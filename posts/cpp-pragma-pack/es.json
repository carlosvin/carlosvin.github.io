{"sectids":"","toc-placement":"auto","notitle":"","stylesheet":"","webfonts":"","prewrap":"","attribute-undefined":"drop-line","attribute-missing":"skip","iconfont-remote":"","caution-caption":"Caution","important-caption":"Important","note-caption":"Note","tip-caption":"Tip","warning-caption":"Warning","example-caption":"Example","figure-caption":"Figure","table-caption":"Table","toc-title":"Table of Contents","section-refsig":"Section","part-refsig":"Part","chapter-refsig":"Chapter","appendix-refsig":"Appendix","appendix-caption":"Appendix","untitled-label":"Untitled","version-label":"Version","last-update-label":"Last updated","docfile":"cpp-pragma-pack.es.adoc","docdir":"","docfilesuffix":".adoc","docname":"cpp-pragma-pack.es","embedded":"","asciidoctor":"","asciidoctor-version":"2.0.10","safe-mode-name":"secure","safe-mode-secure":"","safe-mode-level":20,"max-include-depth":64,"user-home":".","backend":"html5","max-attribute-value-size":4096,"linkcss":"","doctype":"article","htmlsyntax":"html","backend-html5-doctype-article":"","doctype-article":"","backend-html5":"","outfilesuffix":".html","filetype":"html","filetype-html":"","basebackend-html-doctype-article":"","basebackend-html":"","basebackend":"html","stylesdir":".","iconsdir":"./images/icons","localdate":"2020-04-19","localyear":"2020","localtime":"18:31:22 +0200","localdatetime":"2020-04-19 18:31:22 +0200","docdate":"2020-04-19","docyear":"2020","doctime":"10:46:31 +0200","docdatetime":"2020-04-19 10:46:31 +0200","doctitle":"Alineación de una Estructura C++ en Memoria","date":"2012/11/26 12:00:00","keywords":["C++","Performance","Compilers","Memory"],"description":"Comprendiendo cómo funciona la directiva C++ pragma pack y cómo afecta a la alineación de la memoria","lang":"es","previewimage":"/images/c-mem-struct/5b.png","toc":"","authorcount":0,"title":"Alineación de una Estructura C++ en Memoria","summary":"Comprendiendo cómo funciona la directiva C++ pragma pack y cómo afecta a la alineación de la memoria","html":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_estructura_de_ejemplo\">Estructura de ejemplo</a></li>\n<li><a href=\"#_la_directiva_pragma_pack_en_struct_c\">La directiva #pragma pack en struct C++</a></li>\n<li><a href=\"#_rendimiento\">Rendimiento</a></li>\n</ul>\n</div>\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Un struct de C++ es un elemento que permite agrupar elementos de tipos distintos con alguna relación entre ellos. Esto permite manipular todos los elementos en bloque mediante una única referencia. Podemos considerarlo como una clase con visibilidad publica por defecto para sus atributos y funciones.</p>\n</div>\n<div class=\"paragraph\">\n<p>Si alguna vez nos interesa trabajar a un nivel más bajo, nos puede resultar útil entender cómo se mapea una estructura en memoria y cómo controlar este mapeo.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_estructura_de_ejemplo\">Estructura de ejemplo</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Esta estructura estará compuesta por dos campos, un entero (4 bytes) y un booleano (un byte). En C++ queda de la siguiente forma:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-c++\" data-lang=\"c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStruct</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Si hacemos un <code>sizeof</code> de una instancia de la estructura deberíamos obtener un tamaño de 5 bytes. Y la memoria quedaría de la siguiente forma:</p>\n</div>\n<div id=\"5-bytes\" class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/c-mem-struct/5b.png\" alt=\"5Bytes\" width=\"200\" height=\"auto\">\n</div>\n<div class=\"title\">Figure 1. Estructura de 5 bytes que realmente ocupa 5 bytes en memoria</div>\n</div>\n<div class=\"paragraph\">\n<p><strong>Pero</strong> no es tan sencillo, a continuación veremos que no nos podemos olvidar de la alineación de la memoria que hace el compilador en ese sistema y veremos cómo controlarlo para no encontrarnos con tamaños inesperados, ya que esto depende del compilador del sistema.</p>\n</div>\n<div class=\"paragraph\">\n<p>Por ejemplo, si en mi máquina hago un <code>sizeof</code> de la estructura de ejemplo, <strong>obtengo un tamaño de 8 bytes</strong>. Lo que está sucediendo es que el compilador reserva más memoria al final de la estructura para que cuadre en bloques de 2n Bytes. La memoria realmente queda de la siguiente forma:</p>\n</div>\n<div id=\"8-bytes\" class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/c-mem-struct/8b.png\" alt=\"5Bytes\" width=\"200\" height=\"auto\">\n</div>\n<div class=\"title\">Sin pragma: Estructura de 5 Bytes que realmente ocupa 8 Bytes en memoria</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Fragmento de código que imprime el tamaño de la estructura y el de cada uno de sus atributos, en este caso 4 + 1 no es 5</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-c++\" data-lang=\"c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span>  <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStruct</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">size_t</span> sz, <span class=\"hljs-keyword\">size_t</span> sz_flag, <span class=\"hljs-keyword\">size_t</span> sz_timeout)</span>\n</span>{\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"\\tflag: \"</span> &lt;&lt; sz_flag &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"\\t+\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"\\ttimeout: \"</span> &lt;&lt; sz_timeout &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"\\t=\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"\\t\"</span> &lt;&lt; sz_timeout + sz_flag &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt;<span class=\"hljs-string\">\"sizeof struct:  \"</span> &lt;&lt; sz &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[])</span>\n</span>{\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStruct\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">print</span> (<span class=\"hljs-keyword\">sizeof</span>(SampleStruct), <span class=\"hljs-keyword\">sizeof</span>(SampleStruct::flag), <span class=\"hljs-keyword\">sizeof</span>(SampleStruct::timeout));\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" -- \"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\"><a href=\"https://coliru.stacked-crooked.com/a/c7deb3df49bebd40\">Ejecutando el código sin la directiva pragma</a>, tenemos que nuestra estructura ocupa 8 bytes en lugar de 5 bytes.</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-bash\" data-lang=\"bash\">SampleStruct\nflag: 1 Bytes\n+\ntimeout: 4 Bytes\n=\n5 Bytes\nsizeof struct:  8 Bytes\n--</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nSi queremos conocer el tamaño exacto de las estructuras que vamos a utilizar, tenemos que especificar al compilador la forma de alinear la estructura en memoria, para ello utilizaremos la directiva <code>#pragma pack(n)</code>.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_la_directiva_pragma_pack_en_struct_c\">La directiva #pragma pack en struct C++</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Se trata de una directiva del preprocesador que indica al compilador cómo debe realizar la alineación de la memoria.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Ejemplo con diferentes configuraciones de alineamiento de memoria</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-c++\" data-lang=\"c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">size_t</span> sz, <span class=\"hljs-keyword\">size_t</span> sz_flag, <span class=\"hljs-keyword\">size_t</span> sz_timeout)</span>\n</span>{\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" flag: \"</span> &lt;&lt; sz_flag &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span>&lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" +\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" timeout: \"</span> &lt;&lt; sz_timeout &lt;&lt; <span class=\"hljs-string\">\"Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" =\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" \"</span> &lt;&lt; sz_timeout + sz_flag &lt;&lt; <span class=\"hljs-string\">\"Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" sizeof struct:  \"</span> &lt;&lt; sz &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n}\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (1)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack1</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (2)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack2</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (4)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack4</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStruct</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[])</span>\n</span>{\n\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack1\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">print</span> (<span class=\"hljs-keyword\">sizeof</span>(SampleStructPack1), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack1::flag), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack1::timeout));\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" -- \"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack2\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">print</span> (<span class=\"hljs-keyword\">sizeof</span>(SampleStructPack2), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack2::flag), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack2::timeout));\n\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack4\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">print</span> (<span class=\"hljs-keyword\">sizeof</span>(SampleStructPack4), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack4::flag), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack4::timeout));\n\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStruct\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">print</span> (<span class=\"hljs-keyword\">sizeof</span>(SampleStruct), <span class=\"hljs-keyword\">sizeof</span>(SampleStruct::flag), <span class=\"hljs-keyword\">sizeof</span>(SampleStruct::timeout));\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" -- \"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\"><a href=\"https://coliru.stacked-crooked.com/a/7c18ee6585e57366\">Ejecutando el código con las directivas pragma</a>, tenemos distintos resultados dependiendo del valor de pragma.</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-bash\" data-lang=\"bash\">SampleStructPack1 <b class=\"conum\">(1)</b>\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  5 Bytes\n --\n\nSampleStructPack2 <b class=\"conum\">(2)</b>\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  6 Bytes\n\nSampleStructPack4 <b class=\"conum\">(3)</b>\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes\n\nSampleStruct <b class=\"conum\">(4)</b>\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p>SampleStructPack1 <code>#pragma pack (1)</code>: Reserva bloques de memoria de un byte, nuestra estructura se ha ajustado perfectamente; en este caso sí que <code>4 + 1 = 5</code>.</p>\n</li>\n<li>\n<p>SampleStructPack2 <code>#pragma pack (2)</code>: Ahora el mínimo tamaño del bloque de memoria es de 2 bytes. Para el entero, hay un ajuste exacto porque necesita 2 bloques que 2 bytes para alojar sus 4 bytes. Para el caso del booleano, necesita un bloque de 1 byte, pero como mínimo tiene que asignar un bloque de 2 bytes, por eso en total reserva 6 bytes, <code>4 + 2 = 6</code>.</p>\n</li>\n<li>\n<p>SampleStructPack4 <code>#pragma pack (4)</code>: Es el mismo caso que el anterior, aunque en el caso del booleano, hay un mayor \"desperdicio\" de memoria. Necesita 1 byte, pero reserva 4 bytes que es tamaño mínimo de bloque de memoria que puede asignar el compilador.</p>\n</li>\n<li>\n<p>SampleStruct (default compiler alignment): Como vemos se comporta exactamente igual que <code>#pragma pack (4)</code>, podemos deducir que la alineación por defecto del compilador que estamos utilizando es de 4 bytes.</p>\n</li>\n</ol>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Important</div>\n</td>\n<td class=\"content\">\n¿Por qué no utilizamos siempre la alineación de memoria más ajustada (<code>#pragma pack (1)</code>) para aprovechar mejor la memoria?\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Warning</div>\n</td>\n<td class=\"content\">\nPorque perderemos rendimiento.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rendimiento\">Rendimiento</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vamos a hacer una prueba simple de rendimiento, en la que se va a reservar el mismo número de elementos en arrays para cada tipo de estructura.</p>\n</div>\n<div class=\"paragraph\">\n<p>Este es el resultado:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\"><a href=\"https://coliru.stacked-crooked.com/a/954ad542659c7591\">Resultados de la prueba de rendimiento</a>.</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-bash\" data-lang=\"bash\">SampleStructPack1: 500000000000000000 bytes allocated <span class=\"hljs-keyword\">in</span> 94311 nanoseconds\nSampleStructPack2: 600000000000000000 bytes allocated <span class=\"hljs-keyword\">in</span> 1777 nanoseconds\nSampleStructPack4: 800000000000000000 bytes allocated <span class=\"hljs-keyword\">in</span> 1519 nanoseconds</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Como vemos cuanto más ajustada es la alineación de memoria, más tiempo se tarda en reservar y liberar.</p>\n</div>\n<div class=\"paragraph\">\n<p>A continuación pego el código de la prueba de rendimiento.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Código de las pruebas de rendimiento</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-c++\" data-lang=\"c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;chrono&gt;</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (1)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack1</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (2)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack2</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (4)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack4</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStruct</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">long</span> MAX_ELEMENTS = <span class=\"hljs-number\">100000000000000000</span>;\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>::chrono;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">allocate1</span><span class=\"hljs-params\">()</span>\n</span>{\n    SampleStructPack1 elements [MAX_ELEMENTS];\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack1: \"</span> &lt;&lt; <span class=\"hljs-keyword\">sizeof</span>(elements) &lt;&lt; <span class=\"hljs-string\">\" bytes allocated\"</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">allocate2</span><span class=\"hljs-params\">()</span>\n</span>{\n    SampleStructPack2 elements [MAX_ELEMENTS];\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack2: \"</span> &lt;&lt; <span class=\"hljs-keyword\">sizeof</span>(elements) &lt;&lt; <span class=\"hljs-string\">\" bytes allocated\"</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">allocate4</span><span class=\"hljs-params\">()</span>\n</span>{\n    SampleStructPack4 elements [MAX_ELEMENTS];\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack4: \"</span> &lt;&lt; <span class=\"hljs-keyword\">sizeof</span>(elements) &lt;&lt; <span class=\"hljs-string\">\" bytes allocated\"</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">chrono1</span><span class=\"hljs-params\">()</span>\n</span>{\n    <span class=\"hljs-keyword\">auto</span> <span class=\"hljs-built_in\">begin</span> = high_resolution_clock::now() ;\n    allocate1();\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" in \"</span> &lt;&lt; duration_cast&lt;nanoseconds&gt;(high_resolution_clock::now() - <span class=\"hljs-built_in\">begin</span>).count() &lt;&lt; <span class=\"hljs-string\">\" nanoseconds\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">chrono2</span><span class=\"hljs-params\">()</span>\n</span>{\n    <span class=\"hljs-keyword\">auto</span> <span class=\"hljs-built_in\">begin</span> = high_resolution_clock::now() ;\n    allocate2();\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" in \"</span> &lt;&lt; duration_cast&lt;nanoseconds&gt;(high_resolution_clock::now() - <span class=\"hljs-built_in\">begin</span>).count() &lt;&lt; <span class=\"hljs-string\">\" nanoseconds\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">chrono4</span><span class=\"hljs-params\">()</span>\n</span>{\n    <span class=\"hljs-keyword\">auto</span> <span class=\"hljs-built_in\">begin</span> = high_resolution_clock::now() ;\n    allocate4();\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" in \"</span> &lt;&lt; duration_cast&lt;nanoseconds&gt;(high_resolution_clock::now() - <span class=\"hljs-built_in\">begin</span>).count() &lt;&lt; <span class=\"hljs-string\">\" nanoseconds\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n}\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[])</span>\n</span>{\n    chrono1();\n    chrono2();\n    chrono4();\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n</div>\n</div>\n</div>\n</div>","slug":"cpp-pragma-pack"}