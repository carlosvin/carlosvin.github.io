<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=sapper name=generator> <meta content=a22af7614c96254d name=yandex-verification> <link href=/icons/icon-192x192.png rel=apple-touch-icon> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=client/main.2871002379.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>Alineación de una Estructura C++ en Memoria</title><link href=/rss rel=alternate type=application/rss+xml title='Subscribe to Carlos says "bla bla"'><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"Webpage","@id":"https://google.com/article"},"headline":"Alineación de una Estructura C++ en Memoria","alternativeHeadline":"Comprendiendo cómo funciona la directiva C++ pragma pack y cómo afecta a la alineación de la memoria","description":"Comprendiendo cómo funciona la directiva C++ pragma pack y cómo afecta a la alineación de la memoria","image":"/images/c-mem-struct/5b.png","datePublished":"2012-11-26 12:00:00","dateModified":"2012-11-26 12:00:00","keywords":["C++","Performance","Compilers","Memory"],"author":{"@type":"Person","name":"Carlos Martin Sanchez"},"publisher":"Carlos Martin Sanchez"}</script><meta content=2012-11-26 name=date scheme=YYYY-MM-DD><meta content="Comprendiendo cómo funciona la directiva C++ pragma pack y cómo afecta a la alineación de la memoria" name=description><link href=/posts/cpp-pragma-pack/en rel=alternate hreflang=en><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/default.min.css rel=preload as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/default.min.css rel=stylesheet></noscript><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-1hjvhrx><li class=svelte-1y8uoef><a href=/ class=svelte-1y8uoef><img alt='Carlos says "bla bla"' src=/favicon.png class="svelte-1hjvhrx logo"></a></li> <ul class="svelte-1hjvhrx closed"><span class="svelte-1hjvhrx siteName"><li class=svelte-1y8uoef><a href=/ class=svelte-1y8uoef>Carlos says "bla bla"</a></span> <li class=svelte-1y8uoef><a href=/categories class=svelte-1y8uoef>Categories</a></li> <li class=svelte-1y8uoef><a href=/about class=svelte-1y8uoef>About</a></ul> <div class="h svelte-1w8skyw"><a href=/rss class="icon svelte-1lu397 rss" title='Subscribe to Carlos says "bla bla"' rel=noopener target=_blank></a> <a href=https://github.com/carlosvin class="icon svelte-1lu397 github" title="Find me at github" rel=noopener target=_blank></a> <a href=https://twitter.com/carlosvin class="icon svelte-1lu397 twitter" title="Find me at twitter" rel=noopener target=_blank></a> <a href=https://stackoverflow.com/story/carlosvin class="icon svelte-1lu397 stackoverflow" title="Find me at stackoverflow" rel=noopener target=_blank></a></div> <button class=svelte-1hjvhrx>≡</button></nav> <main class=svelte-bvcji9> <header class=svelte-1svctju><h1 class=svelte-1svctju>Alineación de una Estructura C++ en Memoria <span class="svelte-1svctju share"><a href="https://twitter.com/intent/tweet?url=https://carlosvin.github.io/posts/cpp-pragma-pack/es&text=Alineación de una Estructura C++ en Memoria: Comprendiendo cómo funciona la directiva C++ pragma pack y cómo afecta a la alineación de la memoria&hashtags=C++,Performance,Compilers,Memory" class="icon svelte-1lu397 twitter" title='Share "Alineación de una Estructura C++ en Memoria"' rel=noopener target=_blank></a></span></h1> <p class="svelte-1svctju summary">Comprendiendo cómo funciona la directiva C++ pragma pack y cómo afecta a la alineación de la memoria</p> <div class="subtitle svelte-16mbbpz"><span class=date>26/11/2012</span> <span class="summary langs">Available in <span class="lang svelte-k3ijyt"><a href=/posts/cpp-pragma-pack/en rel=prefetch>en</a> </span></span> <span class=svelte-16xp99e><a href=/categories/c class=svelte-1gu8b1d title=C++><span class="hover svelte-1x4e0dt">C++</span></a><a href=/categories/performance class=svelte-1gu8b1d title=Performance><span class="hover svelte-1x4e0dt">Performance</span></a><a href=/categories/compilers class=svelte-1gu8b1d title=Compilers><span class="hover svelte-1x4e0dt">Compilers</span></a><a href=/categories/memory class=svelte-1gu8b1d title=Memory><span class="hover svelte-1x4e0dt">Memory</span></a></span></div></header> <div class="content svelte-1jaj44x"><div class=toc id=toc> <div id=toctitle>Table of Contents</div> <ul class=sectlevel1> <li><a href=#_estructura_de_ejemplo>Estructura de ejemplo</a></li> <li><a href=#_la_directiva_pragma_pack_en_struct_c>La directiva #pragma pack en struct C++</a></li> <li><a href=#_rendimiento>Rendimiento</a></li> </ul> </div> <div id=preamble> <div class=sectionbody> <div class=paragraph> <p>Un struct de C++ es un elemento que permite agrupar elementos de tipos distintos con alguna relación entre ellos. Esto permite manipular todos los elementos en bloque mediante una única referencia. Podemos considerarlo como una clase con visibilidad publica por defecto para sus atributos y funciones.</p> </div> <div class=paragraph> <p>Si alguna vez nos interesa trabajar a un nivel más bajo, nos puede resultar útil entender cómo se mapea una estructura en memoria y cómo controlar este mapeo.</p> </div> </div> </div> <div class=sect1> <h2 id=_estructura_de_ejemplo>Estructura de ejemplo</h2> <div class=sectionbody> <div class=paragraph> <p>Esta estructura estará compuesta por dos campos, un entero (4 bytes) y un booleano (un byte). En C++ queda de la siguiente forma:</p> </div> <div class=listingblock> <div class=content> <pre class=highlight><code class=language-c++ data-lang=c++><span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>SampleStruct</span>
{</span>
    <span class=hljs-keyword>bool</span> flag;
    <span class=hljs-keyword>unsigned</span> <span class=hljs-keyword>int</span> timeout;
};</code></pre> </div> </div> <div class=paragraph> <p>Si hacemos un <code>sizeof</code> de una instancia de la estructura deberíamos obtener un tamaño de 5 bytes. Y la memoria quedaría de la siguiente forma:</p> </div> <div class="center imageblock" id=5-bytes> <div class=content> <img alt=5Bytes src=/images/c-mem-struct/5b.png height=auto width=200> </div> <div class=title>Figure 1. Estructura de 5 bytes que realmente ocupa 5 bytes en memoria</div> </div> <div class=paragraph> <p><strong>Pero</strong> no es tan sencillo, a continuación veremos que no nos podemos olvidar de la alineación de la memoria que hace el compilador en ese sistema y veremos cómo controlarlo para no encontrarnos con tamaños inesperados, ya que esto depende del compilador del sistema.</p> </div> <div class=paragraph> <p>Por ejemplo, si en mi máquina hago un <code>sizeof</code> de la estructura de ejemplo, <strong>obtengo un tamaño de 8 bytes</strong>. Lo que está sucediendo es que el compilador reserva más memoria al final de la estructura para que cuadre en bloques de 2n Bytes. La memoria realmente queda de la siguiente forma:</p> </div> <div class="center imageblock" id=8-bytes> <div class=content> <img alt=5Bytes src=/images/c-mem-struct/8b.png height=auto width=200> </div> <div class=title>Sin pragma: Estructura de 5 Bytes que realmente ocupa 8 Bytes en memoria</div> </div> <div class=listingblock> <div class=title>Fragmento de código que imprime el tamaño de la estructura y el de cada uno de sus atributos, en este caso 4 + 1 no es 5</div> <div class=content> <pre class=highlight><code class=language-c++ data-lang=c++><span class=hljs-meta>#<span class=hljs-meta-keyword>include</span>  <span class=hljs-meta-string>&lt;iostream></span></span>

<span class=hljs-keyword>using</span> <span class=hljs-keyword>namespace</span> <span class=hljs-built_in>std</span>;

<span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>SampleStruct</span>
{</span>
    <span class=hljs-keyword>bool</span> flag;
    <span class=hljs-keyword>unsigned</span> <span class=hljs-keyword>int</span> timeout;
};

<span class=hljs-function><span class=hljs-keyword>static</span> <span class=hljs-keyword>void</span> <span class=hljs-title>print</span> <span class=hljs-params>(<span class=hljs-keyword>size_t</span> sz, <span class=hljs-keyword>size_t</span> sz_flag, <span class=hljs-keyword>size_t</span> sz_timeout)</span>
</span>{
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>"\tflag: "</span> &lt;&lt; sz_flag &lt;&lt; <span class=hljs-string>" Bytes"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>"\t+"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>"\ttimeout: "</span> &lt;&lt; sz_timeout &lt;&lt; <span class=hljs-string>" Bytes"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>"\t="</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>"\t"</span> &lt;&lt; sz_timeout + sz_flag &lt;&lt; <span class=hljs-string>" Bytes"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
    <span class=hljs-built_in>cout</span> &lt;&lt;<span class=hljs-string>"sizeof struct:  "</span> &lt;&lt; sz &lt;&lt; <span class=hljs-string>" Bytes"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
}

<span class=hljs-function><span class=hljs-keyword>int</span> <span class=hljs-title>main</span><span class=hljs-params>(<span class=hljs-keyword>int</span> argc, <span class=hljs-keyword>char</span> *argv[])</span>
</span>{
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>"SampleStruct"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
    <span class=hljs-built_in>print</span> (<span class=hljs-keyword>sizeof</span>(SampleStruct), <span class=hljs-keyword>sizeof</span>(SampleStruct::flag), <span class=hljs-keyword>sizeof</span>(SampleStruct::timeout));
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>" -- "</span> &lt;&lt; <span class=hljs-built_in>endl</span>;

    <span class=hljs-keyword>return</span> <span class=hljs-number>0</span>;
}</code></pre> </div> </div> <div class=listingblock> <div class=title><a href=https://coliru.stacked-crooked.com/a/c7deb3df49bebd40>Ejecutando el código sin la directiva pragma</a>, tenemos que nuestra estructura ocupa 8 bytes en lugar de 5 bytes.</div> <div class=content> <pre class=highlight><code class=language-bash data-lang=bash>SampleStruct
flag: 1 Bytes
+
timeout: 4 Bytes
=
5 Bytes
sizeof struct:  8 Bytes
--</code></pre> </div> </div> <div class="admonitionblock tip"> <table> <tr> <td class=icon> <div class=title>Tip</div> </td> <td class=content> Si queremos conocer el tamaño exacto de las estructuras que vamos a utilizar, tenemos que especificar al compilador la forma de alinear la estructura en memoria, para ello utilizaremos la directiva <code>#pragma pack(n)</code>. </td> </tr> </table> </div> </div> </div> <div class=sect1> <h2 id=_la_directiva_pragma_pack_en_struct_c>La directiva #pragma pack en struct C++</h2> <div class=sectionbody> <div class=paragraph> <p>Se trata de una directiva del preprocesador que indica al compilador cómo debe realizar la alineación de la memoria.</p> </div> <div class=listingblock> <div class=title>Ejemplo con diferentes configuraciones de alineamiento de memoria</div> <div class=content> <pre class=highlight><code class=language-c++ data-lang=c++><span class=hljs-meta>#<span class=hljs-meta-keyword>include</span> <span class=hljs-meta-string>&lt;iostream></span></span>

<span class=hljs-keyword>using</span> <span class=hljs-keyword>namespace</span> <span class=hljs-built_in>std</span>;

<span class=hljs-function><span class=hljs-keyword>static</span> <span class=hljs-keyword>void</span> <span class=hljs-title>print</span> <span class=hljs-params>(<span class=hljs-keyword>size_t</span> sz, <span class=hljs-keyword>size_t</span> sz_flag, <span class=hljs-keyword>size_t</span> sz_timeout)</span>
</span>{
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>" flag: "</span> &lt;&lt; sz_flag &lt;&lt; <span class=hljs-string>" Bytes"</span>&lt;&lt; <span class=hljs-built_in>endl</span>;
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>" +"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>" timeout: "</span> &lt;&lt; sz_timeout &lt;&lt; <span class=hljs-string>"Bytes"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>" ="</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>" "</span> &lt;&lt; sz_timeout + sz_flag &lt;&lt; <span class=hljs-string>"Bytes"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>" sizeof struct:  "</span> &lt;&lt; sz &lt;&lt; <span class=hljs-string>" Bytes"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
}

<span class=hljs-meta>#<span class=hljs-meta-keyword>pragma</span> pack (1)</span>
<span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>SampleStructPack1</span>
{</span>
    <span class=hljs-keyword>bool</span> flag;
    <span class=hljs-keyword>unsigned</span> <span class=hljs-keyword>int</span> timeout;
};
<span class=hljs-meta>#<span class=hljs-meta-keyword>pragma</span> pack(0)</span>

<span class=hljs-meta>#<span class=hljs-meta-keyword>pragma</span> pack (2)</span>
<span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>SampleStructPack2</span>
{</span>
    <span class=hljs-keyword>bool</span> flag;
    <span class=hljs-keyword>unsigned</span> <span class=hljs-keyword>int</span> timeout;
};
<span class=hljs-meta>#<span class=hljs-meta-keyword>pragma</span> pack(0)</span>

<span class=hljs-meta>#<span class=hljs-meta-keyword>pragma</span> pack (4)</span>
<span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>SampleStructPack4</span>
{</span>
    <span class=hljs-keyword>bool</span> flag;
    <span class=hljs-keyword>unsigned</span> <span class=hljs-keyword>int</span> timeout;
};
<span class=hljs-meta>#<span class=hljs-meta-keyword>pragma</span> pack(0)</span>


<span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>SampleStruct</span>
{</span>
    <span class=hljs-keyword>bool</span> flag;
    <span class=hljs-keyword>unsigned</span> <span class=hljs-keyword>int</span> timeout;
};


<span class=hljs-function><span class=hljs-keyword>int</span> <span class=hljs-title>main</span><span class=hljs-params>(<span class=hljs-keyword>int</span> argc, <span class=hljs-keyword>char</span> *argv[])</span>
</span>{

    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>"SampleStructPack1"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
    <span class=hljs-built_in>print</span> (<span class=hljs-keyword>sizeof</span>(SampleStructPack1), <span class=hljs-keyword>sizeof</span>(SampleStructPack1::flag), <span class=hljs-keyword>sizeof</span>(SampleStructPack1::timeout));
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>" -- "</span> &lt;&lt; <span class=hljs-built_in>endl</span>;

    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>"SampleStructPack2"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
    <span class=hljs-built_in>print</span> (<span class=hljs-keyword>sizeof</span>(SampleStructPack2), <span class=hljs-keyword>sizeof</span>(SampleStructPack2::flag), <span class=hljs-keyword>sizeof</span>(SampleStructPack2::timeout));

    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>"SampleStructPack4"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
    <span class=hljs-built_in>print</span> (<span class=hljs-keyword>sizeof</span>(SampleStructPack4), <span class=hljs-keyword>sizeof</span>(SampleStructPack4::flag), <span class=hljs-keyword>sizeof</span>(SampleStructPack4::timeout));

    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>"SampleStruct"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
    <span class=hljs-built_in>print</span> (<span class=hljs-keyword>sizeof</span>(SampleStruct), <span class=hljs-keyword>sizeof</span>(SampleStruct::flag), <span class=hljs-keyword>sizeof</span>(SampleStruct::timeout));
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>" -- "</span> &lt;&lt; <span class=hljs-built_in>endl</span>;

    <span class=hljs-keyword>return</span> <span class=hljs-number>0</span>;
}</code></pre> </div> </div> <div class=listingblock> <div class=title><a href=https://coliru.stacked-crooked.com/a/7c18ee6585e57366>Ejecutando el código con las directivas pragma</a>, tenemos distintos resultados dependiendo del valor de pragma.</div> <div class=content> <pre class=highlight><code class=language-bash data-lang=bash>SampleStructPack1 <b class=conum>(1)</b>
 flag: 1 Bytes
 +
 timeout: 4Bytes
 =
 5Bytes
 sizeof struct:  5 Bytes
 --

SampleStructPack2 <b class=conum>(2)</b>
 flag: 1 Bytes
 +
 timeout: 4Bytes
 =
 5Bytes
 sizeof struct:  6 Bytes

SampleStructPack4 <b class=conum>(3)</b>
 flag: 1 Bytes
 +
 timeout: 4Bytes
 =
 5Bytes
 sizeof struct:  8 Bytes

SampleStruct <b class=conum>(4)</b>
 flag: 1 Bytes
 +
 timeout: 4Bytes
 =
 5Bytes
 sizeof struct:  8 Bytes</code></pre> </div> </div> <div class="arabic colist"> <ol> <li> <p>SampleStructPack1 <code>#pragma pack (1)</code>: Reserva bloques de memoria de un byte, nuestra estructura se ha ajustado perfectamente; en este caso sí que <code>4 + 1 = 5</code>.</p> </li> <li> <p>SampleStructPack2 <code>#pragma pack (2)</code>: Ahora el mínimo tamaño del bloque de memoria es de 2 bytes. Para el entero, hay un ajuste exacto porque necesita 2 bloques que 2 bytes para alojar sus 4 bytes. Para el caso del booleano, necesita un bloque de 1 byte, pero como mínimo tiene que asignar un bloque de 2 bytes, por eso en total reserva 6 bytes, <code>4 + 2 = 6</code>.</p> </li> <li> <p>SampleStructPack4 <code>#pragma pack (4)</code>: Es el mismo caso que el anterior, aunque en el caso del booleano, hay un mayor "desperdicio" de memoria. Necesita 1 byte, pero reserva 4 bytes que es tamaño mínimo de bloque de memoria que puede asignar el compilador.</p> </li> <li> <p>SampleStruct (default compiler alignment): Como vemos se comporta exactamente igual que <code>#pragma pack (4)</code>, podemos deducir que la alineación por defecto del compilador que estamos utilizando es de 4 bytes.</p> </li> </ol> </div> <div class="admonitionblock important"> <table> <tr> <td class=icon> <div class=title>Important</div> </td> <td class=content> ¿Por qué no utilizamos siempre la alineación de memoria más ajustada (<code>#pragma pack (1)</code>) para aprovechar mejor la memoria? </td> </tr> </table> </div> <div class="admonitionblock warning"> <table> <tr> <td class=icon> <div class=title>Warning</div> </td> <td class=content> Porque perderemos rendimiento. </td> </tr> </table> </div> </div> </div> <div class=sect1> <h2 id=_rendimiento>Rendimiento</h2> <div class=sectionbody> <div class=paragraph> <p>Vamos a hacer una prueba simple de rendimiento, en la que se va a reservar el mismo número de elementos en arrays para cada tipo de estructura.</p> </div> <div class=paragraph> <p>Este es el resultado:</p> </div> <div class=listingblock> <div class=title><a href=https://coliru.stacked-crooked.com/a/954ad542659c7591>Resultados de la prueba de rendimiento</a>.</div> <div class=content> <pre class=highlight><code class=language-bash data-lang=bash>SampleStructPack1: 500000000000000000 bytes allocated <span class=hljs-keyword>in</span> 94311 nanoseconds
SampleStructPack2: 600000000000000000 bytes allocated <span class=hljs-keyword>in</span> 1777 nanoseconds
SampleStructPack4: 800000000000000000 bytes allocated <span class=hljs-keyword>in</span> 1519 nanoseconds</code></pre> </div> </div> <div class=paragraph> <p>Como vemos cuanto más ajustada es la alineación de memoria, más tiempo se tarda en reservar y liberar.</p> </div> <div class=paragraph> <p>A continuación pego el código de la prueba de rendimiento.</p> </div> <div class=listingblock> <div class=title>Código de las pruebas de rendimiento</div> <div class=content> <pre class=highlight><code class=language-c++ data-lang=c++><span class=hljs-meta>#<span class=hljs-meta-keyword>include</span> <span class=hljs-meta-string>&lt;iostream></span></span>
<span class=hljs-meta>#<span class=hljs-meta-keyword>include</span> <span class=hljs-meta-string>&lt;chrono></span></span>

<span class=hljs-meta>#<span class=hljs-meta-keyword>pragma</span> pack (1)</span>
<span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>SampleStructPack1</span>
{</span>
    <span class=hljs-keyword>bool</span> flag;
    <span class=hljs-keyword>unsigned</span> <span class=hljs-keyword>int</span> timeout;
};
<span class=hljs-meta>#<span class=hljs-meta-keyword>pragma</span> pack(0)</span>

<span class=hljs-meta>#<span class=hljs-meta-keyword>pragma</span> pack (2)</span>
<span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>SampleStructPack2</span>
{</span>
    <span class=hljs-keyword>bool</span> flag;
    <span class=hljs-keyword>unsigned</span> <span class=hljs-keyword>int</span> timeout;
};
<span class=hljs-meta>#<span class=hljs-meta-keyword>pragma</span> pack(0)</span>

<span class=hljs-meta>#<span class=hljs-meta-keyword>pragma</span> pack (4)</span>
<span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>SampleStructPack4</span>
{</span>
    <span class=hljs-keyword>bool</span> flag;
    <span class=hljs-keyword>unsigned</span> <span class=hljs-keyword>int</span> timeout;
};
<span class=hljs-meta>#<span class=hljs-meta-keyword>pragma</span> pack(0)</span>


<span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>SampleStruct</span>
{</span>
    <span class=hljs-keyword>bool</span> flag;
    <span class=hljs-keyword>unsigned</span> <span class=hljs-keyword>int</span> timeout;
};

<span class=hljs-keyword>static</span> <span class=hljs-keyword>const</span> <span class=hljs-keyword>long</span> MAX_ELEMENTS = <span class=hljs-number>100000000000000000</span>;
<span class=hljs-keyword>using</span> <span class=hljs-keyword>namespace</span> <span class=hljs-built_in>std</span>;
<span class=hljs-keyword>using</span> <span class=hljs-keyword>namespace</span> <span class=hljs-built_in>std</span>::chrono;

<span class=hljs-function><span class=hljs-keyword>void</span> <span class=hljs-title>allocate1</span><span class=hljs-params>()</span>
</span>{
    SampleStructPack1 elements [MAX_ELEMENTS];
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>"SampleStructPack1: "</span> &lt;&lt; <span class=hljs-keyword>sizeof</span>(elements) &lt;&lt; <span class=hljs-string>" bytes allocated"</span>;
}

<span class=hljs-function><span class=hljs-keyword>void</span> <span class=hljs-title>allocate2</span><span class=hljs-params>()</span>
</span>{
    SampleStructPack2 elements [MAX_ELEMENTS];
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>"SampleStructPack2: "</span> &lt;&lt; <span class=hljs-keyword>sizeof</span>(elements) &lt;&lt; <span class=hljs-string>" bytes allocated"</span>;
}

<span class=hljs-function><span class=hljs-keyword>void</span> <span class=hljs-title>allocate4</span><span class=hljs-params>()</span>
</span>{
    SampleStructPack4 elements [MAX_ELEMENTS];
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>"SampleStructPack4: "</span> &lt;&lt; <span class=hljs-keyword>sizeof</span>(elements) &lt;&lt; <span class=hljs-string>" bytes allocated"</span>;
}

<span class=hljs-function><span class=hljs-keyword>void</span> <span class=hljs-title>chrono1</span><span class=hljs-params>()</span>
</span>{
    <span class=hljs-keyword>auto</span> <span class=hljs-built_in>begin</span> = high_resolution_clock::now() ;
    allocate1();
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>" in "</span> &lt;&lt; duration_cast&lt;nanoseconds>(high_resolution_clock::now() - <span class=hljs-built_in>begin</span>).count() &lt;&lt; <span class=hljs-string>" nanoseconds"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
}

<span class=hljs-function><span class=hljs-keyword>void</span> <span class=hljs-title>chrono2</span><span class=hljs-params>()</span>
</span>{
    <span class=hljs-keyword>auto</span> <span class=hljs-built_in>begin</span> = high_resolution_clock::now() ;
    allocate2();
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>" in "</span> &lt;&lt; duration_cast&lt;nanoseconds>(high_resolution_clock::now() - <span class=hljs-built_in>begin</span>).count() &lt;&lt; <span class=hljs-string>" nanoseconds"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
}

<span class=hljs-function><span class=hljs-keyword>void</span> <span class=hljs-title>chrono4</span><span class=hljs-params>()</span>
</span>{
    <span class=hljs-keyword>auto</span> <span class=hljs-built_in>begin</span> = high_resolution_clock::now() ;
    allocate4();
    <span class=hljs-built_in>cout</span> &lt;&lt; <span class=hljs-string>" in "</span> &lt;&lt; duration_cast&lt;nanoseconds>(high_resolution_clock::now() - <span class=hljs-built_in>begin</span>).count() &lt;&lt; <span class=hljs-string>" nanoseconds"</span> &lt;&lt; <span class=hljs-built_in>endl</span>;
}


<span class=hljs-function><span class=hljs-keyword>int</span> <span class=hljs-title>main</span><span class=hljs-params>(<span class=hljs-keyword>int</span> argc, <span class=hljs-keyword>char</span> *argv[])</span>
</span>{
    chrono1();
    chrono2();
    chrono4();

    <span class=hljs-keyword>return</span> <span class=hljs-number>0</span>;
}</code></pre> </div> </div> </div> </div></div></main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.858979d0.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main","/client/client.858979d0.js")}document.head.appendChild(s)</script> <script async defer> (function (i, s, o, g, r, a, m) {
		i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
			(i[r].q = i[r].q || []).push(arguments)
		}, i[r].l = 1 * new Date(); a = s.createElement(o),
			m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
		})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

		ga('create', 'UA-1328360-10', 'auto');
		ga('send', 'pageview'); </script> 