{"type":"data","nodes":[null,{"type":"data","data":[{"path":1,"lang":2,"translations":3,"version":14},"/langs/es/posts/cpp-pragma-pack/","es",{"lang":2,"author":4,"siteName":5,"siteDescription":6,"categories":7,"Categories":8,"RecentPosts":9,"NoPosts":10,"SubscribeTo":11,"AboutMe":12,"AllPosts":13},"Carlos Martin Sanchez","Carlos dice bla bla","Qué está pasando por mi cabeza y alrededores","categorías","Categorías","Últimas entradas","No hay entradas","Suscríbete al feed","Sobre mi","Todas las entradas","1.0.1"],"uses":{"params":["lang"],"url":1},"slash":"always"},{"type":"data","data":[{"html":1,"props":2,"jsonLd":20},"\u003Cdiv id=\"toc\" class=\"toc\">\n\u003Cdiv id=\"toctitle\">Table of Contents\u003C/div>\n\u003Cul class=\"sectlevel1\">\n\u003Cli>\u003Ca href=\"#_estructura_de_ejemplo\">Estructura de ejemplo\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#_la_directiva_pragma_pack_en_struct_c\">La directiva #pragma pack en struct C++\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#_rendimiento\">Rendimiento\u003C/a>\u003C/li>\n\u003C/ul>\n\u003C/div>\n\u003Cdiv id=\"preamble\">\n\u003Cdiv class=\"sectionbody\">\n\u003Cdiv class=\"paragraph\">\n\u003Cp>Un struct de C++ es un elemento que permite agrupar elementos de tipos distintos con alguna relación entre ellos. Esto permite manipular todos los elementos en bloque mediante una única referencia. Podemos considerarlo como una clase con visibilidad publica por defecto para sus atributos y funciones.\u003C/p>\n\u003C/div>\n\u003Cdiv class=\"paragraph\">\n\u003Cp>Si alguna vez nos interesa trabajar a un nivel más bajo, nos puede resultar útil entender cómo se mapea una estructura en memoria y cómo controlar este mapeo.\u003C/p>\n\u003C/div>\n\u003C/div>\n\u003C/div>\n\u003Cdiv class=\"sect1\">\n\u003Ch2 id=\"_estructura_de_ejemplo\">Estructura de ejemplo\u003C/h2>\n\u003Cdiv class=\"sectionbody\">\n\u003Cdiv class=\"paragraph\">\n\u003Cp>Esta estructura estará compuesta por dos campos, un entero (4 bytes) y un booleano (un byte). En C++ queda de la siguiente forma:\u003C/p>\n\u003C/div>\n\u003Cdiv class=\"listingblock\">\n\u003Cdiv class=\"content\">\n\u003Cpre class=\"highlight\">\u003Ccode class=\"language-c++\" data-lang=\"c++\">\u003Cspan class=\"hljs-keyword\">struct\u003C/span> \u003Cspan class=\"hljs-title class_\">SampleStruct\u003C/span>\n{\n    \u003Cspan class=\"hljs-type\">bool\u003C/span> flag;\n    \u003Cspan class=\"hljs-type\">unsigned\u003C/span> \u003Cspan class=\"hljs-type\">int\u003C/span> timeout;\n};\u003C/code>\u003C/pre>\n\u003C/div>\n\u003C/div>\n\u003Cdiv class=\"paragraph\">\n\u003Cp>Si hacemos un \u003Ccode>sizeof\u003C/code> de una instancia de la estructura deberíamos obtener un tamaño de 5 bytes. Y la memoria quedaría de la siguiente forma:\u003C/p>\n\u003C/div>\n\u003Cdiv id=\"5-bytes\" class=\"imageblock center\">\n\u003Cdiv class=\"content\">\n\u003Cimg src=\"/posts/cpp-pragma-pack/5b.png\" alt=\"5Bytes\" width=\"200\" height=\"auto\">\n\u003C/div>\n\u003Cdiv class=\"title\">Figure 1. Estructura de 5 bytes que realmente ocupa 5 bytes en memoria\u003C/div>\n\u003C/div>\n\u003Cdiv class=\"paragraph\">\n\u003Cp>\u003Cstrong>Pero\u003C/strong> no es tan sencillo, a continuación veremos que no nos podemos olvidar de la alineación de la memoria que hace el compilador en ese sistema y veremos cómo controlarlo para no encontrarnos con tamaños inesperados, ya que esto depende del compilador del sistema.\u003C/p>\n\u003C/div>\n\u003Cdiv class=\"paragraph\">\n\u003Cp>Por ejemplo, si en mi máquina hago un \u003Ccode>sizeof\u003C/code> de la estructura de ejemplo, \u003Cstrong>obtengo un tamaño de 8 bytes\u003C/strong>. Lo que está sucediendo es que el compilador reserva más memoria al final de la estructura para que cuadre en bloques de 2n Bytes. La memoria realmente queda de la siguiente forma:\u003C/p>\n\u003C/div>\n\u003Cdiv id=\"8-bytes\" class=\"imageblock center\">\n\u003Cdiv class=\"content\">\n\u003Cimg src=\"/posts/cpp-pragma-pack/8b.png\" alt=\"5Bytes\" width=\"200\" height=\"auto\">\n\u003C/div>\n\u003Cdiv class=\"title\">Sin pragma: Estructura de 5 Bytes que realmente ocupa 8 Bytes en memoria\u003C/div>\n\u003C/div>\n\u003Cdiv class=\"listingblock\">\n\u003Cdiv class=\"title\">Fragmento de código que imprime el tamaño de la estructura y el de cada uno de sus atributos, en este caso 4 + 1 no es 5\u003C/div>\n\u003Cdiv class=\"content\">\n\u003Cpre class=\"highlight\">\u003Ccode class=\"language-c++\" data-lang=\"c++\">\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">include\u003C/span>  \u003Cspan class=\"hljs-string\">&lt;iostream&gt;\u003C/span>\u003C/span>\n\n\u003Cspan class=\"hljs-keyword\">using\u003C/span> \u003Cspan class=\"hljs-keyword\">namespace\u003C/span> std;\n\n\u003Cspan class=\"hljs-keyword\">struct\u003C/span> \u003Cspan class=\"hljs-title class_\">SampleStruct\u003C/span>\n{\n    \u003Cspan class=\"hljs-type\">bool\u003C/span> flag;\n    \u003Cspan class=\"hljs-type\">unsigned\u003C/span> \u003Cspan class=\"hljs-type\">int\u003C/span> timeout;\n};\n\n\u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-type\">static\u003C/span> \u003Cspan class=\"hljs-type\">void\u003C/span> \u003Cspan class=\"hljs-title\">print\u003C/span> \u003Cspan class=\"hljs-params\">(\u003Cspan class=\"hljs-type\">size_t\u003C/span> sz, \u003Cspan class=\"hljs-type\">size_t\u003C/span> sz_flag, \u003Cspan class=\"hljs-type\">size_t\u003C/span> sz_timeout)\u003C/span>\n\u003C/span>{\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot;\\tflag: &quot;\u003C/span> &lt;&lt; sz_flag &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; Bytes&quot;\u003C/span> &lt;&lt; endl;\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot;\\t+&quot;\u003C/span> &lt;&lt; endl;\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot;\\ttimeout: &quot;\u003C/span> &lt;&lt; sz_timeout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; Bytes&quot;\u003C/span> &lt;&lt; endl;\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot;\\t=&quot;\u003C/span> &lt;&lt; endl;\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot;\\t&quot;\u003C/span> &lt;&lt; sz_timeout + sz_flag &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; Bytes&quot;\u003C/span> &lt;&lt; endl;\n    cout &lt;&lt;\u003Cspan class=\"hljs-string\">&quot;sizeof struct:  &quot;\u003C/span> &lt;&lt; sz &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; Bytes&quot;\u003C/span> &lt;&lt; endl;\n}\n\n\u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-type\">int\u003C/span> \u003Cspan class=\"hljs-title\">main\u003C/span>\u003Cspan class=\"hljs-params\">(\u003Cspan class=\"hljs-type\">int\u003C/span> argc, \u003Cspan class=\"hljs-type\">char\u003C/span> *argv[])\u003C/span>\n\u003C/span>{\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot;SampleStruct&quot;\u003C/span> &lt;&lt; endl;\n    \u003Cspan class=\"hljs-built_in\">print\u003C/span> (\u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(SampleStruct), \u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(SampleStruct::flag), \u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(SampleStruct::timeout));\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; -- &quot;\u003C/span> &lt;&lt; endl;\n\n    \u003Cspan class=\"hljs-keyword\">return\u003C/span> \u003Cspan class=\"hljs-number\">0\u003C/span>;\n}\u003C/code>\u003C/pre>\n\u003C/div>\n\u003C/div>\n\u003Cdiv class=\"listingblock\">\n\u003Cdiv class=\"title\">\u003Ca href=\"https://coliru.stacked-crooked.com/a/c7deb3df49bebd40\">Ejecutando el código sin la directiva pragma\u003C/a>, tenemos que nuestra estructura ocupa 8 bytes en lugar de 5 bytes.\u003C/div>\n\u003Cdiv class=\"content\">\n\u003Cpre class=\"highlight\">\u003Ccode class=\"language-bash\" data-lang=\"bash\">SampleStruct\nflag: 1 Bytes\n+\n\u003Cspan class=\"hljs-built_in\">timeout\u003C/span>: 4 Bytes\n=\n5 Bytes\nsizeof struct:  8 Bytes\n--\u003C/code>\u003C/pre>\n\u003C/div>\n\u003C/div>\n\u003Cdiv class=\"admonitionblock tip\">\n\u003Ctable>\n\u003Ctr>\n\u003Ctd class=\"icon\">\n\u003Cdiv class=\"title\">Tip\u003C/div>\n\u003C/td>\n\u003Ctd class=\"content\">\nSi queremos conocer el tamaño exacto de las estructuras que vamos a utilizar, tenemos que especificar al compilador la forma de alinear la estructura en memoria, para ello utilizaremos la directiva \u003Ccode>#pragma pack(n)\u003C/code>.\n\u003C/td>\n\u003C/tr>\n\u003C/table>\n\u003C/div>\n\u003C/div>\n\u003C/div>\n\u003Cdiv class=\"sect1\">\n\u003Ch2 id=\"_la_directiva_pragma_pack_en_struct_c\">La directiva #pragma pack en struct C++\u003C/h2>\n\u003Cdiv class=\"sectionbody\">\n\u003Cdiv class=\"paragraph\">\n\u003Cp>Se trata de una directiva del preprocesador que indica al compilador cómo debe realizar la alineación de la memoria.\u003C/p>\n\u003C/div>\n\u003Cdiv class=\"listingblock\">\n\u003Cdiv class=\"title\">Ejemplo con diferentes configuraciones de alineamiento de memoria\u003C/div>\n\u003Cdiv class=\"content\">\n\u003Cpre class=\"highlight\">\u003Ccode class=\"language-c++\" data-lang=\"c++\">\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">include\u003C/span> \u003Cspan class=\"hljs-string\">&lt;iostream&gt;\u003C/span>\u003C/span>\n\n\u003Cspan class=\"hljs-keyword\">using\u003C/span> \u003Cspan class=\"hljs-keyword\">namespace\u003C/span> std;\n\n\u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-type\">static\u003C/span> \u003Cspan class=\"hljs-type\">void\u003C/span> \u003Cspan class=\"hljs-title\">print\u003C/span> \u003Cspan class=\"hljs-params\">(\u003Cspan class=\"hljs-type\">size_t\u003C/span> sz, \u003Cspan class=\"hljs-type\">size_t\u003C/span> sz_flag, \u003Cspan class=\"hljs-type\">size_t\u003C/span> sz_timeout)\u003C/span>\n\u003C/span>{\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; flag: &quot;\u003C/span> &lt;&lt; sz_flag &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; Bytes&quot;\u003C/span>&lt;&lt; endl;\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; +&quot;\u003C/span> &lt;&lt; endl;\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; timeout: &quot;\u003C/span> &lt;&lt; sz_timeout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot;Bytes&quot;\u003C/span> &lt;&lt; endl;\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; =&quot;\u003C/span> &lt;&lt; endl;\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; &quot;\u003C/span> &lt;&lt; sz_timeout + sz_flag &lt;&lt; \u003Cspan class=\"hljs-string\">&quot;Bytes&quot;\u003C/span> &lt;&lt; endl;\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; sizeof struct:  &quot;\u003C/span> &lt;&lt; sz &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; Bytes&quot;\u003C/span> &lt;&lt; endl;\n}\n\n\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">pragma\u003C/span> pack (1)\u003C/span>\n\u003Cspan class=\"hljs-keyword\">struct\u003C/span> \u003Cspan class=\"hljs-title class_\">SampleStructPack1\u003C/span>\n{\n    \u003Cspan class=\"hljs-type\">bool\u003C/span> flag;\n    \u003Cspan class=\"hljs-type\">unsigned\u003C/span> \u003Cspan class=\"hljs-type\">int\u003C/span> timeout;\n};\n\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">pragma\u003C/span> pack(0)\u003C/span>\n\n\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">pragma\u003C/span> pack (2)\u003C/span>\n\u003Cspan class=\"hljs-keyword\">struct\u003C/span> \u003Cspan class=\"hljs-title class_\">SampleStructPack2\u003C/span>\n{\n    \u003Cspan class=\"hljs-type\">bool\u003C/span> flag;\n    \u003Cspan class=\"hljs-type\">unsigned\u003C/span> \u003Cspan class=\"hljs-type\">int\u003C/span> timeout;\n};\n\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">pragma\u003C/span> pack(0)\u003C/span>\n\n\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">pragma\u003C/span> pack (4)\u003C/span>\n\u003Cspan class=\"hljs-keyword\">struct\u003C/span> \u003Cspan class=\"hljs-title class_\">SampleStructPack4\u003C/span>\n{\n    \u003Cspan class=\"hljs-type\">bool\u003C/span> flag;\n    \u003Cspan class=\"hljs-type\">unsigned\u003C/span> \u003Cspan class=\"hljs-type\">int\u003C/span> timeout;\n};\n\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">pragma\u003C/span> pack(0)\u003C/span>\n\n\n\u003Cspan class=\"hljs-keyword\">struct\u003C/span> \u003Cspan class=\"hljs-title class_\">SampleStruct\u003C/span>\n{\n    \u003Cspan class=\"hljs-type\">bool\u003C/span> flag;\n    \u003Cspan class=\"hljs-type\">unsigned\u003C/span> \u003Cspan class=\"hljs-type\">int\u003C/span> timeout;\n};\n\n\n\u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-type\">int\u003C/span> \u003Cspan class=\"hljs-title\">main\u003C/span>\u003Cspan class=\"hljs-params\">(\u003Cspan class=\"hljs-type\">int\u003C/span> argc, \u003Cspan class=\"hljs-type\">char\u003C/span> *argv[])\u003C/span>\n\u003C/span>{\n\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot;SampleStructPack1&quot;\u003C/span> &lt;&lt; endl;\n    \u003Cspan class=\"hljs-built_in\">print\u003C/span> (\u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(SampleStructPack1), \u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(SampleStructPack1::flag), \u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(SampleStructPack1::timeout));\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; -- &quot;\u003C/span> &lt;&lt; endl;\n\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot;SampleStructPack2&quot;\u003C/span> &lt;&lt; endl;\n    \u003Cspan class=\"hljs-built_in\">print\u003C/span> (\u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(SampleStructPack2), \u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(SampleStructPack2::flag), \u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(SampleStructPack2::timeout));\n\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot;SampleStructPack4&quot;\u003C/span> &lt;&lt; endl;\n    \u003Cspan class=\"hljs-built_in\">print\u003C/span> (\u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(SampleStructPack4), \u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(SampleStructPack4::flag), \u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(SampleStructPack4::timeout));\n\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot;SampleStruct&quot;\u003C/span> &lt;&lt; endl;\n    \u003Cspan class=\"hljs-built_in\">print\u003C/span> (\u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(SampleStruct), \u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(SampleStruct::flag), \u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(SampleStruct::timeout));\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; -- &quot;\u003C/span> &lt;&lt; endl;\n\n    \u003Cspan class=\"hljs-keyword\">return\u003C/span> \u003Cspan class=\"hljs-number\">0\u003C/span>;\n}\u003C/code>\u003C/pre>\n\u003C/div>\n\u003C/div>\n\u003Cdiv class=\"listingblock\">\n\u003Cdiv class=\"title\">\u003Ca href=\"https://coliru.stacked-crooked.com/a/7c18ee6585e57366\">Ejecutando el código con las directivas pragma\u003C/a>, tenemos distintos resultados dependiendo del valor de pragma.\u003C/div>\n\u003Cdiv class=\"content\">\n\u003Cpre class=\"highlight\">\u003Ccode class=\"language-bash\" data-lang=\"bash\">SampleStructPack1 \u003Cb class=\"conum\">(1)\u003C/b>\n flag: 1 Bytes\n +\n \u003Cspan class=\"hljs-built_in\">timeout\u003C/span>: 4Bytes\n =\n 5Bytes\n sizeof struct:  5 Bytes\n --\n\nSampleStructPack2 \u003Cb class=\"conum\">(2)\u003C/b>\n flag: 1 Bytes\n +\n \u003Cspan class=\"hljs-built_in\">timeout\u003C/span>: 4Bytes\n =\n 5Bytes\n sizeof struct:  6 Bytes\n\nSampleStructPack4 \u003Cb class=\"conum\">(3)\u003C/b>\n flag: 1 Bytes\n +\n \u003Cspan class=\"hljs-built_in\">timeout\u003C/span>: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes\n\nSampleStruct \u003Cb class=\"conum\">(4)\u003C/b>\n flag: 1 Bytes\n +\n \u003Cspan class=\"hljs-built_in\">timeout\u003C/span>: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes\u003C/code>\u003C/pre>\n\u003C/div>\n\u003C/div>\n\u003Cdiv class=\"colist arabic\">\n\u003Col>\n\u003Cli>\n\u003Cp>SampleStructPack1 \u003Ccode>#pragma pack (1)\u003C/code>: Reserva bloques de memoria de un byte, nuestra estructura se ha ajustado perfectamente; en este caso sí que \u003Ccode>4 + 1 = 5\u003C/code>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>SampleStructPack2 \u003Ccode>#pragma pack (2)\u003C/code>: Ahora el mínimo tamaño del bloque de memoria es de 2 bytes. Para el entero, hay un ajuste exacto porque necesita 2 bloques que 2 bytes para alojar sus 4 bytes. Para el caso del booleano, necesita un bloque de 1 byte, pero como mínimo tiene que asignar un bloque de 2 bytes, por eso en total reserva 6 bytes, \u003Ccode>4 + 2 = 6\u003C/code>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>SampleStructPack4 \u003Ccode>#pragma pack (4)\u003C/code>: Es el mismo caso que el anterior, aunque en el caso del booleano, hay un mayor \"desperdicio\" de memoria. Necesita 1 byte, pero reserva 4 bytes que es tamaño mínimo de bloque de memoria que puede asignar el compilador.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>SampleStruct (default compiler alignment): Como vemos se comporta exactamente igual que \u003Ccode>#pragma pack (4)\u003C/code>, podemos deducir que la alineación por defecto del compilador que estamos utilizando es de 4 bytes.\u003C/p>\n\u003C/li>\n\u003C/ol>\n\u003C/div>\n\u003Cdiv class=\"admonitionblock important\">\n\u003Ctable>\n\u003Ctr>\n\u003Ctd class=\"icon\">\n\u003Cdiv class=\"title\">Important\u003C/div>\n\u003C/td>\n\u003Ctd class=\"content\">\n¿Por qué no utilizamos siempre la alineación de memoria más ajustada (\u003Ccode>#pragma pack (1)\u003C/code>) para aprovechar mejor la memoria?\n\u003C/td>\n\u003C/tr>\n\u003C/table>\n\u003C/div>\n\u003Cdiv class=\"admonitionblock warning\">\n\u003Ctable>\n\u003Ctr>\n\u003Ctd class=\"icon\">\n\u003Cdiv class=\"title\">Warning\u003C/div>\n\u003C/td>\n\u003Ctd class=\"content\">\nPorque perderemos rendimiento.\n\u003C/td>\n\u003C/tr>\n\u003C/table>\n\u003C/div>\n\u003C/div>\n\u003C/div>\n\u003Cdiv class=\"sect1\">\n\u003Ch2 id=\"_rendimiento\">Rendimiento\u003C/h2>\n\u003Cdiv class=\"sectionbody\">\n\u003Cdiv class=\"paragraph\">\n\u003Cp>Vamos a hacer una prueba simple de rendimiento, en la que se va a reservar el mismo número de elementos en arrays para cada tipo de estructura.\u003C/p>\n\u003C/div>\n\u003Cdiv class=\"paragraph\">\n\u003Cp>Este es el resultado:\u003C/p>\n\u003C/div>\n\u003Cdiv class=\"listingblock\">\n\u003Cdiv class=\"title\">\u003Ca href=\"https://coliru.stacked-crooked.com/a/954ad542659c7591\">Resultados de la prueba de rendimiento\u003C/a>.\u003C/div>\n\u003Cdiv class=\"content\">\n\u003Cpre class=\"highlight\">\u003Ccode class=\"language-bash\" data-lang=\"bash\">SampleStructPack1: 500000000000000000 bytes allocated \u003Cspan class=\"hljs-keyword\">in\u003C/span> 94311 nanoseconds\nSampleStructPack2: 600000000000000000 bytes allocated \u003Cspan class=\"hljs-keyword\">in\u003C/span> 1777 nanoseconds\nSampleStructPack4: 800000000000000000 bytes allocated \u003Cspan class=\"hljs-keyword\">in\u003C/span> 1519 nanoseconds\u003C/code>\u003C/pre>\n\u003C/div>\n\u003C/div>\n\u003Cdiv class=\"paragraph\">\n\u003Cp>Como vemos cuanto más ajustada es la alineación de memoria, más tiempo se tarda en reservar y liberar.\u003C/p>\n\u003C/div>\n\u003Cdiv class=\"paragraph\">\n\u003Cp>A continuación pego el código de la prueba de rendimiento.\u003C/p>\n\u003C/div>\n\u003Cdiv class=\"listingblock\">\n\u003Cdiv class=\"title\">Código de las pruebas de rendimiento\u003C/div>\n\u003Cdiv class=\"content\">\n\u003Cpre class=\"highlight\">\u003Ccode class=\"language-c++\" data-lang=\"c++\">\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">include\u003C/span> \u003Cspan class=\"hljs-string\">&lt;iostream&gt;\u003C/span>\u003C/span>\n\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">include\u003C/span> \u003Cspan class=\"hljs-string\">&lt;chrono&gt;\u003C/span>\u003C/span>\n\n\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">pragma\u003C/span> pack (1)\u003C/span>\n\u003Cspan class=\"hljs-keyword\">struct\u003C/span> \u003Cspan class=\"hljs-title class_\">SampleStructPack1\u003C/span>\n{\n    \u003Cspan class=\"hljs-type\">bool\u003C/span> flag;\n    \u003Cspan class=\"hljs-type\">unsigned\u003C/span> \u003Cspan class=\"hljs-type\">int\u003C/span> timeout;\n};\n\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">pragma\u003C/span> pack(0)\u003C/span>\n\n\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">pragma\u003C/span> pack (2)\u003C/span>\n\u003Cspan class=\"hljs-keyword\">struct\u003C/span> \u003Cspan class=\"hljs-title class_\">SampleStructPack2\u003C/span>\n{\n    \u003Cspan class=\"hljs-type\">bool\u003C/span> flag;\n    \u003Cspan class=\"hljs-type\">unsigned\u003C/span> \u003Cspan class=\"hljs-type\">int\u003C/span> timeout;\n};\n\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">pragma\u003C/span> pack(0)\u003C/span>\n\n\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">pragma\u003C/span> pack (4)\u003C/span>\n\u003Cspan class=\"hljs-keyword\">struct\u003C/span> \u003Cspan class=\"hljs-title class_\">SampleStructPack4\u003C/span>\n{\n    \u003Cspan class=\"hljs-type\">bool\u003C/span> flag;\n    \u003Cspan class=\"hljs-type\">unsigned\u003C/span> \u003Cspan class=\"hljs-type\">int\u003C/span> timeout;\n};\n\u003Cspan class=\"hljs-meta\">#\u003Cspan class=\"hljs-keyword\">pragma\u003C/span> pack(0)\u003C/span>\n\n\n\u003Cspan class=\"hljs-keyword\">struct\u003C/span> \u003Cspan class=\"hljs-title class_\">SampleStruct\u003C/span>\n{\n    \u003Cspan class=\"hljs-type\">bool\u003C/span> flag;\n    \u003Cspan class=\"hljs-type\">unsigned\u003C/span> \u003Cspan class=\"hljs-type\">int\u003C/span> timeout;\n};\n\n\u003Cspan class=\"hljs-type\">static\u003C/span> \u003Cspan class=\"hljs-type\">const\u003C/span> \u003Cspan class=\"hljs-type\">long\u003C/span> MAX_ELEMENTS = \u003Cspan class=\"hljs-number\">100000000000000000\u003C/span>;\n\u003Cspan class=\"hljs-keyword\">using\u003C/span> \u003Cspan class=\"hljs-keyword\">namespace\u003C/span> std;\n\u003Cspan class=\"hljs-keyword\">using\u003C/span> \u003Cspan class=\"hljs-keyword\">namespace\u003C/span> std::chrono;\n\n\u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-type\">void\u003C/span> \u003Cspan class=\"hljs-title\">allocate1\u003C/span>\u003Cspan class=\"hljs-params\">()\u003C/span>\n\u003C/span>{\n    SampleStructPack1 elements [MAX_ELEMENTS];\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot;SampleStructPack1: &quot;\u003C/span> &lt;&lt; \u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(elements) &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; bytes allocated&quot;\u003C/span>;\n}\n\n\u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-type\">void\u003C/span> \u003Cspan class=\"hljs-title\">allocate2\u003C/span>\u003Cspan class=\"hljs-params\">()\u003C/span>\n\u003C/span>{\n    SampleStructPack2 elements [MAX_ELEMENTS];\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot;SampleStructPack2: &quot;\u003C/span> &lt;&lt; \u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(elements) &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; bytes allocated&quot;\u003C/span>;\n}\n\n\u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-type\">void\u003C/span> \u003Cspan class=\"hljs-title\">allocate4\u003C/span>\u003Cspan class=\"hljs-params\">()\u003C/span>\n\u003C/span>{\n    SampleStructPack4 elements [MAX_ELEMENTS];\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot;SampleStructPack4: &quot;\u003C/span> &lt;&lt; \u003Cspan class=\"hljs-built_in\">sizeof\u003C/span>(elements) &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; bytes allocated&quot;\u003C/span>;\n}\n\n\u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-type\">void\u003C/span> \u003Cspan class=\"hljs-title\">chrono1\u003C/span>\u003Cspan class=\"hljs-params\">()\u003C/span>\n\u003C/span>{\n    \u003Cspan class=\"hljs-keyword\">auto\u003C/span> begin = high_resolution_clock::\u003Cspan class=\"hljs-built_in\">now\u003C/span>() ;\n    \u003Cspan class=\"hljs-built_in\">allocate1\u003C/span>();\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; in &quot;\u003C/span> &lt;&lt; \u003Cspan class=\"hljs-built_in\">duration_cast\u003C/span>&lt;nanoseconds&gt;(high_resolution_clock::\u003Cspan class=\"hljs-built_in\">now\u003C/span>() - begin).\u003Cspan class=\"hljs-built_in\">count\u003C/span>() &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; nanoseconds&quot;\u003C/span> &lt;&lt; endl;\n}\n\n\u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-type\">void\u003C/span> \u003Cspan class=\"hljs-title\">chrono2\u003C/span>\u003Cspan class=\"hljs-params\">()\u003C/span>\n\u003C/span>{\n    \u003Cspan class=\"hljs-keyword\">auto\u003C/span> begin = high_resolution_clock::\u003Cspan class=\"hljs-built_in\">now\u003C/span>() ;\n    \u003Cspan class=\"hljs-built_in\">allocate2\u003C/span>();\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; in &quot;\u003C/span> &lt;&lt; \u003Cspan class=\"hljs-built_in\">duration_cast\u003C/span>&lt;nanoseconds&gt;(high_resolution_clock::\u003Cspan class=\"hljs-built_in\">now\u003C/span>() - begin).\u003Cspan class=\"hljs-built_in\">count\u003C/span>() &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; nanoseconds&quot;\u003C/span> &lt;&lt; endl;\n}\n\n\u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-type\">void\u003C/span> \u003Cspan class=\"hljs-title\">chrono4\u003C/span>\u003Cspan class=\"hljs-params\">()\u003C/span>\n\u003C/span>{\n    \u003Cspan class=\"hljs-keyword\">auto\u003C/span> begin = high_resolution_clock::\u003Cspan class=\"hljs-built_in\">now\u003C/span>() ;\n    \u003Cspan class=\"hljs-built_in\">allocate4\u003C/span>();\n    cout &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; in &quot;\u003C/span> &lt;&lt; \u003Cspan class=\"hljs-built_in\">duration_cast\u003C/span>&lt;nanoseconds&gt;(high_resolution_clock::\u003Cspan class=\"hljs-built_in\">now\u003C/span>() - begin).\u003Cspan class=\"hljs-built_in\">count\u003C/span>() &lt;&lt; \u003Cspan class=\"hljs-string\">&quot; nanoseconds&quot;\u003C/span> &lt;&lt; endl;\n}\n\n\n\u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-type\">int\u003C/span> \u003Cspan class=\"hljs-title\">main\u003C/span>\u003Cspan class=\"hljs-params\">(\u003Cspan class=\"hljs-type\">int\u003C/span> argc, \u003Cspan class=\"hljs-type\">char\u003C/span> *argv[])\u003C/span>\n\u003C/span>{\n    \u003Cspan class=\"hljs-built_in\">chrono1\u003C/span>();\n    \u003Cspan class=\"hljs-built_in\">chrono2\u003C/span>();\n    \u003Cspan class=\"hljs-built_in\">chrono4\u003C/span>();\n\n    \u003Cspan class=\"hljs-keyword\">return\u003C/span> \u003Cspan class=\"hljs-number\">0\u003C/span>;\n}\u003C/code>\u003C/pre>\n\u003C/div>\n\u003C/div>\n\u003C/div>\n\u003C/div>",{"title":3,"lang":4,"summary":5,"slug":6,"keywords":7,"filepath":12,"dirpath":13,"created":14,"modified":14,"otherLangs":15,"author":17,"previewimage":18,"path":19},"Alineación de una Estructura C++ en Memoria","es","Comprendiendo cómo funciona la directiva C++ pragma pack y cómo afecta a la alineación de la memoria","cpp-pragma-pack",[8,9,10,11],"C++","Performance","Compilers","Memory","/static/posts/cpp-pragma-pack/cpp-pragma-pack.es.adoc","/static/posts/cpp-pragma-pack",1353927600000,[16],"en","Carlos Martin Sanchez","/posts/cpp-pragma-pack/5b.png","/langs/es/posts/cpp-pragma-pack","\u003Cscript type=\"application/ld+json\">{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"Webpage\",\"@id\":\"https://google.com/article\"},\"headline\":\"Alineación de una Estructura C++ en Memoria\",\"alternativeHeadline\":\"Comprendiendo cómo funciona la directiva C++ pragma pack y cómo afecta a la alineación de la memoria\",\"description\":\"Comprendiendo cómo funciona la directiva C++ pragma pack y cómo afecta a la alineación de la memoria\",\"image\":\"/posts/cpp-pragma-pack/5b.png\",\"datePublished\":\"2012-11-26T11:00:00.000Z\",\"dateModified\":\"2012-11-26T11:00:00.000Z\",\"keywords\":[\"C++\",\"Performance\",\"Compilers\",\"Memory\"],\"author\":{\"@type\":\"Person\",\"name\":\"Carlos Martin Sanchez\"},\"publisher\":{\"@type\":\"Person\",\"name\":\"Carlos Martin Sanchez\"}}\u003C/script>"],"uses":{"params":["slug","lang"]}}]}
