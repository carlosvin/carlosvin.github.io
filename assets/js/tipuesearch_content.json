{
  "pages": [
    {
      "text": "I'm interested in building, dependency management, packagin and deployment in regards to software projects. For Java, Scala, Python, and so on is quite easy since there are tools like Maven, Gradle, pip, Sbt, etc. But regarding C++_, the best options I've found are Maven with Nar plugin or Gradle with cpp plugin (incubation).\nI knew about Biicode almost 2 years ago, but I've never found time to test it, until today.\nHow does Biicode work?\nFirstly we have to install Biicode.\nI've made tiny example project using logging system from Poco library.\nI've executed this command to create the project, called bii_log.\nbii new carlovin/bii_log --hello=cpp\nI've created the project under my Biicode username, just in case I'd like to publish later.\nPrevious command generates the structure of files and directories, although we are going to focus only on:\nblocks/carlosvin/bii_log/main.cpp\nblocks/carlosvin/bii_log/biicode.conf\nIn biicode.conf we are going to configure our dependencies, in this example Poco library.\n# Biicode configuration file\n\n[requirements]\n    fenix/poco(develop): 0\n\n[parent]\n        carlosvin/bii_log: 0\n\n[includes]\n    Poco/*.h: fenix/poco/Foundation/include\nIn [includes] section, we are overriding the path to file headers. If we don't override it we'd had to do something like this:\n#include \"fenix/poco/Foundation/include/Logger.h\"\nThanks to this line, include declarations are going to be clearer, as follows:\n#include \"Poco/Logger.h\"\nEasy, now we can start using Poco in our project, e.g:\n#include \"Poco/FileChannel.h\"\n#include \"Poco/FormattingChannel.h\"\n#include \"Poco/PatternFormatter.h\"\n#include \"Poco/Logger.h\"\n#include \"Poco/AutoPtr.h\"\n\nusing Poco::FileChannel;\nusing Poco::FormattingChannel;\nusing Poco::PatternFormatter;\nusing Poco::Logger;\nusing Poco::AutoPtr;\n\nint main(int argc, char** argv) {\n        AutoPtr<FileChannel> pChannel(new FileChannel);\n        pChannel->setProperty(\"path\", \"log/sample.log\");\n        pChannel->setProperty(\"rotation\", \"100 K\");\n        pChannel->setProperty(\"archive\", \"timestamp\");\n\n        //AutoPtr<ConsoleChannel> pCons(new ConsoleChannel);\n        AutoPtr<PatternFormatter> pPF(new PatternFormatter);\n        pPF->setProperty(\"pattern\", \"%Y-%m-%d %H:%M:%S %s: %t\");\n        AutoPtr<FormattingChannel> pFC(new FormattingChannel(pPF, pChannel));\n        Logger::root().setChannel(pFC);\n\n        Logger & logger = Logger::get(\"TestChannel\");\n        for(int i=0; i<10000; i++){\n                poco_information(logger, \"This is a info\");\n                poco_warning(logger, \"This is a warning\");\n        }\n        return 0;\n}\nTo compile the project we only have to execute following command:\nbii cpp:build\nTo publish the project and to allow everyone use it as we have used Poco:\nbii publish\nBesides the ease to use, I like so much the integration with Eclipse with CDT. After \"bii cpp:build\" execution all files were properly indexed.\nI've read also an article about the good integration with CLion: When CLion met biicode.", 
      "tags": "biicode,C++,depencency management,Poco", 
      "loc": "/en/posts/first-biicode-poco.html", 
      "title": "C++ Dependency Management: Biicode"
    }, 
    {
      "text": "Few days ago at work, I had to fulfill a document where I had to select a type of software maintenance that I was going to apply.\nThe fact was I had only two choices, it seemed me very weird because during my degree I studied 3 or 4 kinds of software maintenance.\nToday I have found my Software Engineering class notes, then the types of Software Maintenance sorted descending by percentage of time spent:\nPerfective:Activities to improve or add new functionalities required by the user.\nAdaptative:Activities to adapt the system to technological environment changes  (hardware or software).\nCorrective:Fix defects in hardware or software detected by user running the production system.\nPreventive:Activities to ease the future system maintenance.", 
      "tags": "Software Engineering,Software Maintenance", 
      "loc": "/en/posts/software-maintenance.html", 
      "title": "Software Maintenance"
    }, 
    {
      "text": "Introduction\nI am more and more worried about building, dependency management and distribution of my projects. I'd like to find a tool unifies those processes with  independence of the language. I know several tools those almost fit to what I'm looking for, like I know several tools those almost fit to what I'm looking for, like SCons, Autotools, Ant, Maven and lately Gradle.\nI've made several projects with Gradle, but always I was focused in Java and Android projects.\nIn Java projects I've found a Maven replacement, because it is faster, easier and less verbose.\nAbout Android projects I suffered the early adoption of Android Studio + Gradle, although currently I think the are more mature and they work fine.\nFirst of all, I have to say: building C/C++/Objective-C projects with Gradle is in incubation phase, although now we can perform advanced tasks like:\nGeneration several artifacts within same project (libraries and executables).\nDependency management between artifacts (no versions).\nDifferent \"flavors\" of the same software, e.g: we can generate a \u201cCommunity\u201d release and other one with more enabled features called \u201cEnterprise\u201d.\nIt allows multi-platform binary generation.\nAs I said, this plugin is still having limitations although they are working on it: Gradle C++ roadmap. If they achieve it I'll leave Autotools (I'm going to regret saying that).\n\nIndex\nIntroduction\nCase studyProject Structure\nC++ Application\nBuilding with GradleBase case\nDifferent \"Flavors\"Community\nEnterprise\n\nRelease or Debug\nMulti-platform\n\nTry it yourself\n\nConclusions\n\n\n\n\nCase study\nI've extracted all the case study from here. I've adapted the project to be multi-platform with 2 versions \"Community\" and \"Enterprise\".\nThe application consists of an executable and a dynamic library. The executable will use the library.\nGradle also is able to generate a distributable version and a debug version.\nYou can fork the code on https://github.com/carlosvin/cpp_gradle.\n\nProject Structure\nWe can create whichever directory structure, but it is easier using the proposed by Gradle, if not we'll have to specify where the code is located.\nThis is the project structure:\ngradle-cpp:Root directory.\nbuild.gradle:File where is configured Gradle project, it is the equivalent to: build.xml for Ant, Makefile for C/C++ or pom.xml for Maven.\n\nsrc:Folder where the source code is located.\nhello:This folder contains the module hello. This module will generate hello library.\ncpp:This folder contains C++ source files.\nHello.cpp:File with the implementation of Hello class.\n\nheaders:Folder with header files.\nHello.h:Class Hello declaration.\nMsg.h:File with constants declarations.\n\n\nmain:This folder contains the module which produces the executable that uses hello library.\ncpp:This folder contains C++ source files.\nmain.cpp:Source code of main function.\n\n\n\nbuild:Folder created automatically by Gradle where it leaves all execution results like unit tests reports, compiled files, package distributions, etc.\n\n\n\n\nC++ Application\nIt consists of an executable that uses the functionality implemented at hello library.\n// main.cpp\n#include \"Hello.h\"\nint main(int argc, char ** argv)\n{\n    Hello hello (\"Pepito\");\n    hello.sayHello(10);\n    return 0;\n}\nhello library allows greet n times to someone who is passed as argument to constructor class.\n// Hello.h\nclass Hello\n{\n    private:\n        const char * who;\n    public:\n        Hello(const char * who);\n        void sayHello(unsigned n = 1);\n};\n\n\nBuilding with Gradle\n\nBase case\nThe only we need to build the application with Gradle is: having Gradle [1] and the file build.gradle.\n// build.gradle\napply plugin: 'cpp'\n\nlibraries {\n    hello {}\n}\nexecutables {\n    main {\n        binaries.all {\n            lib libraries.hello.shared\n        }\n    }\n}\nWith this simple file, we'll be able to compile and install the application in Debug mode for the platform where we are executing Gradle (in my case X64).\nIf we execute gradle task from the root of the project, we'll get all the tasks we can do with Gradle.\nIn our case, we just want our compiled application ready to run, so we have to execute: gradle installMainExecutable.\nOnce execution has finished, we can run the program calling to build/install/mainExecutable/main [2].\n$ build/install/mainExecutable/main\n1.  Hello Mr. Pepito (Community)\n2.  Hello Mr. Pepito (Community)\n3.  Hello Mr. Pepito (Community)\n4.  Hello Mr. Pepito (Community)\n5.  Hello Mr. Pepito (Community)\n6.  Hello Mr. Pepito (Community)\n7.  Hello Mr. Pepito (Community)\n8.  Hello Mr. Pepito (Community)\n9.  Hello Mr. Pepito (Community)\n10. Hello Mr. Pepito (Community)\n\n\nDifferent \"Flavors\"\nWith a few lines more we can generate different versions of same application.\nIn our example we are going to build \"Community\" and \"Enterprise\" flavors.\n//build.gradle\napply plugin: 'cpp'\nmodel {\n    flavors {\n        community\n        enterprise\n    }\n}\nlibraries {\n    hello {\n        binaries.all {\n            if (flavor == flavors.enterprise) {\n                    cppCompiler.define \"ENTERPRISE\"\n            }\n        }\n    }\n}\nexecutables {\n    main {\n        binaries.all {\n            lib libraries.hello.shared\n        }\n    }\n}\nBesides, we have to make our application ready to use compilation parameters.\n// Msg.h\n\n#ifdef ENTERPRISE\nstatic const char * EDITION = \"Enterprise\";\n\n#else\nstatic const char * EDITION = \"Community\";\n\n#endif\nIn this way it selects a string depending on used flavor.\nIf we execute gradle clean task in the root folder, we'll get more available tasks.\nBefore, we had installMainExecutable which has been replaced by installCommunityMainExecutable and installEnterpriseMainExecutable.\nIf we execute both tasks, we'll get the installed application in both flavors:\n$gradle installEnterpriseMainExecutable installCommunityMainExecutable\n\n:compileEnterpriseHelloSharedLibraryHelloCpp\n:linkEnterpriseHelloSharedLibrary\n:enterpriseHelloSharedLibrary\n:compileEnterpriseMainExecutableMainCpp\n:linkEnterpriseMainExecutable\n:enterpriseMainExecutable\n:installEnterpriseMainExecutable\n:compileCommunityHelloSharedLibraryHelloCpp\n:linkCommunityHelloSharedLibrary\n:communityHelloSharedLibrary\n:compileCommunityMainExecutableMainCpp\n:linkCommunityMainExecutable\n:communityMainExecutable\n:installCommunityMainExecutable\n\nBUILD SUCCESSFUL\nTotal time: 9.414 secs\nNow we can run the application in both flavors:\n\nCommunity\n$ build/install/mainExecutable/community/main\n1.      Hello Mr. Pepito        (Community)\n2.      Hello Mr. Pepito        (Community)\n3.      Hello Mr. Pepito        (Community)\n4.      Hello Mr. Pepito        (Community)\n5.      Hello Mr. Pepito        (Community)\n6.      Hello Mr. Pepito        (Community)\n7.      Hello Mr. Pepito        (Community)\n8.      Hello Mr. Pepito        (Community)\n9.      Hello Mr. Pepito        (Community)\n10.     Hello Mr. Pepito        (Community)\n\n\nEnterprise\n$ build/install/mainExecutable/enterprise/main\n1.      Hello Mr. Pepito        (Enterprise)\n2.      Hello Mr. Pepito        (Enterprise)\n3.      Hello Mr. Pepito        (Enterprise)\n4.      Hello Mr. Pepito        (Enterprise)\n5.      Hello Mr. Pepito        (Enterprise)\n6.      Hello Mr. Pepito        (Enterprise)\n7.      Hello Mr. Pepito        (Enterprise)\n8.      Hello Mr. Pepito        (Enterprise)\n9.      Hello Mr. Pepito        (Enterprise)\n10.     Hello Mr. Pepito        (Enterprise)\n\n\n\nRelease or Debug\nBy default Gradle compiles in Debug mode, but we can add the Release mode which enables several optimizations and remove debug flags [3].\n// build.gradle\n\napply plugin: 'cpp'\nmodel {\n    buildTypes {\n        debug\n        release\n    }\n\n// ... the rest of file below doesn't change\nIf we execute gradle clean task we'll get more tasks, they have been split, for example installCommunityMainExecutable has been split in installDebugCommunityMainExecutable and installReleaseCommunityMainExecutable.\n\n\nMulti-platform\nAlso we can use cross-compiling features provided by compilers and generate native components for other platforms.\nTo do that we just have to add the supported platforms.\nThis only works if we have installed the Toolchain for the target platform.\n// build.gradle\n\napply plugin: 'cpp'\nmodel {\n    buildTypes {\n        debug\n        release\n    }\n    platforms {\n        x86 {\n            architecture \"x86\"\n        }\n        x64 {\n            architecture \"x86_64\"\n        }\n        itanium {\n            architecture \"ia-64\"\n        }\n    }\n    flavors {\n        community\n        enterprise\n    }\n}\nlibraries {\n    hello {\n        binaries.all {\n            if (flavor == flavors.enterprise) {\n                cppCompiler.define \"ENTERPRISE\"\n            }\n        }\n    }\n}\nexecutables {\n    main {\n        binaries.all {\n            lib libraries.hello.shared\n        }\n    }\n}\nWhen execute gradle clean task we'll see the different building options we have.\nIn this example, we can build different versions of the application in different flavors for different platforms in Debug or Release mode.\n\n\n\nTry it yourself\nThe project is on https://github.com/carlosvin/cpp_gradle.\nRequirements:\nJava 6 or higher.\nAn installed compiler (e.g GCC)\nYou just have to follow next steps:\ngit clone git@github.com:carlosvin/cpp_gradle.git\ncd cpp_gradle\n./gradlew task or ./gradlew.bat task if you are in Windows. In this way you'll see available tasks for this project. The first execution will take more time, because it downloads Gradle runtime.\nIf you are in a 64 bits platform, you can use this command to install the application: ./gradlew installX64ReleaseEnterpriseMainExecutable.\nRun the application you just built: build/install/mainExecutable/x64ReleaseEnterprise/main\n\n\n\nConclusions\nWith a tiny configuration file, we have many different build combinations.\nGradle for C++ has a promising future,  I hope it follows the steps of Java and Android support.\nIt is well supported by continuous integration systems.\nIt has many plugins and features.\nGradle for C++ is a feature under development, we have to be careful:\nDon't use it in production environments.\nMany things can change or disappear.\nThe full example is on https://github.com/carlosvin/cpp_gradle.\nI recommend you to Try it yourself.\nGetting Started Gradle Native.\n[n]'n' Positive integer[1]Actually Gradle is not required if we use the \"wrapper\", but we aren't going to treat it here, here you can get more info about Gradle Wrapper.[2].bat in Windows. Without extension in Linux[3]We can also specify/modify the kind of optimizations.", 
      "tags": "Build Construction Systems,C++,Gradle", 
      "loc": "/en/posts/gradle-cpp.html", 
      "title": "Build C++ project with Gradle"
    }, 
    {
      "text": "I've found out a artistic-technological group named AlgoRythmics, they teach how the most popular sorting algorithms work.\nYou can read the wikipedia topic Popular sorting algorithms, although I think it isn't as funny to learn as the AlgoRythmics way. Following the Quicksort, judge for yourself.", 
      "tags": "Algorithm,Programming,Sorting", 
      "loc": "/en/posts/sorting-algorithm-dancing.html", 
      "title": "How sorting algorithms work (Dancing)"
    }, 
    {
      "text": "Bases de datos embebidas\nSe trata de bases de datos que carecen de servidor, est\u00e1n inscrustadas en la propia aplicaci\u00f3n y suelen estar almacenadas en ficheros locales. Esto \u00faltimo unido a que suelen tener un modo de funcionamiento en el que mantienen los datos en memoria hace que puedan tener un rendimiento muy alto.\nEso s\u00ed, este gran grado acoplamiento a la aplicaci\u00f3n, hace que tengan peor rendimiento cuando se comparten entre varias aplicaciones debido a colisiones de acceso.\nOtra ventaja es que no tenemos que encargarnos de mantener y gestionar un servidor de bases de datos.\nVoy a hacer una comparativa de rendimiento entre 3 bases de datos embebidas ACID (transaccionales), las NoSQL no entran en esta comparativa que est\u00e1n en otra liga de rendimiento.\n\nContenidos\nBases de datos embebidasSQLite\nDerby o JavaDB\nObjectDB\n\nLos TestsInterfaz DB\nLas Bases de Datos JDBC\nEl c\u00f3digo fuente\nResultados de los tests\n\n\n\n\nSQLite\nSe trata de una librer\u00eda escrita en ANSI C, de menos de 500KB, multi-plataforma, sin dependencias externas, almacena todo el contenido de la base de datos en un solo fichero.\nEs la que da mejor rendimiento en los Resultados de los tests.\nSe puede utilizar desde C y C++, pero tambi\u00e9n desde otros lenguajes de programaci\u00f3n  (PHP, Python, Java, .NET ...).\nEn el caso de Java podemos gestionar esta base de datos a trav\u00e9s de JDBC. Podemos obtener la librer\u00eda de https://bitbucket.org/xerial/sqlite-jdbc.\nVeamos un ejemplo de la inserci\u00f3n de una serie de objetos de la clase Price.\npublic class JdbcDb implements DB {\n\n        enum Column {\n                INSTRUMENT,\n                MARKET,\n                PRICE,\n                DATE;\n        }\n\n        public static final String TABLE_NAME = \"PRICES\";\n        public static final String SQL_INSERT = \"INSERT INTO \" + TABLE_NAME\n                        + \" (INSTRUMENT, MARKET, PRICE, DATE) VALUES (?,?,?,?)\";\n\n        // ...\n\n        private void insert(Price p, PreparedStatement preparedStatement) throws SQLException {\n                preparedStatement.setString(1, p.getInstrument());\n                preparedStatement.setString(2, p.getMarket());\n                preparedStatement.setDouble(3, p.getPrice());\n                preparedStatement.setTimestamp(4, new Timestamp(p.getDate().getTime()));\n                preparedStatement.addBatch();\n        }\n\n        @Override\n        public void insert(Price... prices) throws SQLException {\n                PreparedStatement preparedStatement = conn.prepareStatement(SQL_INSERT);\n                for (Price p : prices) {\n                        insert(p, preparedStatement);\n                }\n                preparedStatement.executeBatch();\n                preparedStatement.close();\n                conn.commit();\n        }\n\n        // ...\n}\n\n\nDerby o JavaDB\nJavaDB es una distribuci\u00f3n de Oracle de la base de datos de c\u00f3digo libre Derby. Soporta el est\u00e1ndar ANSI/ISO SQL  a trav\u00e9s de JDBC y Java EE. Estas librer\u00edas est\u00e1n incluidas en el JDK.\nAlmacena la base de datos en multiples archivos, lo que puede resultar \u00fatil para escalar el almacenamiento.\nSolo podemos utilizarlo en Java, no desde otros lenguajes.\nComo veremos m\u00e1s adelante ha sido la m\u00e1s lenta en los Resultados de los tests.\nLa implementaci\u00f3n de ejemplo de una inserci\u00f3n de una serie de objetos de la clase Price, es exactamente la misma que la que hemos hecho m\u00e1s arriba en SQLite, esto es una de las bondades de JDBC, que nos permite obtener una conexi\u00f3n para una base de datos espec\u00edfica, pero a partir de ah\u00ed casi siempre nos podemos olvidar de la base de datos con la que trabajamos, siempre y cuando soporte nuestras consultas SQL.\n\n\nObjectDB\nEs una base de datos orientada a objetos que nos permite acceso JPA, un est\u00e1ndar de Java que persigue no perder las ventajas de la orientaci\u00f3n a objetos; esto se suele perder cuando nos acercamos a la capa de persistencia.\nResulta realmente sencillo realizar acciones t\u00edpicas de una base de datos, abstray\u00e9ndonos del SQL, por ejemplo veamos c\u00f3mo quedar\u00eda una inserci\u00f3n de un array de objetos de la clase Price con ObjectDB.\npublic void insert(Price... prices) throws SQLException {\n        em.getTransaction().begin();\n        for (Price p : prices) {\n                em.persist(p);\n        }\n        em.getTransaction().commit();\n}\nSi a esta facilidad de uso, le unimos que los Resultados de los tests de rendimiento han sido muy buenos (cerca de SQLite), puedo decir que he descubierto una base de datos embebida a tener muy en cuenta en futuros proyectos Java, eso s\u00ed, al igual que con JavaDB, solo nos sirve si vamos a programar en Java.\n\n\n\nLos Tests\nSimplemente consisten en realizar repetidamente una serie operaciones CRUD. Para cada base de datos, el test realiza una serie de inserciones, selects, actualizaciones y borrado de objetos de la clase Precio.\nHe utilizado 100000 instancias de la clase Price, las mismas para cada tipo de base de datos.\nPara esto he creado una interfaz DB que compartir\u00e1n cada una de las implementaciones para cada base de datos.\n\nInterfaz DB\n\npublic interface DB {\n\n        public void insert(Price... prices) throws SQLException;\n\n        public void createTable();\n\n        public void deleteAll();\n\n        public void update(Price... prices) throws SQLException;\n\n        public Set<Price> selectAll();\n\n}\n\n\n\nLas Bases de Datos JDBC\nSolo cambian los datos necesarios para obtener el driver y la conexi\u00f3n a la base de datos,  por eso toda la l\u00f3gica est\u00e1 en la clase JdbcDb de la que heredan SqliteDb y DerbyDB.\n\n\nEl c\u00f3digo fuente\nPod\u00e9is descargar el c\u00f3digo fuente de https://github.com/carlosvin/java_embedded_databases.\nSe trata de un proyecto Gradle por lo que para ejecutar los tests solo ten\u00e9is que escribir (y tener instalado Gradle claro):\n\ngrade test\n\nGradle se descargar\u00e1 autom\u00e1ticamente las librer\u00edas necesarias, compilar\u00e1 y ejecutar\u00e1 los tests.\nTambi\u00e9n pod\u00e9is ver directamente la ejecuci\u00f3n en https://travis-ci.org/carlosvin/java_embedded_databases.\nhttps://travis-ci.org/carlosvin/java_embedded_databases.svg\n\n\nResultados de los tests\nA continuaci\u00f3n pod\u00e9is ver un con los resultados de los tests.\n\nAbrir el gr\u00e1fico interactivo | Abrir imagen", 
      "tags": "database,embedded,Java", 
      "loc": "/en/posts/java-embedded-db-performance-comparison.html", 
      "title": "Bases de Datos Embebidas Java: Comparaci\u00f3n de Rendimiento"
    }, 
    {
      "text": "Recently I've  had to serialize/deserialize some data in Java binary format. Lately I use JSON or XML formats.\nI remember that to serialize Java objects they must implement the  Serializable interface, but I had also read in Internet other way, implementing the Externalizable interface, then, which interface must I implement? It depends on what you want such as everything in the life.\n\nWhen to use Serializable or Externalizable\nSerializable\nExternalizable\nPerformance tests (Serializable vs. Externalizable)Implementing Serializable\nImplementing Externalizable (wrong way)\nImplementing Externalizable (right way)\nResult Analysis\n\n\n\n\nSerializable\nTo serialize easily. You have to write less code.\nThis way has some restrictions: The object to serialize must implement the default constructor (0 args). It must be responsible to manage the parent class attributes.\nThe performance is not as important, we will see more about that in Performance tests (Serializable vs. Externalizable).\n\n\nExternalizable\nYou must implement the serialization/deserialization methods, so you have to write more code.\nWhen you cannot use Serializable.\nWhen you want to improve the performance, as we'll see in Performance tests (Serializable vs. Externalizable)\nIf you have to manage the serialization of parent class attributes, then I recommend you use Externalizable, because we'll avoid a weird overriding of private methods.\nprivate void writeObject(ObjectOutputStream oos)\nprivate void readObject(ObjectInputStream ois)\n\n\nPerformance tests (Serializable vs. Externalizable)\nSerializable: Java, through introspection, guesses the types of class attributes to know how to serialize/deserialize them, but this \"magic\" is not free, it has a performance penalty.\nWhen we use Externalizable interface, we decide how to serialize/deserialize, namely we have to write the code that does it. We've lost ease, but also we avoid that Java does some tasks, so if we override the methods properly, we'll get a performance improvement.\nTo know how much is the performance difference between both interfaces, I've written a tiny example in which we serialize an object with 2 collections with 100000 elements each one, 3 ways:\n\nImplementing Serializable\nAs we told above, Java has to guessed certain things, in this process it sacrifices some of performance (slower way), in exchange for programming simplicity, the class to serialize just has to implement the Serializable interface.\npublic class Contacts implements Serializable {\nserializing:   1133 millisecond\ndeserializing: 506  millisecond\n\n\nImplementing Externalizable (wrong way)\nIf the class implements Externalizable, we must tell to Java how it has to serialize/deserialize the class attributes. We must be carefully, because if we did it bad, then we'll get the worst of the both worlds: more complex implementation and bad performance, i.e: If we serialize/deserialize complex class attributes (like collections), Java will also have to guess many things about the attributes type.\n@Override\npublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n  setEmails((Set<String>) in.readObject());\n  setPhones((Set<String>) in.readObject());\n}\n\n@Override\npublic void writeExternal(ObjectOutput out) throws IOException {\n  out.writeObject(emails);\n  out.writeObject(phones);\n}\nserializing:   737 millisecond\ndeserializing: 367  millisecond\n\n\nImplementing Externalizable (right way)\nIf we serialize one by one the collection elements, then we'll save more time, because Java serializes simple types, this way avoids guessing things that we actually know.\n@Override\npublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n  emails.clear();\n  phones.clear();\n  int nEmails = in.readInt();\n  for (int i = 0; i < nEmails; i++) {\n    emails.add(in.readUTF());\n  }\n  int nPhones = in.readInt();\n  for (int i = 0; i < nPhones; i++) {\n    phones.add(in.readUTF());\n  }\n}\n\n@Override\npublic void writeExternal(ObjectOutput out) throws IOException {\n  out.writeInt(emails.size());\n  for (String e : emails) {\n    out.writeUTF(e);\n  }\n  out.writeInt(phones.size());\n  for (String p : phones) {\n    out.writeUTF(p);\n  }\n}\nserializing:   204 millisecond\ndeserializing: 92  millisecond\nWe've gained performance at expense of write more code.\n\n\nResult Analysis\n\nCaution!\nWe don't gain performance due to use an interface or the other one.\n\n\nTip\nWe gain performance because Externalizable interface forces us to implement ourselves the guessing code, so Java doesn't have to do that.\n\nAlthough as we have watched in Implementing Externalizable (right way), if we wouldn't be careful in implementation, we'll get less performance.\nFollowing you can see a graph with Tests results.\n\nOpen interactive graph | Open image\n\nTests results.\n\nCode in Github.\n\nTravis CI build status", 
      "tags": "Java", 
      "loc": "/en/posts/serialization-java-serializable-externalizable.html", 
      "title": "Java serialization ways: Performance Comparison"
    }, 
    {
      "text": "C++11 has added many improvements to help us developing multi-thread systems. I'm going to talk about mutex.\nIn previous C++11 compiler versions, we can get a pthread mutex, but we must initialize and destroy in C style; in the end you must do more things than just lock/unlock.\nC++11 provides mutex class, we just lock/unclock the object. I recommend you take a look at C++11 mutex class.\nIf you still work with previous C++11 compiler versions, a time ago, I made a wrapper class that helps to work with pthread mutex. You just lock/unlock the Mutex object.\nThen I leave my code proposal (Gist code).\n\n\n#include \"Mutex.h\"\n#include <exception>\n\n\nMutex::Mutex()\n{\n    if ( pthread_mutex_init(&_mutex, NULL) )\n    {\n        throw \"Error: Initializing _mutex\";\n    }\n}\n\nMutex::~Mutex()\n{\n\n    pthread_mutex_destroy(&_mutex);\n}\n\nMutex::Mutex(const Mutex & obj)\n{\n\t_mutex = obj._mutex;\n}\n\nMutex & Mutex::operator=(const Mutex & obj)\n{\n\t_mutex = obj._mutex;\n\treturn *this;\n}\n\nbool Mutex::operator==(const Mutex & obj)\n{\n\treturn _mutex == obj._mutex;\n}\n\nbool Mutex::operator!=(const Mutex & obj)\n{\n\treturn !(*this == obj);\n}\n\nvoid Mutex::lock ()\n{\n    pthread_mutex_lock( &_mutex );\n}\n\nvoid Mutex::unlock ()\n{\n    pthread_mutex_unlock( &_mutex );\n}\n\nvoid Mutex::lock ( int lock, Mutex * mtx)\n{\n\tif (lock)\n\t{\n\t\tmtx->lock();\n\t}\n\telse\n\t{\n\t\tmtx->unlock();\n\t}\n}", 
      "tags": "C++,pthread", 
      "loc": "/en/posts/cpp-mutex.html", 
      "title": "Mutex C++"
    }, 
    {
      "text": "I've been listening a A. Jesse Jiryu Davis talk about the library Python's asycnio library.\nAsycnio is a library added to Python 3.4. that provides infrastructure for writing single-threaded concurrent code which let us to save memory.", 
      "tags": "Programming,Python", 
      "loc": "/en/posts/async-what-how-when.html", 
      "title": "Python's asyncio: What, How, When"
    }, 
    {
      "text": "I've seen in Google Science Fair a collection of equations that changed the world.\nIn my opinion, everybody must understand some of these equations.", 
      "tags": "G+,Math,Pysics,Science", 
      "loc": "/en/posts/equations-that-changed-the-word.html", 
      "title": "Equations that changed the world"
    }, 
    {
      "text": "I guess that most people come from dynamic content management systems based on:\nsend data from browser to server\nprocess the received data, then it stores the info into a database (or files)\nthe server generate dynamically an answer that is sent to the browser as HTMLthe answer is usually built reading info from a database or files.\n\nThis process is managed by a software installed on server, this is our content management system.\nNow I've changed the paradigm to \"static web site generator\", specifically I'm going to use Nikola,\nalthough this time, I'm not going to install on a remote server.\nIn a next post I'll tell you how I've automated the publication process using Github [1] and Travis [2].\n\nPath to Nikola\nPhpNuke\nMy Own Content Management SystemDrupal\nWordpress\nCMSdj\nNikola\n\n\n\n\nPhpNuke\nMy first content management system, yes it still exists. It based on PHP+MySQL, multi-lang, user management, user groups, theming, plugins, etc.\n\n\nMy Own Content Management System\nIt wasn't a full [CMS], because actually it was a blogging system. I can publish posts dynamically, it was made with PHP and MySQL. It was useful to:\nPublish posts (with several problems).\nI realized that a developer needs a designer.\nI don't like the PHP syntax.\nI began to understand the importance of [DRY].\n\nDrupal\nA full [CMS],  I liked it until things began to \"break\" (Maybe I broke some of them). But Drupal has everything you expect from a [CMS] and more.\n\n\nWordpress\nI don't know if it is better or worse than Drupal, there are many discussions on the Internet, but I can tell Wordpress is more usable and easier to update than Drupal.\n\n\nCMSdj\nIt is my second attempt to create my own [CMS]. I had an idea in my mind about how to make the core design (the data model), I still believe in that design. I had also discovered Django, I liked this framework developed in Python, who can resist creating their own [CMS]?\nCMSdj is in Bitbucket and is working, it has its internal search engine, theming, comment system, voting system,HTML5_ + CSS3 views, but:\nI didn't have enough time to develop it, two hours per week at most.\nI still needed a designer.\nSo, I declared the project CMSdj dead out of boredom, although it was supporting my old blog, when I went to write something, I saw my unfinished project, I didn't like it, so I decided to close it and begin a new one.\n\n\nNikola\nI wanted a static website generator because they are trendy.\nI tried Jekyll because it's the most famous, but I prefer one written in Python. So, after a quick search I had three finalists: Nikola, Mynt and Pelican. I chose Nikola  because I discarded the others:\n* Pelican throws some multi-lang problems with the categories. I didn't want to spend time researching about how to fix them.\n* I love the simplicity of Mynt, but you have to create your own themes.\n[1]Github hosts the generated site, the static files (html, css, images, js).[2]Travis is a continuous integration software (like Jenkins). I use it to automate the site deployment: download the files when they change from Github, re-generate and re-publish the static files.[DRY]Don't Repeat Yourself, \u00b4DRY in wiki\u00b4_[CMS](1, 2, 3, 4, 5) Content Management System", 
      "tags": "Python,Static Sites", 
      "loc": "/en/posts/primer-post.html", 
      "title": "First post with Nikola"
    }, 
    {
      "text": "If you want to use Android Studio without installation, as a portable software, here you have the  link to last portable version of Android Studio.", 
      "tags": "Android,Java,Software", 
      "loc": "/en/posts/android-studio-portable-download.html", 
      "title": "Android Studio Portable Download"
    }, 
    {
      "text": "Trabajando con libtool [1], cuando vamos a depurar un ejecutable que utiliza una librer\u00eda generada con libtool, es posible que nos encontremos con el siguiente error:\n$ gdb ./tests-mylib\n\"tests-mylib\": not in executable format: File format not recognized\nlibmylib.so es una librer\u00eda din\u00e1mica generada con libtool\ntests-mylib es un ejecutable que utiliza la librer\u00eda mylib\nPara los que est\u00e9is pensando que se me ha olvidado poner la opci\u00f3n de compilaci\u00f3n -g, lo siento, pero este error ocurre aunque utilicemos -g.\nEl error es debido a que estamos intentando ejecutar un script generado por libtool, es una envoltura sobre el programa real, para facilitar la ejecuci\u00f3n de \u00e9ste [libtooldoc].\nPara poder depurar nuestro programa de prueba tests-mylib\nlibtool --mode=execute gdb tests-mylib\n[1]Herramienta que pertenece a la Autotools usada para crear bibliotecas de software portables.[libtooldoc]Esta informaci\u00f3n la he sacado de http://www.gnu.org/software/libtool/manual/libtool.html#Debugging-executables", 
      "tags": "Autotools,C++,GNU,Tips and Tricks", 
      "loc": "/en/posts/debug-libtool-lib.html", 
      "title": "Depurar librer\u00eda generada con libtool"
    }, 
    {
      "text": "Un struct de C++ es un elemento que permite agrupar elementos de tipos distintos con alguna relaci\u00f3n entre ellos. Esto permite manipular todos los elementos en bloque mediante una \u00fanica referencia.\nSi alguna vez nos interesa trabajar a un nivel m\u00e1s bajo, nos puede resultar \u00fatil entender c\u00f3mo se mapea una estructura en memoria y c\u00f3mo controlar este mapeo.\n\nTabla de Contenidos\nEstructura de ejemplo\nLa directiva #pragma pack en struct C++\nRendimiento\n\n\n\nEstructura de ejemplo\nEsta estructura estar\u00e1 compuesta por dos campos, un entero (4 bytes) y un booleano (un byte). En C++ queda de la siguiente forma:\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\nSi hacemos un sizeof de la una instancia de la estructura deber\u00edamos obtener un tama\u00f1o de 5 bytes. Y la memoria quedar\u00eda de la siguiente forma:\n\nEstructura de 5 bytes que realmente ocupa 5 bytes en memoria.\n\nPero no es tan sencillo, a continuaci\u00f3n veremos que no nos podemos olvidar de la alineaci\u00f3n de la memoria que hace el compilador en ese sistema y veremos c\u00f3mo controlarlo para no encontrarnos con tama\u00f1os inesperados, ya que esto depende del compilador del sistema.\nPor ejemplo, si en mi m\u00e1quina hago un sizeof de la estructura, obtengo un tama\u00f1o de 8 bytes. Lo que est\u00e1 sucediendo es que el compilador reserva m\u00e1s memoria al final de la estructura para que cuadre en bloques de 2n bytes. La memoria queda de la siguiente forma:\n\nEstructura de 5 bytes que realmente ocupa 8 bytes en memoria. Para ser m\u00e1s precisos, deber\u00eda haber dibujado la memoria no usada a continuaci\u00f3n del atributo flag.\n\nVamos a ver un fragmento de c\u00f3digo que imprime el tama\u00f1o de la estructura y el de cada uno de sus atributos y verificar, en este caso 4 + 1 no es 5.\n#include  <iostream>\n\nusing namespace std;\n\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\n\nstatic void print (size_t sz, size_t sz_flag, size_t sz_timeout)\n{\n    cout << \"\\tflag: \" << sz_flag << \" Bytes\" << endl;\n    cout << \"\\t+\" << endl;\n    cout << \"\\ttimeout: \" << sz_timeout << \" Bytes\" << endl;\n    cout << \"\\t=\" << endl;\n    cout << \"\\t\" << sz_timeout + sz_flag << \" Bytes\" << endl;\n    cout <<\"sizeof struct:  \" << sz << \" Bytes\" << endl;\n}\n\nint main(int argc, char *argv[])\n{\n    cout << \"SampleStruct\" << endl;\n    print (sizeof(SampleStruct), sizeof(SampleStruct::flag), sizeof(SampleStruct::timeout));\n    cout << \" -- \" << endl;\n\n    return 0;\n}\nEjecutando el c\u00f3digo de sin la directiva pragma, tenemos que nuestra estructura ocupa 8 bytes en lugar de 5 bytes.\nSampleStruct\nflag: 1 Bytes\n+\ntimeout: 4 Bytes\n=\n5 Bytes\nsizeof struct:  8 Bytes\n--\n\nTip\nSi queremos conocer el tama\u00f1o exacto de las estructuras que vamos a utilizar, tenemos que especificar al compilador la forma de alinear la estructura en memoria, para ello utilizaremos la directiva #pragma pack(n).\n\n\n\nLa directiva #pragma pack en struct C++\nSe trata de una directiva del preprocesador que indica al compilador c\u00f3mo debe realizar la alineaci\u00f3n de la memoria. Vamos a ver como se comporta con un ejemplo:\n#include <iostream>\n\nusing namespace std;\n\nstatic void print (size_t sz, size_t sz_flag, size_t sz_timeout)\n{\n    cout << \" flag: \" << sz_flag << \" Bytes\"<< endl;\n    cout << \" +\" << endl;\n    cout << \" timeout: \" << sz_timeout << \"Bytes\" << endl;\n    cout << \" =\" << endl;\n    cout << \" \" << sz_timeout + sz_flag << \"Bytes\" << endl;\n    cout << \" sizeof struct:  \" << sz << \" Bytes\" << endl;\n}\n\n#pragma pack (1)\nstruct SampleStructPack1\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (2)\nstruct SampleStructPack2\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (4)\nstruct SampleStructPack4\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\n\n\nint main(int argc, char *argv[])\n{\n\n    cout << \"SampleStructPack1\" << endl;\n    print (sizeof(SampleStructPack1), sizeof(SampleStructPack1::flag), sizeof(SampleStructPack1::timeout));\n    cout << \" -- \" << endl;\n\n    cout << \"SampleStructPack2\" << endl;\n    print (sizeof(SampleStructPack2), sizeof(SampleStructPack2::flag), sizeof(SampleStructPack2::timeout));\n\n    cout << \"SampleStructPack4\" << endl;\n    print (sizeof(SampleStructPack4), sizeof(SampleStructPack4::flag), sizeof(SampleStructPack4::timeout));\n\n    cout << \"SampleStruct\" << endl;\n    print (sizeof(SampleStruct), sizeof(SampleStruct::flag), sizeof(SampleStruct::timeout));\n    cout << \" -- \" << endl;\n\n    return 0;\n}\nEjecutando el c\u00f3digo de con las directivas pragma, tenemos distintos resultados dependiendo del valor de pragma.\nSampleStructPack1\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  5 Bytes\n --\n\nSampleStructPack2\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  6 Bytes\n\nSampleStructPack4\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes\n\nSampleStruct\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes\n --\nVeamos caso por caso:\nSampleStructPack1 #pragma pack (1)\nReserva bloques de memoria de un byte, nuestra estructura se ha ajustado perfectamente; en este caso s\u00ed que 4 + 1 = 5.\nSampleStructPack2 #pragma pack (2)\nAhora el m\u00ednimo tama\u00f1o del bloque de memoria es de 2 bytes. Para el entero, hay un ajuste exacto porque necesita 2 bloques que 2 bytes para alojar sus 4 bytes.\nPara el caso del booleano, necesita un bloque de 1 byte, pero como m\u00ednimo tiene que asignar un bloque de 2 bytes, por eso en total reserva 6 bytes, 4 + 2 = 6.\nSampleStructPack4 #pragma pack (4)\nEs el mismo caso que el anterior, aunque  en el caso del booleano, hay un mayor \"desperdicio\" de memoria. Necesita 1 byte, pero reserva 4 bytes que es tama\u00f1o m\u00ednimo de bloque de memoria que puede asignar el compilador.\nSampleStruct (alineaci\u00f3n por defecto del compilador)\nComo vemos se comporta exactamente igual que #pragma pack (4), podemos deducir que la alineaci\u00f3n por defecto del compilador que estamos utilizando es de 4 bytes.\n\nImportant\n\u00bfPor qu\u00e9 no utilizamos siempre la alineaci\u00f3n de memoria m\u00e1s ajustada (#pragma pack (1)) para aprovechar mejor la memoria?\n\nWarning\nPorque perderemos rendimiento.\n\n\n\n\nRendimiento\nVamos a hacer una prueba simple de rendimiento, en la que se va a reservar el mismo n\u00famero de elementos en arrays para cada tipo de estructura.\nEste es el resultado:\nSampleStructPack1: 500000000000000000 bytes allocated in 94311 nanoseconds\nSampleStructPack2: 600000000000000000 bytes allocated in 1777 nanoseconds\nSampleStructPack4: 800000000000000000 bytes allocated in 1519 nanoseconds\nComo vemos cuanto m\u00e1s ajustada es la alineaci\u00f3n de memoria, m\u00e1s tiempo se tarda en reservar y liberar. Puedes ejecutar la prueba de rendimiento en este enlace.\nA continuaci\u00f3n pego el c\u00f3digo de la prueba de rendimiento.\n#include <iostream>\n#include <chrono>\n\n#pragma pack (1)\nstruct SampleStructPack1\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (2)\nstruct SampleStructPack2\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (4)\nstruct SampleStructPack4\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\n\nstatic const long MAX_ELEMENTS = 100000000000000000;\nusing namespace std;\nusing namespace std::chrono;\n\nvoid allocate1()\n{\n    SampleStructPack1 elements [MAX_ELEMENTS];\n    cout << \"SampleStructPack1: \" << sizeof(elements) << \" bytes allocated\";\n}\n\nvoid allocate2()\n{\n    SampleStructPack2 elements [MAX_ELEMENTS];\n    cout << \"SampleStructPack2: \" << sizeof(elements) << \" bytes allocated\";\n}\n\nvoid allocate4()\n{\n    SampleStructPack4 elements [MAX_ELEMENTS];\n    cout << \"SampleStructPack4: \" << sizeof(elements) << \" bytes allocated\";\n}\n\nvoid chrono1()\n{\n    auto begin = high_resolution_clock::now() ;\n    allocate1();\n    cout << \" in \" << duration_cast<nanoseconds>(high_resolution_clock::now() - begin).count() << \" nanoseconds\" << endl;\n}\n\nvoid chrono2()\n{\n    auto begin = high_resolution_clock::now() ;\n    allocate2();\n    cout << \" in \" << duration_cast<nanoseconds>(high_resolution_clock::now() - begin).count() << \" nanoseconds\" << endl;\n}\n\nvoid chrono4()\n{\n    auto begin = high_resolution_clock::now() ;\n    allocate4();\n    cout << \" in \" << duration_cast<nanoseconds>(high_resolution_clock::now() - begin).count() << \" nanoseconds\" << endl;\n}\n\n\nint main(int argc, char *argv[])\n{\n    chrono1();\n    chrono2();\n    chrono4();\n\n    return 0;\n}", 
      "tags": "C++", 
      "loc": "/en/posts/cpp-pragma-pack.html", 
      "title": "Mapeo de un struct C++ en Memoria"
    }, 
    {
      "text": "Sometimes working through a proxy is pretty tedious.\nWe are going how to configure git to work through a proxy\nA generic description, how to make git uses a specific proxy:\n#http\ngit config --global http.proxy <protocol>://<username>:<password>@<ip_host>:<port>\n\n#https\ngit config --global https.proxy <protocol>://<username>:<password>@<ip_host>:<port>\n\n#to disable using proxy\ngit config --global --unset http.proxy\nprotocol\nUse to be http or https\nusername\nThe proxy user name\nip_host\nProxy host address\nport\nProxy listening port\npassword\nYour proxy password\nMore info in official Git configuration.", 
      "tags": "Git,Proxy,Tips and Tricks", 
      "loc": "/en/posts/git-proxy-config.html", 
      "title": "Git proxy configuration"
    }, 
    {
      "text": "A continuaci\u00f3n muestro una forma de eliminar los signos de puntuaci\u00f3n de una cadena de caract\u00e9res en Python. Los signos de puntuaci\u00f3n son reemplazados por caract\u00e9res en blanco.\nimport re, string\n\ndef remove_punctuation ( text ):\n    return re.sub('[%s]' % re.escape(string.punctuation), ' ', text)\nEjecutando:\n>>> remove_punctuation (\"El perro, de San Roque, no tiene rabo; ni nunca lo ha tenido.\")\n'El perro  de San Roque  no tiene rabo  ni nunca lo ha tenido '\nSi queremos hacer la funci\u00f3n m\u00e1s general, para reemplazar los signos de puntuaci\u00f3n por cualquier otra cadena, simplemente hay que hacer la siguiente modificaci\u00f3n en la funci\u00f3n.\nimport re, string\n\ndef replace_punctuation ( text, replace ):\n  return re.sub('[%s]' % re.escape(string.punctuation), replace, text)\nEjecutando el c\u00f3digo de arriba:\n>>> replace_punctuation (\"El perro, de San Roque, no tiene rabo; ni nunca lo ha tenido.\", '[stop]')\n'El perro[stop] de San Roque[stop] no tiene rabo[stop] ni nunca lo ha tenido[stop]'", 
      "tags": "Python,Tips and Tricks", 
      "loc": "/en/posts/remove-replace-punctuation-py.html", 
      "title": "Eliminar/Reemplazar signos de puntuaci\u00f3n en Python"
    }, 
    {
      "text": "En muchos idiomas, como es el caso del espa\u00f1ol, hay caracteres que no tienen representaci\u00f3n ASCII, como por ejemplo la \u00e1 (que s\u00ed que tiene representaci\u00f3n en Unicode).\nPara evitar problemas o por simplificar, se ha dado una equivalencia entre los caracteres Unicode y los ASCII.\nA continuaci\u00f3n os pondr\u00e9 un trozo de c\u00f3digo en Python que hace esta conversi\u00f3n.\n# -*- coding: utf-8 -*-\nfrom unicodedata import normalize\n\ndef normalize_text ( text ):\n  return normalize('NFKD', text).encode('ASCII', 'ignore')\nEjecutando el ejemplo:\n>>> normalize_text ( 'a\u00e1a\u00e1 e\u00e9e\u00e9 i\u00edi\u00ed o\u00f3o\u00f3 \u00f1n\u00f1n A\u00c0A\u00c0' )\nb'aaaa eeee iiii oooo nnnn AAAA'", 
      "tags": "Python,Tips and Tricks", 
      "loc": "/en/posts/normalize-text-py.html", 
      "title": "Normalizar texto en Python"
    }, 
    {
      "text": "cheat-sheets.org\n\n\"All cheat sheets, round-ups, quick reference cards, quick reference guides and quick reference sheets in one page. The only one you need.\"", 
      "tags": "Cheat Sheet,Tips and Tricks", 
      "loc": "/en/posts/cheat-sheets-for-developers.html", 
      "title": "Cheat-sheets for developers"
    }, 
    {
      "text": "When we install a package in most of Linux distributions, the package system installs other packages needed by the package that we actually want to install.\nIf we uninstall the package, its dependencies won't be uninstalled, these unused dependencies are called orphaned packages.\n\nRemove orphaned packages\nArchlinux\nDebian\n\n\n\nArchlinux\npacman -Rsn $(pacman -Qdtq)\nHow does the command work?\npacman -Qdt list all orphaned packages\npacman -Rsn uninstall the listed packages\n\n\nDebian\napt-get remove --purge $(deborphan)", 
      "tags": "Archlinux,Debian,Linux,Tips and Tricks", 
      "loc": "/en/posts/linux-remove-orphaned-files.html", 
      "title": "Remove orphaned packages (Linux)"
    }, 
    {
      "text": "Python\nFunci\u00f3n encargada de eliminar las etiquetas HTML:\n#main.py\n\nimport re\n\ndef strip_tags(value):\nreturn re.sub(r'<[>]*?>', '', value)\nSuponiendo que tenemos el siguiente HTML\n<!DOCTYPE HTML>\n<html>\n        <head>\n                <title>Title</title>\n        </head>\n        <body>\n                <p>Paragraph</p>\n        </body>\n</html>\nVamos a hacer una prueba pasandolo como par\u00e1metro de la funci\u00f3n strip_tags:\n#main.py\n\nhtml_text = \"\"\"\n        <!DOCTYPE HTML>\n        <html>\n                <head>\n                        <title>Title</title>\n                </head>\n                <body>\n                        <p>Paragraph</p>\n                </body>\n        </html>\"\"\"\n\nprint strip_tags(html_text)\nSi ejecutamos el script tenemos como resultado:\nTitle\n\nParagraph\nY si con Python ha sido f\u00e1cil, vamos a ver con Django\n\n\nDjango\n#main.py\n\nfrom django.utils.html import strip_tags\n\nhtml_text = \"\"\"\n        <!DOCTYPE HTML>\n        <html>\n                <head>\n                        <title>Title</title>\n                </head>\n                <body>\n                        <p>Paragraph</p>\n                </body>\n        </html>\"\"\"\n\nprint strip_tags( html_text )\nMucho m\u00e1s sencillo, porque la funci\u00f3n ya est\u00e1 escrita.", 
      "tags": "Django,HTML,Python", 
      "loc": "/en/posts/delete-html-tags-py-django.html", 
      "title": "Eliminar etiquetas HTML"
    }, 
    {
      "text": "Hace tiempo que estoy interesado la construcci\u00f3n, gesti\u00f3n de dependencias, empaquetado y despliegue de proyectos software. Para Java, Scala, Python, etc. Es bastante sencillo ya que hay herramientas como Maven, Gradle, pip, Sbt, etc. Pero para C++_, lo m\u00e1s parecido que he encontrado es Maven con el plugin Nar o Gradle con su plugin cpp (que est\u00e1 en desarrollo).\nHace tiempo que conozco Biicode, pero no hab\u00eda sacado nunca tiempo para probarlo, hasta hoy.\nEl funcionamiento general es muy sencillo.\nNecesitamos instalar biicode en nuestra m\u00e1quina.\nYo he creado un peque\u00f1o ejemplo utilizando el sistema de log de la librer\u00eda Poco.\nHe ejecutado este comando para crear mi proyecto, al que he llamado bii_log. Eso s\u00ed, lo tengo que crear debajo de mi nombre de usuario en Biicode, por si posteriormente lo quiero publicar.\nbii new carlovin/bii_log --hello=cpp\nSe ha creado una estructura de directorios y ficheros con nuestro proyecto. Aunque los \u00fanicos ficheros que vamos a tocar son:\nblocks/carlosvin/bii_log/main.cpp\nblocks/carlosvin/bii_log/biicode.conf\nEn el fichero biicode.conf vamos a configurar nuestras dependencias, en nuestro caso la librer\u00eda Poco.\n# Biicode configuration file\n\n[requirements]\n    fenix/poco(develop): 0\n\n[parent]\n        carlosvin/bii_log: 0\n\n[includes]\n    Poco/*.h: fenix/poco/Foundation/include\nEn la secci\u00f3n [includes], estamos redefiniendo la ruta a nuestros ficheros de cabeceras, porque si no lo hici\u00e9ramos tendr\u00edamos que hacer algo as\u00ed:\n#include \"fenix/poco/Foundation/include/Logger.h\"\nGracias a esta l\u00ednea, en nuestro c\u00f3digo tendremos includes m\u00e1s claros como:\n#include \"Poco/Logger.h\"\nAs\u00ed de f\u00e1cil, ya podemos utilizar la librer\u00eda Poco en nuestro proyecto, por ejemplo:\n#include \"Poco/FileChannel.h\"\n#include \"Poco/FormattingChannel.h\"\n#include \"Poco/PatternFormatter.h\"\n#include \"Poco/Logger.h\"\n#include \"Poco/AutoPtr.h\"\n\nusing Poco::FileChannel;\nusing Poco::FormattingChannel;\nusing Poco::PatternFormatter;\nusing Poco::Logger;\nusing Poco::AutoPtr;\n\nint main(int argc, char** argv) {\n        AutoPtr<FileChannel> pChannel(new FileChannel);\n        pChannel->setProperty(\"path\", \"log/sample.log\");\n        pChannel->setProperty(\"rotation\", \"100 K\");\n        pChannel->setProperty(\"archive\", \"timestamp\");\n\n        //AutoPtr<ConsoleChannel> pCons(new ConsoleChannel);\n        AutoPtr<PatternFormatter> pPF(new PatternFormatter);\n        pPF->setProperty(\"pattern\", \"%Y-%m-%d %H:%M:%S %s: %t\");\n        AutoPtr<FormattingChannel> pFC(new FormattingChannel(pPF, pChannel));\n        Logger::root().setChannel(pFC);\n\n        Logger & logger = Logger::get(\"TestChannel\");\n        for(int i=0; i<10000; i++){\n                poco_information(logger, \"This is a info\");\n                poco_warning(logger, \"This is a warning\");\n        }\n        return 0;\n}\nPara compilar el proyecto simplemente hay que ejecutar:\nbii cpp:build\nY para publicarlo y que cualquiera pueda utilizarlo, como nosotros hemos utilizado Poco:\nbii publish\nAdem\u00e1s de lo sencillo que ha resultado todo, me ha gustado mucho que despu\u00e9s de ejecutar \"bii cpp:build\", mi Eclipse con CDT indexaba perfectamente el c\u00f3digo, as\u00ed como el autocompletado y la navegaci\u00f3n entre clases y m\u00e9todos.\nTambien he leido un articulo sobre lo bien que se integra con CLion: When CLion met biicode.", 
      "tags": "biicode,C++,depencency management,Poco", 
      "loc": "/posts/first-biicode-poco.html", 
      "title": "Gesti\u00f3n de dependencias C++: Biicode"
    }, 
    {
      "text": "Hace unos d\u00edas en el trabajo tuve que rellenar un documento en el que deb\u00eda indicar el tipo de mantenimiento que deb\u00eda hacer y s\u00f3lo ten\u00eda dos opciones: correctivo y adaptativo. Esto me extra\u00f1\u00f3, porque el cambio que yo quer\u00eda hacer no terminaba de encajar en ninguno de los dos tipos.\nHaciendo memoria sobre lo que hab\u00eda dado en mi primera asignatura de Ingenier\u00eda del Software, consegu\u00ed recordar tres tipos, pero me parec\u00eda que me faltaba un tipo.\nHoy por casualidad he encontrado mis apuntes de Ingenier\u00eda del Software y estos son los tipos de mantenimiento ordenados de m\u00e1s a menos porcentaje de tiempo dedicado.\nPerfectivo:Actividades para mejorar o a\u00f1adir nuevas funcionalidades requeridas por el usuario.\nAdaptativo:Actividades para adaptar el sistema a los cambios en su entorno tecnol\u00f3gico (Hardware o software).\nCorrectivo:Corregir defectos en el hardware o software detectados por el usuario durante la explotaci\u00f3n del sistema.\nPreventivo:Actividades para facilitar el mantenimiento del futuro sistema.", 
      "tags": "Software Engineering,Software Maintenance", 
      "loc": "/posts/software-maintenance.html", 
      "title": "Mantenimiento de Software"
    }, 
    {
      "text": "Introducci\u00f3n\nLa construcci\u00f3n, gesti\u00f3n de dependencias y distribuci\u00f3n de mis proyectos es algo que cada vez me preocupa m\u00e1s, me gustar\u00eda encontrar una herramienta que unificara este proceso y fuese independiente del lenguaje, lo m\u00e1s parecido con lo que he trabajado ha sido SCons, Autotools, Ant, Maven y \u00faltimamente Gradle.\nLlevo un tiempo haciendo algunas cosas con Gradle, pero siempre centrado en proyectos Java utiliz\u00e1ndolo como reemplazo a Maven, porque que es m\u00e1s sencillo de usar y m\u00e1s r\u00e1pido. Tambi\u00e9n lo he utilizado en projectos Android y he sufrido la pareja Android Studio + Gradle en sus primeros matrimonios (porque yo he querido), actualmente est\u00e1 todo mucho m\u00e1s documentado y funciona muy bien.\nAntes de nada hay que decir que la construcci\u00f3n de proyectos C/C++ y Objective-C con Gradle se encuentra en fase de incubaci\u00f3n, aunque ya permite hacer algunas tareas avanzadas como:\nGeneraci\u00f3n de m\u00faltiples artefactos dentro del mismo proyecto, esto es varias librer\u00edas o ejecutables.\nGestionar las dependencias entre estos artefactos (sin versiones).\nGenerar distintos \u201csabores\u201d de aplicaciones, por ejemplo: podremos generar una aplicaci\u00f3n \u201cCommunity\u201d y otra con m\u00e1s caracter\u00edsticas habilitadas llamada \u201cEnterprise\u201d.\nPermite generar binarios para distintas plataformas, esto depende de las cadenas de herramientas ( Toolchains ) que tengamos instaladas en la m\u00e1quina de compilaci\u00f3n.\nComo dec\u00eda todav\u00eda tiene limitaciones, aunque est\u00e1n trabajando en ello y si consiguen lo que tienen planeado dejar\u00e9 Autotools (me arrepentir\u00e9 de haber dicho esto).\n\n\u00edndice\nIntroducci\u00f3n\nUn caso pr\u00e1cticoEstructura del proyecto\nLa Aplicaci\u00f3n C++\nConstruyendo con GradleCaso b\u00e1sico\nDistintos \u201cSabores\u201dCommunity\nEnterprise\n\nRelease o Debug\nMulti-plataforma\n\nPru\u00e9balo t\u00fa mism@\n\nConclusiones\n\n\n\n\nUn caso pr\u00e1ctico\nB\u00e1sicamente he sacado todo el ejemplo de aqu\u00ed y lo he adaptado a un caso en el que hay varias plataformas y quiero generar dos versiones distintas de mi software \u201cCommunity\u201d y \u201cEnterprise\u201d.\nLa aplicaci\u00f3n es un ejecutable y una librer\u00eda din\u00e1mica. El ejecutable hace uso de esta librer\u00eda. Ya est\u00e1, solo quiero mostrar lo que nos permite hacer Gradle.\nTambi\u00e9n nos permitir\u00e1 generar una versi\u00f3n para distribuir y otra para depurar.\nTodo el c\u00f3digo se encuentra en https://github.com/carlosvin/cpp_gradle.\n\nEstructura del proyecto\nPodemos crear la estructura que queramos, pero resulta m\u00e1s f\u00e1cil seguir la que espera Gradle, para no tener que especificar donde est\u00e1 el c\u00f3digofuente. Esta es la estructura del proyecto:\ngradle-cpp:Directorio ra\u00edz.\nbuild.gradle:Fichero donde se configura el proyecto Gradle, el equivalente al build.xml de Ant, al Makefile de C/C++ o al pom.xml de Maven.\n\nsrc:Carpeta donde va todo el c\u00f3digo fuente\nhello:Carpeta que contiene el m\u00f3dulo que va a ser la librer\u00eda hello.\ncpp:Carpeta donde van los fuentes C++.\nHello.cpp:Implementaci\u00f3n de la clase Hello.\n\nheaders:Carpeta donde van los ficheros de cabeceras.\nHello.h:Declaraci\u00f3n de la Clase Hello\nMsg.h:Declaraci\u00f3n de constantes.\n\n\nmain:Carpeta que contiene el m\u00f3dulo que ser\u00e1 el ejecutable que utilice la librer\u00eda hello.\ncpp:Carpeta donde van los fuentes C++.\nmain.cpp:C\u00f3digo fuente con la funci\u00f3n main.\n\n\n\nbuild:Carpeta que crea Gradle autom\u00e1ticamente donde deja todos los resultados sus ejecuciones, en ella encontraremos informes de resultados de pruebas, binarios compilados, paquetes para distribuir, etc.\n\n\n\n\nLa Aplicaci\u00f3n C++\nVa a consistir en un ejecutable que har\u00e1 uso de la funcionalidad de la librer\u00eda \u2019hello\u2019.\n// main.cpp\n#include \"Hello.h\"\nint main(int argc, char ** argv)\n{\n    Hello hello (\"Pepito\");\n    hello.sayHello(10);\n    return 0;\n}\nEsta librer\u00eda permite saludar n veces a una persona especificada en su constructor.\n// Hello.h\nclass Hello\n{\n    private:\n        const char * who;\n    public:\n        Hello(const char * who);\n        void sayHello(unsigned n = 1);\n};\n\n\nConstruyendo con Gradle\n\nCaso b\u00e1sico\nLo \u00fanico que necesitamos para construir nuestra aplicaci\u00f3n con Gradle es: tener Gradle [1] y el fichero build.gradle.\n// build.gradle\napply plugin: 'cpp'\n\nlibraries {\n    hello {}\n}\nexecutables {\n    main {\n        binaries.all {\n            lib libraries.hello.shared\n        }\n    }\n}\nCon este fichero tan simple, conseguiremos compilar e instalar nuestra aplicaci\u00f3n, en modo Debug para la plataforma donde estamos ejecutando Gradle, en mi caso es Linux X64.\nSi ejecutamos desde la ra\u00edz de nuestro proyecto gradle task, podremos ver todas las tareas que podemos hacer.\nEn nuestro caso, solo queremos nuestra aplicaci\u00f3n compilada y lista para funcionar, as\u00ed que ejecutaremos: gradle installMainExecutable.\nUna vez que ha terminado, podemos ejecutar el programa llamando al script build/install/mainExecutable/main [2].\n$ build/install/mainExecutable/main\n1.  Hello Mr. Pepito (Community)\n2.  Hello Mr. Pepito (Community)\n3.  Hello Mr. Pepito (Community)\n4.  Hello Mr. Pepito (Community)\n5.  Hello Mr. Pepito (Community)\n6.  Hello Mr. Pepito (Community)\n7.  Hello Mr. Pepito (Community)\n8.  Hello Mr. Pepito (Community)\n9.  Hello Mr. Pepito (Community)\n10. Hello Mr. Pepito (Community)\n\n\nDistintos \u201cSabores\u201d\nCon unas pocas l\u00edneas m\u00e1s, podemos generar distintas versiones de la misma aplicaci\u00f3n, en nuestro ejemplo vamos a generar una versi\u00f3n \u201cCommunity\u201d y otra \u201cEnterprise\u201d.\n//build.gradle\napply plugin: 'cpp'\nmodel {\n    flavors {\n        community\n        enterprise\n    }\n}\nlibraries {\n    hello {\n        binaries.all {\n            if (flavor == flavors.enterprise) {\n                    cppCompiler.define \"ENTERPRISE\"\n            }\n        }\n    }\n}\nexecutables {\n    main {\n        binaries.all {\n            lib libraries.hello.shared\n        }\n    }\n}\nAdem\u00e1s tenemos que preparar nuestra aplicaci\u00f3n para utilizar estos par\u00e1metros de compilaci\u00f3n.\n// Msg.h\n\n#ifdef ENTERPRISE\nstatic const char * EDITION = \"Enterprise\";\n\n#else\nstatic const char * EDITION = \"Community\";\n\n#endif\nDe esta forma se utiliza una cadena u otra en funci\u00f3n del \u201csabor\u201d con que compilemos.\nSi ahora ejecutamos gradle clean task en la ra\u00edz de nuestro proyecto, veremos que tenemos m\u00e1s tareas disponibles, antes ten\u00edamos installMainExecutable y ahora ha sido reemplazada por installCommunityMainExecutable y installEnterpriseMainExecutable.\nSi ejecutamos estas dos tareas, tendremos nuestra aplicaci\u00f3n instalada en los dos sabores.\n$gradle installEnterpriseMainExecutable installCommunityMainExecutable\n\n:compileEnterpriseHelloSharedLibraryHelloCpp\n:linkEnterpriseHelloSharedLibrary\n:enterpriseHelloSharedLibrary\n:compileEnterpriseMainExecutableMainCpp\n:linkEnterpriseMainExecutable\n:enterpriseMainExecutable\n:installEnterpriseMainExecutable\n:compileCommunityHelloSharedLibraryHelloCpp\n:linkCommunityHelloSharedLibrary\n:communityHelloSharedLibrary\n:compileCommunityMainExecutableMainCpp\n:linkCommunityMainExecutable\n:communityMainExecutable\n:installCommunityMainExecutable\n\nBUILD SUCCESSFUL\nTotal time: 9.414 secs\nAhora podemos ejecutar nuestra aplicaci\u00f3n en los dos sabores:\n\nCommunity\n$ build/install/mainExecutable/community/main\n1.      Hello Mr. Pepito        (Community)\n2.      Hello Mr. Pepito        (Community)\n3.      Hello Mr. Pepito        (Community)\n4.      Hello Mr. Pepito        (Community)\n5.      Hello Mr. Pepito        (Community)\n6.      Hello Mr. Pepito        (Community)\n7.      Hello Mr. Pepito        (Community)\n8.      Hello Mr. Pepito        (Community)\n9.      Hello Mr. Pepito        (Community)\n10.     Hello Mr. Pepito        (Community)\n\n\nEnterprise\n$ build/install/mainExecutable/enterprise/main\n1.      Hello Mr. Pepito        (Enterprise)\n2.      Hello Mr. Pepito        (Enterprise)\n3.      Hello Mr. Pepito        (Enterprise)\n4.      Hello Mr. Pepito        (Enterprise)\n5.      Hello Mr. Pepito        (Enterprise)\n6.      Hello Mr. Pepito        (Enterprise)\n7.      Hello Mr. Pepito        (Enterprise)\n8.      Hello Mr. Pepito        (Enterprise)\n9.      Hello Mr. Pepito        (Enterprise)\n10.     Hello Mr. Pepito        (Enterprise)\n\n\n\nRelease o Debug\nPor defecto Gradle compila nuestra aplicaci\u00f3n en modo Debug, pero podemos a\u00f1adir el modo Release para que active algunas optimizaciones [3].\n// build.gradle\n\napply plugin: 'cpp'\nmodel {\n    buildTypes {\n        debug\n        release\n    }\n\n// ... the rest of file below doesn't change\nSi ahora ejecutamos gradle clean task veremos que tenemos m\u00e1s tareas, se habr\u00e1n desdoblado las que ten\u00edamos, por ejemplo installCommunityMainExecutable se habr\u00e1 desdoblado en installDebugCommunityMainExecutable y installReleaseCommunityMainExecutable.\n\n\nMulti-plataforma\nTambi\u00e9n tenemos las posibilidad de utilizar las caracter\u00edsticas de compilaci\u00f3n cruzada que nos ofrecen los compiladores y generar componentes nativos para otras plataformas. El proceso es el mismo, simplemente tenemos que dar te alta las plataformas que vamos a soportar.\nEsto solo funcionar\u00e1 si en nuestro sistema tenemos instalada la cadena de herramientas ( Toolchains ) necesaria, es decir, si en un sistema de 64 bits queremos compilar para 32 bits, tendremos que tener instaladas las librer\u00edas necesarias para 32 bits.\n// build.gradle\n\napply plugin: 'cpp'\nmodel {\n    buildTypes {\n        debug\n        release\n    }\n    platforms {\n        x86 {\n            architecture \"x86\"\n        }\n        x64 {\n            architecture \"x86_64\"\n        }\n        itanium {\n            architecture \"ia-64\"\n        }\n    }\n    flavors {\n        community\n        enterprise\n    }\n}\nlibraries {\n    hello {\n        binaries.all {\n            if (flavor == flavors.enterprise) {\n                cppCompiler.define \"ENTERPRISE\"\n            }\n        }\n    }\n}\nexecutables {\n    main {\n        binaries.all {\n            lib libraries.hello.shared\n        }\n    }\n}\nEjecutando gradle clean task podremos ver las distintas opciones de construci\u00f3n que tenemos, en nuestro caso veremos que podemos construir distintas versiones de nuestra aplicaci\u00f3n en distintos sabores, para distintas plataformas en Debug o Release.\n\n\n\nPru\u00e9balo t\u00fa mism@\nEl proyecto se encuentra en https://github.com/carlosvin/cpp_gradle.\nPara poder probar necesitas:\nTener instalado Java a partir de la versi\u00f3n 6.\nTener alg\u00fan compilador instalado (por ejemplo GCC)\nSolo tienes que seguir los siguientes pasos:\ngit clone git@github.com:carlosvin/cpp_gradle.git\ncd cpp_gradle\n./gradlew task o ./gradlew.bat task si est\u00e1s en Windows. De esta forma ver\u00e1s todas las tareas que te ofrece Gradle para este proyecto. La primera vez tardar\u00e1 un poco porque se descarga una versi\u00f3n de Gradle.\nSi est\u00e1s en una m\u00e1quina de 64 bits, por ejemplo utiliza este comando para compilar e instalar la aplicaci\u00f3n ./gradlew installX64ReleaseEnterpriseMainExecutable.\nEjecuta la aplicaci\u00f3n que acabas de construir build/install/mainExecutable/x64ReleaseEnterprise/main\n\n\n\nConclusiones\nCon una configuraci\u00f3n m\u00ednima, tenemos muchas posibilidades de construcci\u00f3n de aplicaciones nativas multi-plataforma.\nTiene un futuro prometedor, veremos como termina. Aunque si sigue los pasos del soporte para Java o Android, seguro que llega a buen puerto.\nPodemos utilizar otras caracter\u00edsticas de Gradle y aplicarlas a nuestros proyectos C++, como an\u00e1lisis est\u00e1ticos de c\u00f3digo, generaci\u00f3n de informes (pruebas, cobertura, calidad, etc.), f\u00e1cil incorporaci\u00f3n a sistemas de integraci\u00f3n continua.\nGradle para C++ es una caracter\u00edstica que actualmente est\u00e1 en desarrollo, por lo que no hay que olvidar que:\nNo debemos utilizar en entornos reales de desarrollo, puede acarrear muchos dolores de cabeza.\nLa forma de definir el fichero build.gradle para esta caracter\u00edstica puede cambiar.\nTodo el ejemplo se encuentra en https://github.com/carlosvin/cpp_gradle.\nOs recomiendo que lo descargu\u00e9is y prob\u00e9is lo sencillo que resulta.\nGetting Started Gradle Native.\n[n]'n' es un n\u00famero entero positivo[1]Realmente no es necesario tener instalado Gradle, si utilizamos el wrapper, pero esto no lo vamos a tratar hoy, si quer\u00e9is m\u00e1s informaci\u00f3n.[2].bat en Windows y sin extensi\u00f3n en Linux[3]Tambi\u00e9n podemos definir el tipo de optimizaciones que vamos a utilizar.", 
      "tags": "Build Construction Systems,C++,Gradle", 
      "loc": "/posts/gradle-cpp.html", 
      "title": "Construir un proyecto C++ con Gradle"
    }, 
    {
      "text": "He encontrado por ah\u00ed un grupo tecnol\u00f3gico-art\u00edstico llamados AlgoRythmics, que ense\u00f1an c\u00f3mo funcionan los algoritmos de ordenaci\u00f3n m\u00e1s conocidos.\nSiempre puedes consultar en la wikipedia Algoritmos de ordenamiento, aunque no creo que sea tan r\u00e1pido ni tan divertido para aprender como con AlgoRythmics, os dejo el ejemplo del Quicksort.", 
      "tags": "Algorithm,Programming,Sorting", 
      "loc": "/posts/sorting-algorithm-dancing.html", 
      "title": "C\u00f3mo funcionan los algoritmos de ordenaci\u00f3n (Bailando)"
    }, 
    {
      "text": "Bases de datos embebidas\nSe trata de bases de datos que carecen de servidor, est\u00e1n inscrustadas en la propia aplicaci\u00f3n y suelen estar almacenadas en ficheros locales. Esto \u00faltimo unido a que suelen tener un modo de funcionamiento en el que mantienen los datos en memoria hace que puedan tener un rendimiento muy alto.\nEso s\u00ed, este gran grado acoplamiento a la aplicaci\u00f3n, hace que tengan peor rendimiento cuando se comparten entre varias aplicaciones debido a colisiones de acceso.\nOtra ventaja es que no tenemos que encargarnos de mantener y gestionar un servidor de bases de datos.\nVoy a hacer una comparativa de rendimiento entre 3 bases de datos embebidas ACID (transaccionales), las NoSQL no entran en esta comparativa que est\u00e1n en otra liga de rendimiento.\n\nContenidos\nBases de datos embebidasSQLite\nDerby o JavaDB\nObjectDB\n\nLos TestsInterfaz DB\nLas Bases de Datos JDBC\nEl c\u00f3digo fuente\nResultados de los tests\n\n\n\n\nSQLite\nSe trata de una librer\u00eda escrita en ANSI C, de menos de 500KB, multi-plataforma, sin dependencias externas, almacena todo el contenido de la base de datos en un solo fichero.\nEs la que da mejor rendimiento en los Resultados de los tests.\nSe puede utilizar desde C y C++, pero tambi\u00e9n desde otros lenguajes de programaci\u00f3n  (PHP, Python, Java, .NET ...).\nEn el caso de Java podemos gestionar esta base de datos a trav\u00e9s de JDBC. Podemos obtener la librer\u00eda de https://bitbucket.org/xerial/sqlite-jdbc.\nVeamos un ejemplo de la inserci\u00f3n de una serie de objetos de la clase Price.\npublic class JdbcDb implements DB {\n\n        enum Column {\n                INSTRUMENT,\n                MARKET,\n                PRICE,\n                DATE;\n        }\n\n        public static final String TABLE_NAME = \"PRICES\";\n        public static final String SQL_INSERT = \"INSERT INTO \" + TABLE_NAME\n                        + \" (INSTRUMENT, MARKET, PRICE, DATE) VALUES (?,?,?,?)\";\n\n        // ...\n\n        private void insert(Price p, PreparedStatement preparedStatement) throws SQLException {\n                preparedStatement.setString(1, p.getInstrument());\n                preparedStatement.setString(2, p.getMarket());\n                preparedStatement.setDouble(3, p.getPrice());\n                preparedStatement.setTimestamp(4, new Timestamp(p.getDate().getTime()));\n                preparedStatement.addBatch();\n        }\n\n        @Override\n        public void insert(Price... prices) throws SQLException {\n                PreparedStatement preparedStatement = conn.prepareStatement(SQL_INSERT);\n                for (Price p : prices) {\n                        insert(p, preparedStatement);\n                }\n                preparedStatement.executeBatch();\n                preparedStatement.close();\n                conn.commit();\n        }\n\n        // ...\n}\n\n\nDerby o JavaDB\nJavaDB es una distribuci\u00f3n de Oracle de la base de datos de c\u00f3digo libre Derby. Soporta el est\u00e1ndar ANSI/ISO SQL  a trav\u00e9s de JDBC y Java EE. Estas librer\u00edas est\u00e1n incluidas en el JDK.\nAlmacena la base de datos en multiples archivos, lo que puede resultar \u00fatil para escalar el almacenamiento.\nSolo podemos utilizarlo en Java, no desde otros lenguajes.\nComo veremos m\u00e1s adelante ha sido la m\u00e1s lenta en los Resultados de los tests.\nLa implementaci\u00f3n de ejemplo de una inserci\u00f3n de una serie de objetos de la clase Price, es exactamente la misma que la que hemos hecho m\u00e1s arriba en SQLite, esto es una de las bondades de JDBC, que nos permite obtener una conexi\u00f3n para una base de datos espec\u00edfica, pero a partir de ah\u00ed casi siempre nos podemos olvidar de la base de datos con la que trabajamos, siempre y cuando soporte nuestras consultas SQL.\n\n\nObjectDB\nEs una base de datos orientada a objetos que nos permite acceso JPA, un est\u00e1ndar de Java que persigue no perder las ventajas de la orientaci\u00f3n a objetos; esto se suele perder cuando nos acercamos a la capa de persistencia.\nResulta realmente sencillo realizar acciones t\u00edpicas de una base de datos, abstray\u00e9ndonos del SQL, por ejemplo veamos c\u00f3mo quedar\u00eda una inserci\u00f3n de un array de objetos de la clase Price con ObjectDB.\npublic void insert(Price... prices) throws SQLException {\n        em.getTransaction().begin();\n        for (Price p : prices) {\n                em.persist(p);\n        }\n        em.getTransaction().commit();\n}\nSi a esta facilidad de uso, le unimos que los Resultados de los tests de rendimiento han sido muy buenos (cerca de SQLite), puedo decir que he descubierto una base de datos embebida a tener muy en cuenta en futuros proyectos Java, eso s\u00ed, al igual que con JavaDB, solo nos sirve si vamos a programar en Java.\n\n\n\nLos Tests\nSimplemente consisten en realizar repetidamente una serie operaciones CRUD. Para cada base de datos, el test realiza una serie de inserciones, selects, actualizaciones y borrado de objetos de la clase Precio.\nHe utilizado 100000 instancias de la clase Price, las mismas para cada tipo de base de datos.\nPara esto he creado una interfaz DB que compartir\u00e1n cada una de las implementaciones para cada base de datos.\n\nInterfaz DB\n\npublic interface DB {\n\n        public void insert(Price... prices) throws SQLException;\n\n        public void createTable();\n\n        public void deleteAll();\n\n        public void update(Price... prices) throws SQLException;\n\n        public Set<Price> selectAll();\n\n}\n\n\n\nLas Bases de Datos JDBC\nSolo cambian los datos necesarios para obtener el driver y la conexi\u00f3n a la base de datos,  por eso toda la l\u00f3gica est\u00e1 en la clase JdbcDb de la que heredan SqliteDb y DerbyDB.\n\n\nEl c\u00f3digo fuente\nPod\u00e9is descargar el c\u00f3digo fuente de https://github.com/carlosvin/java_embedded_databases.\nSe trata de un proyecto Gradle por lo que para ejecutar los tests solo ten\u00e9is que escribir (y tener instalado Gradle claro):\n\ngrade test\n\nGradle se descargar\u00e1 autom\u00e1ticamente las librer\u00edas necesarias, compilar\u00e1 y ejecutar\u00e1 los tests.\nTambi\u00e9n pod\u00e9is ver directamente la ejecuci\u00f3n en https://travis-ci.org/carlosvin/java_embedded_databases.\nhttps://travis-ci.org/carlosvin/java_embedded_databases.svg\n\n\nResultados de los tests\nA continuaci\u00f3n pod\u00e9is ver un con los resultados de los tests.\n\nAbrir el gr\u00e1fico interactivo | Abrir imagen", 
      "tags": "database,embedded,Java", 
      "loc": "/posts/java-embedded-db-performance-comparison.html", 
      "title": "Bases de Datos Embebidas Java: Comparaci\u00f3n de Rendimiento"
    }, 
    {
      "text": "Hace poco, he tenido que serializar/deserializar unos datos en Java, hac\u00eda mucho que no lo hac\u00eda en formato binario directamente (ultimamente he utilizado JSON o XML). Recordaba haber serializado objetos implementando el interfaz Serializable, pero hab\u00eda visto por Internet otra forma implementando el interfaz Externalizable, \u00bfcu\u00e1l interfaz utilizo? Pues depende lo que quieras y necesites, como todo.\n\nCu\u00e1ndo utilizar Serializable o Externalizable\nSerializable\nExternalizable\nPruebas de Rendimiento (Serializable vs Externalizable)Utilizando el interfaz Serializable\nUtilizando el interfaz Externalizable (mal)\nUtilizando el interfaz Externalizable (bien)\nAnalizando los resultados\n\n\n\n\nSerializable\nCuando quieras serializar algo programando poco, es la forma f\u00e1cil.\nPero tiene algunas restricciones: El objeto a serializar debe implementar el constructor por defecto. Debe hacerse responsable de los atributos no accesibles de la clase padre.\nCuando no te importe mucho el rendimiento, como veremos en la secci\u00f3n Pruebas de Rendimiento (Serializable vs Externalizable).\n\n\nExternalizable\nVas a tener que implementar t\u00fa mismo los m\u00e9todos de serializaci\u00f3n.\nCuando no puedas utilizar Serializable.\nCuando quieras obtener un mejor rendimiento, como veremos en la secci\u00f3n Pruebas de Rendimiento (Serializable vs Externalizable)\nSi tienes que encargarte de la serializaci\u00f3n de los atributos de la clase padre, te recomiendo utilizar Externalizable, porque evitamos una sobrescritura extra\u00f1a de m\u00e9todos privados.\nprivate void writeObject(ObjectOutputStream oos)\nprivate void readObject(ObjectInputStream ois)\n\n\nPruebas de Rendimiento (Serializable vs Externalizable)\nEl interfaz Serializable utilizando la introspecci\u00f3n de Java, adivina los tipos de los atributos de las clases que va a serializar/deserializar, pero esta \"magia\" tiene una penalizaci\u00f3n en el rendimiento.\nAl utilizar el interfaz Externalizable somos nosotros los que decidimos como serializar/deserializar los objetos, es decir, tenemos que escribir nosotros el c\u00f3digo que hace esto. Hemos perdido comodidad, pero evitamos que Java haga algunas tareas y, si sobrescribimos correctamente los m\u00e9todos del interfaz Externalizable, conseguiremos una mejora de rendimiento.\nPara saber cu\u00e1nto es la diferencia de rendimiento, he escrito un peque\u00f1o ejemplo en el que se serializa un objeto con dos colecciones con 100000 emails y 100000 tel\u00e9fonos. He contemplado 3 casos:\n\nUtilizando el interfaz Serializable\nComo dijimos m\u00e1s arriba, utilizando el interfaz Serializable Java tiene que adivinar ciertas cosas, en este proceso sacrifica algo de rendimiento (es el que m\u00e1s tarda), a cambio \u013ao \u00fanico que tenemos que hacer es que nuestra clase implemente el interfaz Serializable.\npublic class Contacts implements Serializable {\n1133 milisegundos en serializar\n506  milisegundos en deserializar\n\n\nUtilizando el interfaz Externalizable (mal)\nEn este caso somos nosotros los encargados de \"decir\" a Java c\u00f3mo debe serializar/deserializar, pero debemos ser cuidadosos, de lo contrario podemos quedarnos con lo peor de los dos mundos, por ejemplo: Si simplemente serializamos/deserializamos los atributos de la clase, y estos son atributos complejos (como colecciones), Java tambi\u00e9n tiene que adivinar bastantes cosas y tambi\u00e9n sacrificamos algo de rendimiento y adem\u00e1s hemos tenido que escribir m\u00e1s c\u00f3digo.\n@Override\npublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n  setEmails((Set<String>) in.readObject());\n  setPhones((Set<String>) in.readObject());\n}\n\n@Override\npublic void writeExternal(ObjectOutput out) throws IOException {\n  out.writeObject(emails);\n  out.writeObject(phones);\n}\n737 milisegundos en serializar\n367 milisegundos en deserializar\n\n\nUtilizando el interfaz Externalizable (bien)\nSi serializamos/deserializamos uno por uno los elementos de las colecciones, ahorramos a\u00fan m\u00e1s tiempo, porque Java est\u00e1 serializando tipos m\u00e1s simples (en este caso java.lang.String).\n@Override\npublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n  emails.clear();\n  phones.clear();\n  int nEmails = in.readInt();\n  for (int i = 0; i < nEmails; i++) {\n    emails.add(in.readUTF());\n  }\n  int nPhones = in.readInt();\n  for (int i = 0; i < nPhones; i++) {\n    phones.add(in.readUTF());\n  }\n}\n\n@Override\npublic void writeExternal(ObjectOutput out) throws IOException {\n  out.writeInt(emails.size());\n  for (String e : emails) {\n    out.writeUTF(e);\n  }\n  out.writeInt(phones.size());\n  for (String p : phones) {\n    out.writeUTF(p);\n  }\n}\n204 milisegundos en serializar\n92  milisegundos en deserializar\nHemos ganado rendimiento a costa de escribir un poco m\u00e1s de c\u00f3digo.\n\n\nAnalizando los resultados\n\nCaution!\nPor el hecho de utilizar un interfaz u otro, no ganamos rendimiento.\n\n\nTip\nGanamos rendimiento porque el interfaz Externalizable nos \"obliga\" a implementar parte de la serializaci\u00f3n y quitamos esta carga a Java.\n\nAunque como hemos visto en Utilizando el interfaz Externalizable (bien), si no tenemos cuidado, conseguiremos una mejora muy peque\u00f1a.\nA continuaci\u00f3n pod\u00e9is ver un gr\u00e1fico con los resultados de los tests.\n\nAbrir el gr\u00e1fico interactivo | Abrir imagen\n\nA continuaci\u00f3n os dejo los enlaces a:\nResultados de los tests.\n\nC\u00f3digo en github.\n\nEstado de la Construcci\u00f3n en travis", 
      "tags": "Java", 
      "loc": "/posts/serialization-java-serializable-externalizable.html", 
      "title": "Distintas formas de serializaci\u00f3n en Java: Comparaci\u00f3n de rendimiento"
    }, 
    {
      "text": "En C++11 se han introducido muchas mejoras que nos ayudan a desarrollar sistemas multi-hilo. Voy a centrarme en los mutex.\nEn las versiones anteriores a C++11 una forma de obtener un mutex es el que nos proporciona la librer\u00eda pthread, pero para utilizarlo deb\u00edabos inicializarlo y destruirlo en estilo C, en definitiva, tienes que hacer algo m\u00e1s que lock/unlock cada vez que trabajas con un mutex.\nC++11 nos proporciona una clase mutex, que nos abstrae de cosas que no son lock/unclock. Os recomiendo que ech\u00e9is un vistazo y ve\u00e1is lo limpio que queda el c\u00f3digo: Clase mutex de C++11.\nSi sigues trabajando con versiones de compiladores previos a C++11, hace tiempo me hice un wrapper que te ayuda a abstraerte del mutex de pthread, lo dejo aqu\u00ed abajo por si a alguien le resulta \u00fatil.\nAbajo est\u00e1 un Gist del C\u00f3digo, he vuelto a escribir el c\u00f3digo de cabeza y puede ser que haya alg\u00fan error, lo revisar\u00e9, pero lo importante es la idea de hacer una clase que envuelva la inicializaci\u00f3n del mutex de pthread.\n\n\n#include \"Mutex.h\"\n#include <exception>\n\n\nMutex::Mutex()\n{\n    if ( pthread_mutex_init(&_mutex, NULL) )\n    {\n        throw \"Error: Initializing _mutex\";\n    }\n}\n\nMutex::~Mutex()\n{\n\n    pthread_mutex_destroy(&_mutex);\n}\n\nMutex::Mutex(const Mutex & obj)\n{\n\t_mutex = obj._mutex;\n}\n\nMutex & Mutex::operator=(const Mutex & obj)\n{\n\t_mutex = obj._mutex;\n\treturn *this;\n}\n\nbool Mutex::operator==(const Mutex & obj)\n{\n\treturn _mutex == obj._mutex;\n}\n\nbool Mutex::operator!=(const Mutex & obj)\n{\n\treturn !(*this == obj);\n}\n\nvoid Mutex::lock ()\n{\n    pthread_mutex_lock( &_mutex );\n}\n\nvoid Mutex::unlock ()\n{\n    pthread_mutex_unlock( &_mutex );\n}\n\nvoid Mutex::lock ( int lock, Mutex * mtx)\n{\n\tif (lock)\n\t{\n\t\tmtx->lock();\n\t}\n\telse\n\t{\n\t\tmtx->unlock();\n\t}\n}", 
      "tags": "C++,pthread", 
      "loc": "/posts/cpp-mutex.html", 
      "title": "Mutex C++"
    }, 
    {
      "text": "He estado escuchando una charla de A. Jesse Jiryu Davis sobre la librer\u00eda asycnio de Python.\nSe trata de una librer\u00eda introducida en la versi\u00f3n 3.4 de Python que da soporte a programaci\u00f3n concurrente sobre un solo hilo, lo cual supone un ahorro muy importante de memoria.\nEn la charla nos cuenta qu\u00e9 es, c\u00f3mo funciona, cu\u00e1ndo utilizarlo y cu\u00e1ndo no.", 
      "tags": "Programming,Python", 
      "loc": "/posts/async-what-how-when.html", 
      "title": "Python asyncio: Qu\u00e9, C\u00f3mo, C\u00faando"
    }, 
    {
      "text": "He visto en Google Science Fair una colecci\u00f3n de ecuaciones que han cambiado el mundo.\nEn mi opini\u00f3n, comprender algunas de estas ecuaciones deber\u00eda entrar en lo que llamamos \"Cultura General\".", 
      "tags": "G+,Math,Pysics,Science", 
      "loc": "/posts/equations-that-changed-the-word.html", 
      "title": "Ecuaciones que han cambiado el Mundo"
    }, 
    {
      "text": "Supongo que, como la mayor\u00eda, vengo del concepto de software de gesti\u00f3n de blogs o gestores de contenidos din\u00e1micos, basados en:\nenviar informaci\u00f3n desde un navegador a un servidor\nprocesar y almacenar la informaci\u00f3n en una base de datos o en ficheros\nel servidor genera una respuesta din\u00e1micamente que se env\u00eda al navegador en forma de HTMLpara generar esta respuesta se suele leer de la base de datos o de los ficheros\n\nDe todo este proceso se encarga un software instalado en el servidor, nuestro gestor de contenidos.\nAhora he cambiado al paradigma de \"generador de sitios web est\u00e1ticos\", en concreto voy a utilizar Nikola, aunque esta vez no lo voy a instalar en ning\u00fan servidor.\nEn otro post os contar\u00e9 c\u00f3mo he montado esto con Github [1] y Travis [2].\nMi camino para llegar hasta los generadores de sitios web est\u00e1ticos ha pasado por las etapas que os cuento abajo (me he saltado alguna menos importante).\n\nCamino hasta Nikola\nPhpNuke\nMi propio gestor de contenidos\nDrupal\nWordpress\nCMSdj\nNikola\n\n\n\nPhpNuke\nS\u00ed, sigue existiendo. Aqu\u00ed entramos un gestor de contenido basado PHP+MySQL, multi-idioma, gesti\u00f3n de usuarios, grupos de usuarios, ampliable con temas, plugins, etc.\n\n\nMi propio gestor de contenidos\nQue no era tal, porque se qued\u00f3 en un blog en el que pod\u00eda publicar contenidos din\u00e1micamente, tambi\u00e9n hecho en PHP y MySQL. Me sirvi\u00f3 para:\nPublicar posts con problemas.\nDarme cuenta de que un programador necesita a un dise\u00f1ador.\nPHP a nivel sint\u00e1ctico, es feo (cuesti\u00f3n de gustos).\nEmpezar a entender la importancia de DRY [3].\n\n\nDrupal\nUn gestor de contenidos muy completo, que me gust\u00f3 mucho, hasta que se empezaron a \"romper\" cosas (comparto culpa con Drupal) y me cans\u00e9. Pero quiero remarcar que tiene todo lo que yo pod\u00eda esperar de un gestor de contenidos y m\u00e1s.\n\n\nWordpress\nYa no voy a entrar en si es mejor o peor que Drupal, que de eso hay mucho por Internet. Simplemente es mucho m\u00e1s usable y f\u00e1cil de actualizar.\n\n\nCMSdj\nMi segundo intento de creaci\u00f3n de mi propio gestor de contenidos. Ten\u00eda una idea en la cabeza, de c\u00f3mo deber\u00eda ser un dise\u00f1o del modelo de un gestor de contenidos, todav\u00eda la tengo. Y recientemente hab\u00eda descubierto Django, un framework que me encant\u00f3 hecho con un lenguaje que me encanta, Python, \u00bfqui\u00e9n se puede resistir ahora a crear su propio CMS [4]?\nCMSdj est\u00e1 por ah\u00ed en Bitbucket y funciona, tiene su propio buscador, gesti\u00f3n de templates, sistema de comentarios, sistema de votaci\u00f3n, acercamiento a HTML5 + CSS3 y algunas cosillas m\u00e1s, pero:\nYa no sacaba tiempo para desarrollar, un par de horas a la semana, como mucho, y gastaba una hora en recordar por donde iba.\nSegu\u00eda necesitando un dise\u00f1ador.\nAs\u00ed que declar\u00e9 este proyecto muerto por aburrimiento, aunque segu\u00ed utiliz\u00e1ndolo para publicar mis cosillas, pero cada vez que iba a escribir algo en mi blog y ve\u00eda todo a medio hacer, me pon\u00eda malo, as\u00ed que decid\u00ed cerrar y empezar de nuevo.\n\n\nNikola\nTengo que decir que quer\u00eda un generador de sitios est\u00e1ticos, porque est\u00e1n de moda y toda la gente escribe sobre sus bondades y me convencieron. Prob\u00e9 Jekyll para que no me lo contaran, que es el m\u00e1s famoso. Pero prefer\u00eda uno hecho en Python por si quer\u00eda meter mano alguna vez. As\u00ed que despu\u00e9s de buscar un poco, me qued\u00e9 entre Nikola, Mynt y Pelican. Me qued\u00e9 con Nikola  por descarte:\n* Pelican me di\u00f3 algunos problemas en la utilizaci\u00f3n de varios idiomas y en las categor\u00edas, aunque de primeras fue el que m\u00e1s me convenci\u00f3. De hecho, es posible que esos problemas los crease yo, pero no quer\u00eda gastar mucho tiempo en investigar.\n* Mynt me encant\u00f3 por su sencillez, aunque tienes que hacerte tus propios templates y no quiero darme cuenta otra vez de lo que necesito a un dise\u00f1ador.\n[1]En Github alojo el sitio generado, toda la parte est\u00e1tica (las p\u00e1ginas en HTML, im\u00e1genes, etc.)[2]Travis es un software the integraci\u00f3n cont\u00ednua (como Jenkins), yo lo utilizo para automatizar el despliegue del sitio, esto es, para descargar el sitio cada vez que lo cambie en Github, volver a generarlo y publicarlo otra vez.[3]Don't Repeat Yourself (En espa\u00f1ol, \"no te repitas\")[4]Content Management System (\"Sistema de gesti\u00f3n de contenidos\")", 
      "tags": "Python,Static Sites", 
      "loc": "/posts/primer-post.html", 
      "title": "Primer Post utilizando Nikola"
    }, 
    {
      "text": "Para quien quiera utilizar Android Studio sin instalarlo, como un programa \"portable\", aqu\u00ed os dejo el enlace a la \u00faltima versi\u00f3n de Android Studio.", 
      "tags": "Android,Java,Software", 
      "loc": "/posts/android-studio-portable-download.html", 
      "title": "Android Studio Portable Download"
    }, 
    {
      "text": "Trabajando con libtool [1], cuando vamos a depurar un ejecutable que utiliza una librer\u00eda generada con libtool, es posible que nos encontremos con el siguiente error:\n$ gdb ./tests-mylib\n\"tests-mylib\": not in executable format: File format not recognized\nlibmylib.so es una librer\u00eda din\u00e1mica generada con libtool\ntests-mylib es un ejecutable que utiliza la librer\u00eda mylib\nPara los que est\u00e9is pensando que se me ha olvidado poner la opci\u00f3n de compilaci\u00f3n -g, lo siento, pero este error ocurre aunque utilicemos -g.\nEl error es debido a que estamos intentando ejecutar un script generado por libtool, es una envoltura sobre el programa real, para facilitar la ejecuci\u00f3n de \u00e9ste [libtooldoc].\nPara poder depurar nuestro programa de prueba tests-mylib\nlibtool --mode=execute gdb tests-mylib\n[1]Herramienta que pertenece a la Autotools usada para crear bibliotecas de software portables.[libtooldoc]Esta informaci\u00f3n la he sacado de http://www.gnu.org/software/libtool/manual/libtool.html#Debugging-executables", 
      "tags": "Autotools,C++,GNU,Tips and Tricks", 
      "loc": "/posts/debug-libtool-lib.html", 
      "title": "Depurar librer\u00eda generada con libtool"
    }, 
    {
      "text": "Un struct de C++ es un elemento que permite agrupar elementos de tipos distintos con alguna relaci\u00f3n entre ellos. Esto permite manipular todos los elementos en bloque mediante una \u00fanica referencia.\nSi alguna vez nos interesa trabajar a un nivel m\u00e1s bajo, nos puede resultar \u00fatil entender c\u00f3mo se mapea una estructura en memoria y c\u00f3mo controlar este mapeo.\n\nTabla de Contenidos\nEstructura de ejemplo\nLa directiva #pragma pack en struct C++\nRendimiento\n\n\n\nEstructura de ejemplo\nEsta estructura estar\u00e1 compuesta por dos campos, un entero (4 bytes) y un booleano (un byte). En C++ queda de la siguiente forma:\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\nSi hacemos un sizeof de la una instancia de la estructura deber\u00edamos obtener un tama\u00f1o de 5 bytes. Y la memoria quedar\u00eda de la siguiente forma:\n\nEstructura de 5 bytes que realmente ocupa 5 bytes en memoria.\n\nPero no es tan sencillo, a continuaci\u00f3n veremos que no nos podemos olvidar de la alineaci\u00f3n de la memoria que hace el compilador en ese sistema y veremos c\u00f3mo controlarlo para no encontrarnos con tama\u00f1os inesperados, ya que esto depende del compilador del sistema.\nPor ejemplo, si en mi m\u00e1quina hago un sizeof de la estructura, obtengo un tama\u00f1o de 8 bytes. Lo que est\u00e1 sucediendo es que el compilador reserva m\u00e1s memoria al final de la estructura para que cuadre en bloques de 2n bytes. La memoria queda de la siguiente forma:\n\nEstructura de 5 bytes que realmente ocupa 8 bytes en memoria. Para ser m\u00e1s precisos, deber\u00eda haber dibujado la memoria no usada a continuaci\u00f3n del atributo flag.\n\nVamos a ver un fragmento de c\u00f3digo que imprime el tama\u00f1o de la estructura y el de cada uno de sus atributos y verificar, en este caso 4 + 1 no es 5.\n#include  <iostream>\n\nusing namespace std;\n\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\n\nstatic void print (size_t sz, size_t sz_flag, size_t sz_timeout)\n{\n    cout << \"\\tflag: \" << sz_flag << \" Bytes\" << endl;\n    cout << \"\\t+\" << endl;\n    cout << \"\\ttimeout: \" << sz_timeout << \" Bytes\" << endl;\n    cout << \"\\t=\" << endl;\n    cout << \"\\t\" << sz_timeout + sz_flag << \" Bytes\" << endl;\n    cout <<\"sizeof struct:  \" << sz << \" Bytes\" << endl;\n}\n\nint main(int argc, char *argv[])\n{\n    cout << \"SampleStruct\" << endl;\n    print (sizeof(SampleStruct), sizeof(SampleStruct::flag), sizeof(SampleStruct::timeout));\n    cout << \" -- \" << endl;\n\n    return 0;\n}\nEjecutando el c\u00f3digo de sin la directiva pragma, tenemos que nuestra estructura ocupa 8 bytes en lugar de 5 bytes.\nSampleStruct\nflag: 1 Bytes\n+\ntimeout: 4 Bytes\n=\n5 Bytes\nsizeof struct:  8 Bytes\n--\n\nTip\nSi queremos conocer el tama\u00f1o exacto de las estructuras que vamos a utilizar, tenemos que especificar al compilador la forma de alinear la estructura en memoria, para ello utilizaremos la directiva #pragma pack(n).\n\n\n\nLa directiva #pragma pack en struct C++\nSe trata de una directiva del preprocesador que indica al compilador c\u00f3mo debe realizar la alineaci\u00f3n de la memoria. Vamos a ver como se comporta con un ejemplo:\n#include <iostream>\n\nusing namespace std;\n\nstatic void print (size_t sz, size_t sz_flag, size_t sz_timeout)\n{\n    cout << \" flag: \" << sz_flag << \" Bytes\"<< endl;\n    cout << \" +\" << endl;\n    cout << \" timeout: \" << sz_timeout << \"Bytes\" << endl;\n    cout << \" =\" << endl;\n    cout << \" \" << sz_timeout + sz_flag << \"Bytes\" << endl;\n    cout << \" sizeof struct:  \" << sz << \" Bytes\" << endl;\n}\n\n#pragma pack (1)\nstruct SampleStructPack1\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (2)\nstruct SampleStructPack2\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (4)\nstruct SampleStructPack4\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\n\n\nint main(int argc, char *argv[])\n{\n\n    cout << \"SampleStructPack1\" << endl;\n    print (sizeof(SampleStructPack1), sizeof(SampleStructPack1::flag), sizeof(SampleStructPack1::timeout));\n    cout << \" -- \" << endl;\n\n    cout << \"SampleStructPack2\" << endl;\n    print (sizeof(SampleStructPack2), sizeof(SampleStructPack2::flag), sizeof(SampleStructPack2::timeout));\n\n    cout << \"SampleStructPack4\" << endl;\n    print (sizeof(SampleStructPack4), sizeof(SampleStructPack4::flag), sizeof(SampleStructPack4::timeout));\n\n    cout << \"SampleStruct\" << endl;\n    print (sizeof(SampleStruct), sizeof(SampleStruct::flag), sizeof(SampleStruct::timeout));\n    cout << \" -- \" << endl;\n\n    return 0;\n}\nEjecutando el c\u00f3digo de con las directivas pragma, tenemos distintos resultados dependiendo del valor de pragma.\nSampleStructPack1\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  5 Bytes\n --\n\nSampleStructPack2\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  6 Bytes\n\nSampleStructPack4\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes\n\nSampleStruct\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes\n --\nVeamos caso por caso:\nSampleStructPack1 #pragma pack (1)\nReserva bloques de memoria de un byte, nuestra estructura se ha ajustado perfectamente; en este caso s\u00ed que 4 + 1 = 5.\nSampleStructPack2 #pragma pack (2)\nAhora el m\u00ednimo tama\u00f1o del bloque de memoria es de 2 bytes. Para el entero, hay un ajuste exacto porque necesita 2 bloques que 2 bytes para alojar sus 4 bytes.\nPara el caso del booleano, necesita un bloque de 1 byte, pero como m\u00ednimo tiene que asignar un bloque de 2 bytes, por eso en total reserva 6 bytes, 4 + 2 = 6.\nSampleStructPack4 #pragma pack (4)\nEs el mismo caso que el anterior, aunque  en el caso del booleano, hay un mayor \"desperdicio\" de memoria. Necesita 1 byte, pero reserva 4 bytes que es tama\u00f1o m\u00ednimo de bloque de memoria que puede asignar el compilador.\nSampleStruct (alineaci\u00f3n por defecto del compilador)\nComo vemos se comporta exactamente igual que #pragma pack (4), podemos deducir que la alineaci\u00f3n por defecto del compilador que estamos utilizando es de 4 bytes.\n\nImportant\n\u00bfPor qu\u00e9 no utilizamos siempre la alineaci\u00f3n de memoria m\u00e1s ajustada (#pragma pack (1)) para aprovechar mejor la memoria?\n\nWarning\nPorque perderemos rendimiento.\n\n\n\n\nRendimiento\nVamos a hacer una prueba simple de rendimiento, en la que se va a reservar el mismo n\u00famero de elementos en arrays para cada tipo de estructura.\nEste es el resultado:\nSampleStructPack1: 500000000000000000 bytes allocated in 94311 nanoseconds\nSampleStructPack2: 600000000000000000 bytes allocated in 1777 nanoseconds\nSampleStructPack4: 800000000000000000 bytes allocated in 1519 nanoseconds\nComo vemos cuanto m\u00e1s ajustada es la alineaci\u00f3n de memoria, m\u00e1s tiempo se tarda en reservar y liberar. Puedes ejecutar la prueba de rendimiento en este enlace.\nA continuaci\u00f3n pego el c\u00f3digo de la prueba de rendimiento.\n#include <iostream>\n#include <chrono>\n\n#pragma pack (1)\nstruct SampleStructPack1\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (2)\nstruct SampleStructPack2\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (4)\nstruct SampleStructPack4\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\n\nstatic const long MAX_ELEMENTS = 100000000000000000;\nusing namespace std;\nusing namespace std::chrono;\n\nvoid allocate1()\n{\n    SampleStructPack1 elements [MAX_ELEMENTS];\n    cout << \"SampleStructPack1: \" << sizeof(elements) << \" bytes allocated\";\n}\n\nvoid allocate2()\n{\n    SampleStructPack2 elements [MAX_ELEMENTS];\n    cout << \"SampleStructPack2: \" << sizeof(elements) << \" bytes allocated\";\n}\n\nvoid allocate4()\n{\n    SampleStructPack4 elements [MAX_ELEMENTS];\n    cout << \"SampleStructPack4: \" << sizeof(elements) << \" bytes allocated\";\n}\n\nvoid chrono1()\n{\n    auto begin = high_resolution_clock::now() ;\n    allocate1();\n    cout << \" in \" << duration_cast<nanoseconds>(high_resolution_clock::now() - begin).count() << \" nanoseconds\" << endl;\n}\n\nvoid chrono2()\n{\n    auto begin = high_resolution_clock::now() ;\n    allocate2();\n    cout << \" in \" << duration_cast<nanoseconds>(high_resolution_clock::now() - begin).count() << \" nanoseconds\" << endl;\n}\n\nvoid chrono4()\n{\n    auto begin = high_resolution_clock::now() ;\n    allocate4();\n    cout << \" in \" << duration_cast<nanoseconds>(high_resolution_clock::now() - begin).count() << \" nanoseconds\" << endl;\n}\n\n\nint main(int argc, char *argv[])\n{\n    chrono1();\n    chrono2();\n    chrono4();\n\n    return 0;\n}", 
      "tags": "C++", 
      "loc": "/posts/cpp-pragma-pack.html", 
      "title": "Mapeo de un struct C++ en Memoria"
    }, 
    {
      "text": "Es muy tedioso trabajar desde una red con proxy, al menos para m\u00ed, pierdo un mont\u00f3n de tiempo configurando software para que se actualice y funcione correctamente.\nEsta es una descripci\u00f3n m\u00e1s o menos gen\u00e9rica de como hacer que git utilice un proxy determinado:\n#para http\ngit config --global http.proxy <protocolo>://<nombre de usuario>:<password>@<direccion_ip>:<puerto>\n\n#para https\ngit config --global https.proxy <protocolo>://<nombre de usuario>:<password>@<direccion_ip>:<puerto>\n\n#para deshabilitar el uso del proxy\ngit config --global --unset http.proxy\nprotocolo\nSuele ser http o htpps\nnombre de usuario\nnombre de usuario para autenticarse en el servidor de proxy\npassword\npassword para identificarse en el servidor proxy\ndireccion_ip\ndirecci\u00f3n de servidor de proxy\npuerto\nen el que est\u00e1 escuchando el servidor proxy\nM\u00e1s informaci\u00f3n en la configuraci\u00f3n oficial de Git.", 
      "tags": "Git,Proxy,Tips and Tricks", 
      "loc": "/posts/git-proxy-config.html", 
      "title": "Configuraci\u00f3n de proxy para Git"
    }, 
    {
      "text": "A continuaci\u00f3n muestro una forma de eliminar los signos de puntuaci\u00f3n de una cadena de caract\u00e9res en Python. Los signos de puntuaci\u00f3n son reemplazados por caract\u00e9res en blanco.\nimport re, string\n\ndef remove_punctuation ( text ):\n    return re.sub('[%s]' % re.escape(string.punctuation), ' ', text)\nEjecutando:\n>>> remove_punctuation (\"El perro, de San Roque, no tiene rabo; ni nunca lo ha tenido.\")\n'El perro  de San Roque  no tiene rabo  ni nunca lo ha tenido '\nSi queremos hacer la funci\u00f3n m\u00e1s general, para reemplazar los signos de puntuaci\u00f3n por cualquier otra cadena, simplemente hay que hacer la siguiente modificaci\u00f3n en la funci\u00f3n.\nimport re, string\n\ndef replace_punctuation ( text, replace ):\n  return re.sub('[%s]' % re.escape(string.punctuation), replace, text)\nEjecutando el c\u00f3digo de arriba:\n>>> replace_punctuation (\"El perro, de San Roque, no tiene rabo; ni nunca lo ha tenido.\", '[stop]')\n'El perro[stop] de San Roque[stop] no tiene rabo[stop] ni nunca lo ha tenido[stop]'", 
      "tags": "Python,Tips and Tricks", 
      "loc": "/posts/remove-replace-punctuation-py.html", 
      "title": "Eliminar/Reemplazar signos de puntuaci\u00f3n en Python"
    }, 
    {
      "text": "En muchos idiomas, como es el caso del espa\u00f1ol, hay caracteres que no tienen representaci\u00f3n ASCII, como por ejemplo la \u00e1 (que s\u00ed que tiene representaci\u00f3n en Unicode).\nPara evitar problemas o por simplificar, se ha dado una equivalencia entre los caracteres Unicode y los ASCII.\nA continuaci\u00f3n os pondr\u00e9 un trozo de c\u00f3digo en Python que hace esta conversi\u00f3n.\n# -*- coding: utf-8 -*-\nfrom unicodedata import normalize\n\ndef normalize_text ( text ):\n  return normalize('NFKD', text).encode('ASCII', 'ignore')\nEjecutando el ejemplo:\n>>> normalize_text ( 'a\u00e1a\u00e1 e\u00e9e\u00e9 i\u00edi\u00ed o\u00f3o\u00f3 \u00f1n\u00f1n A\u00c0A\u00c0' )\nb'aaaa eeee iiii oooo nnnn AAAA'", 
      "tags": "Python,Tips and Tricks", 
      "loc": "/posts/normalize-text-py.html", 
      "title": "Normalizar texto en Python"
    }, 
    {
      "text": "No se c\u00f3mo no conoc\u00eda este sitio, con la cabeza que tengo y lo bien que me habr\u00eda venido. Se trata de cheat-sheets.org, agrupa tarjetas, gu\u00edas de referencia r\u00e1pidas, chuletas, etc. de much\u00edsimos lenguajes de programaci\u00f3n y software.", 
      "tags": "Cheat Sheet,Tips and Tricks", 
      "loc": "/posts/cheat-sheets-for-developers.html", 
      "title": "Chuletas para desarrolladores"
    }, 
    {
      "text": "Cuando instalamos un paquete en las distribuciones Linux (en las que yo conozco), se instalan otros paquetes (dependencias).\nSi en el futuro desinstalas ese paquete, esas dependencias quedar\u00e1n instaladas en el sistema, aunque no ser\u00e1n usadas por nadie, simplemente ocupar\u00e1n espacio en disco. Estas dependencias son llamadas paquetes hu\u00e9rfanos.\n\nDesinstalar paquetes hu\u00e9rfanos\nArchlinux\nDebian\n\n\n\nArchlinux\nCuando instalamos un paquete en Archlinux pacman -S nombre_paquete se nos descargan autom\u00e1ticamente las dependencias de este paquete. Esto resulta muy c\u00f3mo, pero cuando eliminamos el paquete que instalamos con pacman -R nombre_paquete, se nos quedan instaladas las dependencias de \u00e9ste. Para evitar \u00e9sto, podemos desinstalar los paquetes con pacman -Rscn nombre_paquete, pero si preferimos desinstalar normalmente solo con la opci\u00f3n -R, despu\u00e9s podemos eliminar todos los paquetes hu\u00e9rfanos de la siguiente forma:\npacman -Rsn $(pacman -Qdtq)\nEl funcionamiento es muy sencillo:\nla sentencia pacman -Qdt da un listado de todos los paquetes hu\u00e9rfanos\npacman -Rsn elimina los paquetes listados\n\n\nDebian\nEn distribuciones basadas en Debian, pasa lo mismo que en Archlinux (bueno para ser justos en Archlinux pasa lo mismo que en Debian, un respeto a la edad). Para eliminar estos paquetes, que solamente est\u00e1n ocupando espacio en disco, simplemente hay que ejecutar el siguiente comando.\napt-get remove --purge $(deborphan)", 
      "tags": "Archlinux,Debian,Linux,Tips and Tricks", 
      "loc": "/posts/linux-remove-orphaned-files.html", 
      "title": "Eliminar paquetes hu\u00e9rfanos en Linux"
    }, 
    {
      "text": "Python\nFunci\u00f3n encargada de eliminar las etiquetas HTML:\n#main.py\n\nimport re\n\ndef strip_tags(value):\nreturn re.sub(r'<[>]*?>', '', value)\nSuponiendo que tenemos el siguiente HTML\n<!DOCTYPE HTML>\n<html>\n        <head>\n                <title>Title</title>\n        </head>\n        <body>\n                <p>Paragraph</p>\n        </body>\n</html>\nVamos a hacer una prueba pasandolo como par\u00e1metro de la funci\u00f3n strip_tags:\n#main.py\n\nhtml_text = \"\"\"\n        <!DOCTYPE HTML>\n        <html>\n                <head>\n                        <title>Title</title>\n                </head>\n                <body>\n                        <p>Paragraph</p>\n                </body>\n        </html>\"\"\"\n\nprint strip_tags(html_text)\nSi ejecutamos el script tenemos como resultado:\nTitle\n\nParagraph\nY si con Python ha sido f\u00e1cil, vamos a ver con Django\n\n\nDjango\n#main.py\n\nfrom django.utils.html import strip_tags\n\nhtml_text = \"\"\"\n        <!DOCTYPE HTML>\n        <html>\n                <head>\n                        <title>Title</title>\n                </head>\n                <body>\n                        <p>Paragraph</p>\n                </body>\n        </html>\"\"\"\n\nprint strip_tags( html_text )\nMucho m\u00e1s sencillo, porque la funci\u00f3n ya est\u00e1 escrita.", 
      "tags": "Django,HTML,Python", 
      "loc": "/posts/delete-html-tags-py-django.html", 
      "title": "Eliminar etiquetas HTML"
    }
  ]
}