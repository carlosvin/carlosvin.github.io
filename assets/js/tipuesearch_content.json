{
  "pages": [
    {
      "text": "He encontrado por ah\u00ed un grupo tecnol\u00f3gico-art\u00edstico llamados AlgoRythmics, que ense\u00f1an c\u00f3mo funcionan los algoritmos de ordenaci\u00f3n m\u00e1s conocidos.\nSiempre puedes consultar en la wikipedia \u00c0lgoritmos de ordenamiento, aunque no creo que sea tan r\u00e1pido ni tan divertido como con AlgoRythmics, os dejo el ejemplo del Quicksort.", 
      "tags": "Algorithm,Programming,Sorting", 
      "loc": "/en/posts/sorting-algorithm-dancing.html", 
      "title": "C\u00f3mo funcionan los algoritmos de ordenaci\u00f3n (Bailando)"
    }, 
    {
      "text": "Bases de datos embebidas\nSe trata de bases de datos que carecen de servidor, est\u00e1n inscrustadas en la propia aplicaci\u00f3n y suelen estar almacenadas en ficheros locales. Esto \u00faltimo unido a que suelen tener un modo de funcionamiento en el que mantienen los datos en memoria hace que puedan tener un rendimiento muy alto.\nEso s\u00ed, este gran grado acoplamiento a la aplicaci\u00f3n, hace que tengan peor rendimiento cuando se comparten entre varias aplicaciones debido a colisiones de acceso.\nOtra ventaja es que no tenemos que encargarnos de mantener y gestionar un servidor de bases de datos.\nVoy a hacer una comparativa de rendimiento entre 3 bases de datos embebidas ACID (transaccionales), las NoSQL no entran en esta comparativa que est\u00e1n en otra liga de rendimiento.\n\nContenidos\nBases de datos embebidasSQLite\nDerby o JavaDB\nObjectDB\n\nLos TestsInterfaz DB\nLas Bases de Datos JDBC\nEl c\u00f3digo fuente\nResultados de los tests\n\n\n\n\nSQLite\nSe trata de una librer\u00eda escrita en ANSI C, de menos de 500KB, multi-plataforma, sin dependencias externas, almacena todo el contenido de la base de datos en un solo fichero.\nEs la que da mejor rendimiento en los Resultados de los tests.\nSe puede utilizar desde C y C++, pero tambi\u00e9n desde otros lenguajes de programaci\u00f3n  (PHP, Python, Java, .NET ...).\nEn el caso de Java podemos gestionar esta base de datos a trav\u00e9s de JDBC. Podemos obtener la librer\u00eda de https://bitbucket.org/xerial/sqlite-jdbc.\nVeamos un ejemplo de la inserci\u00f3n de una serie de objetos de la clase Price.\n\npublic class JdbcDb implements DB {\n\n        enum Column {\n                INSTRUMENT,\n                MARKET,\n                PRICE,\n                DATE;\n        }\n\n        public static final String TABLE_NAME = \"PRICES\";\n        public static final String SQL_INSERT = \"INSERT INTO \" + TABLE_NAME\n                        + \" (INSTRUMENT, MARKET, PRICE, DATE) VALUES (?,?,?,?)\";\n\n        // ...\n\n        private void insert(Price p, PreparedStatement preparedStatement) throws SQLException {\n                preparedStatement.setString(1, p.getInstrument());\n                preparedStatement.setString(2, p.getMarket());\n                preparedStatement.setDouble(3, p.getPrice());\n                preparedStatement.setTimestamp(4, new Timestamp(p.getDate().getTime()));\n                preparedStatement.addBatch();\n        }\n\n        @Override\n        public void insert(Price... prices) throws SQLException {\n                PreparedStatement preparedStatement = conn.prepareStatement(SQL_INSERT);\n                for (Price p : prices) {\n                        insert(p, preparedStatement);\n                }\n                preparedStatement.executeBatch();\n                preparedStatement.close();\n                conn.commit();\n        }\n\n        // ...\n}\n\n\n\nDerby o JavaDB\nJavaDB es una distribuci\u00f3n de Oracle de la base de datos de c\u00f3digo libre Derby. Soporta el est\u00e1ndar ANSI/ISO SQL  a trav\u00e9s de JDBC y Java EE. Estas librer\u00edas est\u00e1n incluidas en el JDK.\nAlmacena la base de datos en multiples archivos, lo que puede resultar \u00fatil para escalar el almacenamiento.\nSolo podemos utilizarlo en Java, no desde otros lenguajes.\nComo veremos m\u00e1s adelante ha sido la m\u00e1s lenta en los Resultados de los tests.\nLa implementaci\u00f3n de ejemplo de una inserci\u00f3n de una serie de objetos de la clase Price, es exactamente la misma que la que hemos hecho m\u00e1s arriba en SQLite, esto es una de las bondades de JDBC, que nos permite obtener una conexi\u00f3n para una base de datos espec\u00edfica, pero a partir de ah\u00ed casi siempre nos podemos olvidar de la base de datos con la que trabajamos, siempre y cuando soporte nuestras consultas SQL.\n\n\nObjectDB\nEs una base de datos orientada a objetos que nos permite acceso JPA, un est\u00e1ndar de Java que persigue no perder las ventajas de la orientaci\u00f3n a objetos; esto se suele perder cuando nos acercamos a la capa de persistencia.\nResulta realmente sencillo realizar acciones t\u00edpicas de una base de datos, abstray\u00e9ndonos del SQL, por ejemplo veamos c\u00f3mo quedar\u00eda una inserci\u00f3n de un array de objetos de la clase Price con ObjectDB.\n\npublic void insert(Price... prices) throws SQLException {\n        em.getTransaction().begin();\n        for (Price p : prices) {\n                em.persist(p);\n        }\n        em.getTransaction().commit();\n}\n\nSi a esta facilidad de uso, le unimos que los Resultados de los tests de rendimiento han sido muy buenos (cerca de SQLite), puedo decir que he descubierto una base de datos embebida a tener muy en cuenta en futuros proyectos Java, eso s\u00ed, al igual que con JavaDB, solo nos sirve si vamos a programar en Java.\n\n\n\nLos Tests\nSimplemente consisten en realizar repetidamente una serie operaciones CRUD. Para cada base de datos, el test realiza una serie de inserciones, selects, actualizaciones y borrado de objetos de la clase Precio.\nHe utilizado 100000 instancias de la clase Price, las mismas para cada tipo de base de datos.\nPara esto he creado una interfaz DB que compartir\u00e1n cada una de las implementaciones para cada base de datos.\n\nInterfaz DB\n\n\npublic interface DB {\n\n        public void insert(Price... prices) throws SQLException;\n\n        public void createTable();\n\n        public void deleteAll();\n\n        public void update(Price... prices) throws SQLException;\n\n        public Set<Price> selectAll();\n\n}\n\n\n\n\nLas Bases de Datos JDBC\nSolo cambian los datos necesarios para obtener el driver y la conexi\u00f3n a la base de datos,  por eso toda la l\u00f3gica est\u00e1 en la clase JdbcDb de la que heredan SqliteDb y DerbyDB.\n\n\nEl c\u00f3digo fuente\nPod\u00e9is descargar el c\u00f3digo fuente de https://github.com/carlosvin/java_embedded_databases.\nSe trata de un proyecto Gradle por lo que para ejecutar los tests solo ten\u00e9is que escribir (y tener instalado Gradle claro):\n\n\ngrade test\n\n\nGradle se descargar\u00e1 autom\u00e1ticamente las librer\u00edas necesarias, compilar\u00e1 y ejecutar\u00e1 los tests.\nTambi\u00e9n pod\u00e9is ver directamente la ejecuci\u00f3n en https://travis-ci.org/carlosvin/java_embedded_databases.\nhttps://travis-ci.org/carlosvin/java_embedded_databases.svg\n\n\nResultados de los tests\nA continuaci\u00f3n pod\u00e9is ver un con los resultados de los tests.\n\nAbrir el gr\u00e1fico interactivo | Abrir imagen", 
      "tags": "Java,database,embedded", 
      "loc": "/en/posts/java-embedded-db-performance-comparison.html", 
      "title": "Bases de Datos Embebidas Java: Performance comparison"
    }, 
    {
      "text": "Recently I've  had to serialize/deserialize some data in Java binary format. Lately I use JSON or XML formats.\nI remember that to serialize Java objects they must implement the  Serializable interface, but I had also read in Internet other way, implementing the Externalizable interface, then, which interface must I implement? It depends on what you want such as everything in the life.\n\nWhen to use Serializable or Externalizable\nSerializable\nExternalizable\nPerformance tests (Serializable vs. Externalizable)Implementing Serializable\nImplementing Externalizable (wrong way)\nImplementing Externalizable (right way)\nResult Analysis\n\n\n\n\nSerializable\nTo serialize easily. You have to write less code.\nThis way has some restrictions: The object to serialize must implement the default constructor (0 args). It must be responsible to manage the parent class attributes.\nThe performance is not as important, we will see more about that in Performance tests (Serializable vs. Externalizable).\n\n\nExternalizable\nYou must implement the serialization/deserialization methods, so you have to write more code.\nWhen you cannot use Serializable.\nWhen you want to improve the performance, as we'll see in Performance tests (Serializable vs. Externalizable)\nIf you have to manage the serialization of parent class attributes, then I recommend you use Externalizable, because we'll avoid a weird overriding of private methods.\n\nprivate void writeObject(ObjectOutputStream oos)\nprivate void readObject(ObjectInputStream ois)\n\n\n\nPerformance tests (Serializable vs. Externalizable)\nSerializable: Java, through introspection, guesses the types of class attributes to know how to serialize/deserialize them, but this \"magic\" is not free, it has a performance penalty.\nWhen we use Externalizable interface, we decide how to serialize/deserialize, namely we have to write the code that does it. We've lost ease, but also we avoid that Java does some tasks, so if we override the methods properly, we'll get a performance improvement.\nTo know how much is the performance difference between both interfaces, I've written a tiny example in which we serialize an object with 2 collections with 100000 elements each one, 3 ways:\n\nImplementing Serializable\nAs we told above, Java has to guessed certain things, in this process it sacrifices some of performance (slower way), in exchange for programming simplicity, the class to serialize just has to implement the Serializable interface.\n\npublic class Contacts implements Serializable {\n\nserializing:   1133 millisecond\ndeserializing: 506  millisecond\n\n\nImplementing Externalizable (wrong way)\nIf the class implements Externalizable, we must tell to Java how it has to serialize/deserialize the class attributes. We must be carefully, because if we did it bad, then we'll get the worst of the both worlds: more complex implementation and bad performance, i.e: If we serialize/deserialize complex class attributes (like collections), Java will also have to guess many things about the attributes type.\n\n@Override\npublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n  setEmails((Set<String>) in.readObject());\n  setPhones((Set<String>) in.readObject());\n}\n\n@Override\npublic void writeExternal(ObjectOutput out) throws IOException {\n  out.writeObject(emails);\n  out.writeObject(phones);\n}\n\nserializing:   737 millisecond\ndeserializing: 367  millisecond\n\n\nImplementing Externalizable (right way)\nIf we serialize one by one the collection elements, then we'll save more time, because Java serializes simple types, this way avoids guessing things that we actually know.\n\n@Override\npublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n  emails.clear();\n  phones.clear();\n  int nEmails = in.readInt();\n  for (int i = 0; i < nEmails; i++) {\n    emails.add(in.readUTF());\n  }\n  int nPhones = in.readInt();\n  for (int i = 0; i < nPhones; i++) {\n    phones.add(in.readUTF());\n  }\n}\n\n@Override\npublic void writeExternal(ObjectOutput out) throws IOException {\n  out.writeInt(emails.size());\n  for (String e : emails) {\n    out.writeUTF(e);\n  }\n  out.writeInt(phones.size());\n  for (String p : phones) {\n    out.writeUTF(p);\n  }\n}\n\nserializing:   204 millisecond\ndeserializing: 92  millisecond\nWe've gained performance at expense of write more code.\n\n\nResult Analysis\n\nCaution!\nWe don't gain performance due to use an interface or the other one.\n\n\nTip\nWe gain performance because Externalizable interface forces us to implement ourselves the guessing code, so Java doesn't have to do that.\n\nAlthough as we have watched in Implementing Externalizable (right way), if we wouldn't be careful in implementation, we'll get less performance.\nFollowing you can see a graph with Tests results.\n\nOpen interactive graph | Open image\n\nTests results.\n\nCode in Github.\n\nTravis CI build status", 
      "tags": "Java", 
      "loc": "/en/posts/serialization-java-serializable-externalizable.html", 
      "title": "Java serialization ways: Performance Comparison"
    }, 
    {
      "text": "C++11 has added many improvements to help us developing multi-thread systems. I'm going to talk about mutex.\nIn previous C++11 compiler versions, we can get a pthread mutex, but we must initialize and destroy in C style; in the end you must do more things than just lock/unlock.\nC++11 provides mutex class, we just do lock/unclock. I recommend you take a look at C++11 mutex class.\nIf you still work with previous C++11 compiler versions, a time ago, I made a wrapper class that helps to work with pthread mutex. You just lock/unlock the Mutex object.\nThen I leave my code proposal (Gist code).\n\n\n#include \"Mutex.h\"\n#include <exception>\n\n\nMutex::Mutex()\n{\n    if ( pthread_mutex_init(&_mutex, NULL) )\n    {\n        throw \"Error: Initializing _mutex\";\n    }\n}\n\nMutex::~Mutex()\n{\n\n    pthread_mutex_destroy(&_mutex);\n}\n\nMutex::Mutex(const Mutex & obj)\n{\n\t_mutex = obj._mutex;\n}\n\nMutex & Mutex::operator=(const Mutex & obj)\n{\n\t_mutex = obj._mutex;\n\treturn *this;\n}\n\nbool Mutex::operator==(const Mutex & obj)\n{\n\treturn _mutex == obj._mutex;\n}\n\nbool Mutex::operator!=(const Mutex & obj)\n{\n\treturn !(*this == obj);\n}\n\nvoid Mutex::lock ()\n{\n    pthread_mutex_lock( &_mutex );\n}\n\nvoid Mutex::unlock ()\n{\n    pthread_mutex_unlock( &_mutex );\n}\n\nvoid Mutex::lock ( int lock, Mutex * mtx)\n{\n\tif (lock)\n\t{\n\t\tmtx->lock();\n\t}\n\telse\n\t{\n\t\tmtx->unlock();\n\t}\n}", 
      "tags": "C++,pthread", 
      "loc": "/en/posts/cpp-mutex.html", 
      "title": "Mutex C++"
    }, 
    {
      "text": "I've been listening a A. Jesse Jiryu Davis talk about the library Python's asycnio library.\nAsycnio is a library added to Python 3.4. that provides infrastructure for writing single-threaded concurrent code which let us to save memory.", 
      "tags": "Programming,Python", 
      "loc": "/en/posts/async-what-how-when.html", 
      "title": "Python's asyncio: What, How, When"
    }, 
    {
      "text": "I've seen in Google Science Fair a collection of equations that changed the world.\nIn my opinion, everybody must understand some of these equations.", 
      "tags": "G+,Math,Pysics,Science", 
      "loc": "/en/posts/equations-that-changed-the-word.html", 
      "title": "Equations that changed the world"
    }, 
    {
      "text": "I guess that the most people come from dynamic content management systems based on:\nsend data from browser to server\nprocess the received data, then it stores the processed info into a database (or files)\nthe server generate dynamically an answer that is sent to the browser as HTMLthe answer is usually built reading info from a database or files.\n\nThis process is managed by a software installed on server, this is our content management system.\nNow I've changed the paradigm to \"static web site generator\", specifically I'm going to use Nikola,\nalthough this time, I'm not going to install on a remote server.\nIn a next post I'll tell you how I've automated the publication process using Github [1] and Travis [2].\n\nPath to Nikola\nPhpNuke\nMy Own Content Management SystemDrupal\nWordpress\nCMSdj\nNikola\n\n\n\n\nPhpNuke\nMy first content management system, yes it still exists. It based on PHP+MySQL, multi-lang, user management, user groups, theming, plugins, etc.\n\n\nMy Own Content Management System\nIt wasn't a full [CMS], because actually it was a blogging system. I can publish posts dynamically, it was made with PHP and MySQL. It was useful to:\nPublish posts (with several problems).\nI realized that a developer needs a designer.\nI don't like the PHP syntax.\nI began to understand the importance of [DRY].\n\nDrupal\nA full [CMS], I liked it until the things began to \"break\" (I shared the guilty with Drupal). But Drupal has everything you expect from a [CMS] and more.\n\n\nWordpress\nI don't know if it is better or worse than Drupal, there are many discussions in Internet, but I can tell Wordpress is more usable and easier to update than Drupal.\n\n\nCMSdj\nIt is my second attempt to create my own [CMS]. I had an idea in my mind about how to be the core design (the data model), I still believe in that design. I had also discovered Django, I liked this framework developed in Python, who can resist to create your own [CMS]?\nCMSdj is in Bitbucket and is working, it has its internal search engine, theming, comment system, voting system,HTML5_ + CSS3 views, but:\nI haven't enough time to develop, two hours by week at most.\nI still needed a designer.\nSo, I declared the project CMSdj dead of boredom, although it was supporting my old blog, when I went to write something, I saw my unfinished project, I disliked it, so I decided to close it and begin a new one.\n\n\nNikola\nI was a static website generator because they are trendy.\nI tried Jekyll because it's the most famous, but I prefer one written in Python. So, after a quick search I had three finalists: Nikola, Mynt y Pelican. I chose Nikola  because I discarded the others:\n* Pelican throws some multi-lang problems with the categories. I didn't want to spend time researching about how to fix them.\n* I love the simplicity of Mynt, but you have to create your own themes, I never want to miss a designer.\n[1]Github hosts the generated site, the static files (html, css, images, js).[2]Travis is a continuous integration software (like Jenkins). I use it to automate the site deployment: download the files when they change from Github, re-generate and re-publish the static files.[DRY]Don't Repeat Yourself, \u00b4DRY in wiki\u00b4_[CMS](1, 2, 3, 4, 5) Content Management System", 
      "tags": "Python,Static Sites", 
      "loc": "/en/posts/primer-post.html", 
      "title": "First post with Nikola"
    }, 
    {
      "text": "If you want to use Android Studio without installation, as a portable software, here you have the link to last portable version of Android Studio.", 
      "tags": "Android,Java,Software", 
      "loc": "/en/posts/android-studio-portable-download.html", 
      "title": "Android Studio Portable Download"
    }, 
    {
      "text": "Trabajando con libtool [1], cuando vamos a depurar un ejecutable que utiliza una librer\u00eda generada con libtool, es posible que nos encontremos con el siguiente error:\n\n$ gdb ./tests-mylib\n\"tests-mylib\": not in executable format: File format not recognized\n\nlibmylib.so es una librer\u00eda din\u00e1mica generada con libtool\ntests-mylib es un ejecutable que utiliza la librer\u00eda mylib\nPara los que est\u00e9is pensando que se me ha olvidado poner la opci\u00f3n de compilaci\u00f3n -g, lo siento, pero este error ocurre aunque utilicemos -g.\nEl error es debido a que estamos intentando ejecutar un script generado por libtool, es una envoltura sobre el programa real, para facilitar la ejecuci\u00f3n de \u00e9ste [libtooldoc].\nPara poder depurar nuestro programa de prueba tests-mylib\n\nlibtool --mode=execute gdb tests-mylib\n\n[1]Herramienta que pertenece a la Autotools usada para crear bibliotecas de software portables.[libtooldoc]Esta informaci\u00f3n la he sacado de http://www.gnu.org/software/libtool/manual/libtool.html#Debugging-executables", 
      "tags": "Autotools,C++,GNU,Tips and Tricks", 
      "loc": "/en/posts/debug-libtool-lib.html", 
      "title": "Depurar librer\u00eda generada con libtool"
    }, 
    {
      "text": "Un struct de C++ es un elemento que permite agrupar elementos de tipos distintos con alguna relaci\u00f3n entre ellos. Esto permite manipular todos los elementos en bloque mediante una \u00fanica referencia.\nSi alguna vez nos interesa trabajar a un nivel m\u00e1s bajo, nos puede resultar \u00fatil entender c\u00f3mo se mapea una estructura en memoria y c\u00f3mo controlar este mapeo.\n\nTabla de Contenidos\nEstructura de ejemplo\nLa directiva #pragma pack en struct C++\nRendimiento\n\n\n\nEstructura de ejemplo\nEsta estructura estar\u00e1 compuesta por dos campos, un entero (4 bytes) y un booleano (un byte). En C++ queda de la siguiente forma:\n\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\n\nSi hacemos un sizeof de la una instancia de la estructura deber\u00edamos obtener un tama\u00f1o de 5 bytes. Y la memoria quedar\u00eda de la siguiente forma:\n\nEstructura de 5 bytes que realmente ocupa 5 bytes en memoria.\n\nPero no es tan sencillo, a continuaci\u00f3n veremos que no nos podemos olvidar de la alineaci\u00f3n de la memoria que hace el compilador en ese sistema y veremos c\u00f3mo controlarlo para no encontrarnos con tama\u00f1os inesperados, ya que esto depende del compilador del sistema.\nPor ejemplo, si en mi m\u00e1quina hago un sizeof de la estructura, obtengo un tama\u00f1o de 8 bytes. Lo que est\u00e1 sucediendo es que el compilador reserva m\u00e1s memoria al final de la estructura para que cuadre en bloques de 2n bytes. La memoria queda de la siguiente forma:\n\nEstructura de 5 bytes que realmente ocupa 8 bytes en memoria. Para ser m\u00e1s precisos, deber\u00eda haber dibujado la memoria no usada a continuaci\u00f3n del atributo flag.\n\nVamos a ver un fragmento de c\u00f3digo que imprime el tama\u00f1o de la estructura y el de cada uno de sus atributos y verificar, en este caso 4 + 1 no es 5.\n\n#include  <iostream>\n\nusing namespace std;\n\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\n\nstatic void print (size_t sz, size_t sz_flag, size_t sz_timeout)\n{\n    cout << \"\\tflag: \" << sz_flag << \" Bytes\" << endl;\n    cout << \"\\t+\" << endl;\n    cout << \"\\ttimeout: \" << sz_timeout << \" Bytes\" << endl;\n    cout << \"\\t=\" << endl;\n    cout << \"\\t\" << sz_timeout + sz_flag << \" Bytes\" << endl;\n    cout <<\"sizeof struct:  \" << sz << \" Bytes\" << endl;\n}\n\nint main(int argc, char *argv[])\n{\n    cout << \"SampleStruct\" << endl;\n    print (sizeof(SampleStruct), sizeof(SampleStruct::flag), sizeof(SampleStruct::timeout));\n    cout << \" -- \" << endl;\n\n    return 0;\n}\n\nEjecutando el c\u00f3digo de sin la directiva pragma, tenemos que nuestra estructura ocupa 8 bytes en lugar de 5 bytes.\n\nSampleStruct\nflag: 1 Bytes\n+\ntimeout: 4 Bytes\n=\n5 Bytes\nsizeof struct:  8 Bytes\n--\n\n\nTip\nSi queremos conocer el tama\u00f1o exacto de las estructuras que vamos a utilizar, tenemos que especificar al compilador la forma de alinear la estructura en memoria, para ello utilizaremos la directiva #pragma pack(n).\n\n\n\nLa directiva #pragma pack en struct C++\nSe trata de una directiva del preprocesador que indica al compilador c\u00f3mo debe realizar la alineaci\u00f3n de la memoria. Vamos a ver como se comporta con un ejemplo:\n\n#include <iostream>\n\nusing namespace std;\n\nstatic void print (size_t sz, size_t sz_flag, size_t sz_timeout)\n{\n    cout << \" flag: \" << sz_flag << \" Bytes\"<< endl;\n    cout << \" +\" << endl;\n    cout << \" timeout: \" << sz_timeout << \"Bytes\" << endl;\n    cout << \" =\" << endl;\n    cout << \" \" << sz_timeout + sz_flag << \"Bytes\" << endl;\n    cout << \" sizeof struct:  \" << sz << \" Bytes\" << endl;\n}\n\n#pragma pack (1)\nstruct SampleStructPack1\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (2)\nstruct SampleStructPack2\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (4)\nstruct SampleStructPack4\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\n\n\nint main(int argc, char *argv[])\n{\n\n    cout << \"SampleStructPack1\" << endl;\n    print (sizeof(SampleStructPack1), sizeof(SampleStructPack1::flag), sizeof(SampleStructPack1::timeout));\n    cout << \" -- \" << endl;\n\n    cout << \"SampleStructPack2\" << endl;\n    print (sizeof(SampleStructPack2), sizeof(SampleStructPack2::flag), sizeof(SampleStructPack2::timeout));\n\n    cout << \"SampleStructPack4\" << endl;\n    print (sizeof(SampleStructPack4), sizeof(SampleStructPack4::flag), sizeof(SampleStructPack4::timeout));\n\n    cout << \"SampleStruct\" << endl;\n    print (sizeof(SampleStruct), sizeof(SampleStruct::flag), sizeof(SampleStruct::timeout));\n    cout << \" -- \" << endl;\n\n    return 0;\n}\n\nEjecutando el c\u00f3digo de con las directivas pragma, tenemos distintos resultados dependiendo del valor de pragma.\n\nSampleStructPack1\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  5 Bytes\n --\n\nSampleStructPack2\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  6 Bytes\n\nSampleStructPack4\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes\n\nSampleStruct\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes\n --\n\nVeamos caso por caso:\nSampleStructPack1 #pragma pack (1)\nReserva bloques de memoria de un byte, nuestra estructura se ha ajustado perfectamente; en este caso s\u00ed que 4 + 1 = 5.\nSampleStructPack2 #pragma pack (2)\nAhora el m\u00ednimo tama\u00f1o del bloque de memoria es de 2 bytes. Para el entero, hay un ajuste exacto porque necesita 2 bloques que 2 bytes para alojar sus 4 bytes.\nPara el caso del booleano, necesita un bloque de 1 byte, pero como m\u00ednimo tiene que asignar un bloque de 2 bytes, por eso en total reserva 6 bytes, 4 + 2 = 6.\nSampleStructPack4 #pragma pack (4)\nEs el mismo caso que el anterior, aunque  en el caso del booleano, hay un mayor \"desperdicio\" de memoria. Necesita 1 byte, pero reserva 4 bytes que es tama\u00f1o m\u00ednimo de bloque de memoria que puede asignar el compilador.\nSampleStruct (alineaci\u00f3n por defecto del compilador)\nComo vemos se comporta exactamente igual que #pragma pack (4), podemos deducir que la alineaci\u00f3n por defecto del compilador que estamos utilizando es de 4 bytes.\n\nImportant\n\u00bfPor qu\u00e9 no utilizamos siempre la alineaci\u00f3n de memoria m\u00e1s ajustada (#pragma pack (1)) para aprovechar mejor la memoria?\n\nWarning\nPorque perderemos rendimiento.\n\n\n\n\nRendimiento\nVamos a hacer una prueba simple de rendimiento, en la que se va a reservar el mismo n\u00famero de elementos en arrays para cada tipo de estructura.\nEste es el resultado:\n\nSampleStructPack1: 500000000000000000 bytes allocated in 94311 nanoseconds\nSampleStructPack2: 600000000000000000 bytes allocated in 1777 nanoseconds\nSampleStructPack4: 800000000000000000 bytes allocated in 1519 nanoseconds\n\nComo vemos cuanto m\u00e1s ajustada es la alineaci\u00f3n de memoria, m\u00e1s tiempo se tarda en reservar y liberar. Puedes ejecutar la prueba de rendimiento en este enlace.\nA continuaci\u00f3n pego el c\u00f3digo de la prueba de rendimiento.\n\n#include <iostream>\n#include <chrono>\n\n#pragma pack (1)\nstruct SampleStructPack1\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (2)\nstruct SampleStructPack2\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (4)\nstruct SampleStructPack4\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\n\nstatic const long MAX_ELEMENTS = 100000000000000000;\nusing namespace std;\nusing namespace std::chrono;\n\nvoid allocate1()\n{\n    SampleStructPack1 elements [MAX_ELEMENTS];\n    cout << \"SampleStructPack1: \" << sizeof(elements) << \" bytes allocated\";\n}\n\nvoid allocate2()\n{\n    SampleStructPack2 elements [MAX_ELEMENTS];\n    cout << \"SampleStructPack2: \" << sizeof(elements) << \" bytes allocated\";\n}\n\nvoid allocate4()\n{\n    SampleStructPack4 elements [MAX_ELEMENTS];\n    cout << \"SampleStructPack4: \" << sizeof(elements) << \" bytes allocated\";\n}\n\nvoid chrono1()\n{\n    auto begin = high_resolution_clock::now() ;\n    allocate1();\n    cout << \" in \" << duration_cast<nanoseconds>(high_resolution_clock::now() - begin).count() << \" nanoseconds\" << endl;\n}\n\nvoid chrono2()\n{\n    auto begin = high_resolution_clock::now() ;\n    allocate2();\n    cout << \" in \" << duration_cast<nanoseconds>(high_resolution_clock::now() - begin).count() << \" nanoseconds\" << endl;\n}\n\nvoid chrono4()\n{\n    auto begin = high_resolution_clock::now() ;\n    allocate4();\n    cout << \" in \" << duration_cast<nanoseconds>(high_resolution_clock::now() - begin).count() << \" nanoseconds\" << endl;\n}\n\n\nint main(int argc, char *argv[])\n{\n    chrono1();\n    chrono2();\n    chrono4();\n\n    return 0;\n}", 
      "tags": "C++", 
      "loc": "/en/posts/cpp-pragma-pack.html", 
      "title": "Mapeo de un struct C++ en Memoria"
    }, 
    {
      "text": "Sometimes working through a proxy is pretty tedious.\nWe are going how to configure git to work through a proxy\nA generic description, how to make git uses a specific proxy:\n\n#http\ngit config --global http.proxy <protocol>://<user_name>:<password>@<ip_host>:<port>\n\n#https\ngit config --global https.proxy [protocol]_://[username]_:[password]_@[ip_host]_:[port]_\n\n#to disable using proxy\ngit config --global --unset http.proxy\n\nMore info in official Git configuration.\n[protocol]Use to be http or https[username]The proxy user name[ip_host]Proxy host address[port]Proxy listening port[password]Your proxy password", 
      "tags": "Git,Proxy,Tips and Tricks", 
      "loc": "/en/posts/git-proxy-config.html", 
      "title": "Git proxy configuration"
    }, 
    {
      "text": "A continuaci\u00f3n muestro una forma de eliminar los signos de puntuaci\u00f3n de una cadena de caract\u00e9res en Python. Los signos de puntuaci\u00f3n son reemplazados por caract\u00e9res en blanco.\n\nimport re, string\n\ndef remove_punctuation ( text ):\n    return re.sub('[%s]' % re.escape(string.punctuation), ' ', text)\n\nEjecutando:\n\n>>> remove_punctuation (\"El perro, de San Roque, no tiene rabo; ni nunca lo ha tenido.\")\n'El perro  de San Roque  no tiene rabo  ni nunca lo ha tenido '\n\nSi queremos hacer la funci\u00f3n m\u00e1s general, para reemplazar los signos de puntuaci\u00f3n por cualquier otra cadena, simplemente hay que hacer la siguiente modificaci\u00f3n en la funci\u00f3n.\n\nimport re, string\n\ndef replace_punctuation ( text, replace ):\n  return re.sub('[%s]' % re.escape(string.punctuation), replace, text)\n\nEjecutando el c\u00f3digo de arriba:\n\n>>> replace_punctuation (\"El perro, de San Roque, no tiene rabo; ni nunca lo ha tenido.\", '[stop]')\n'El perro[stop] de San Roque[stop] no tiene rabo[stop] ni nunca lo ha tenido[stop]'", 
      "tags": "Python,Tips and Tricks", 
      "loc": "/en/posts/remove-replace-punctuation-py.html", 
      "title": "Eliminar/Reemplazar signos de puntuaci\u00f3n en Python"
    }, 
    {
      "text": "En muchos idiomas, como es el caso del espa\u00f1ol, hay caracteres que no tienen representaci\u00f3n ASCII, como por ejemplo la \u00e1 (que s\u00ed que tiene representaci\u00f3n en Unicode).\nPara evitar problemas o por simplificar, se ha dado una equivalencia entre los caracteres Unicode y los ASCII.\nA continuaci\u00f3n os pondr\u00e9 un trozo de c\u00f3digo en Python que hace esta conversi\u00f3n.\n\n# -*- coding: utf-8 -*-\nfrom unicodedata import normalize\n\ndef normalize_text ( text ):\n  return normalize('NFKD', text).encode('ASCII', 'ignore')\n\nEjecutando el ejemplo:\n\n>>> normalize_text ( 'a\u00e1a\u00e1 e\u00e9e\u00e9 i\u00edi\u00ed o\u00f3o\u00f3 \u00f1n\u00f1n A\u00c0A\u00c0' )\nb'aaaa eeee iiii oooo nnnn AAAA'", 
      "tags": "Python,Tips and Tricks", 
      "loc": "/en/posts/normalize-text-py.html", 
      "title": "Normalizar texto en Python"
    }, 
    {
      "text": "cheat-sheets.org\n\n\"All cheat sheets, round-ups, quick reference cards, quick reference guides and quick reference sheets in one page. The only one you need.\"", 
      "tags": "Cheat Sheet,Tips and Tricks", 
      "loc": "/en/posts/cheat-sheets-for-developers.html", 
      "title": "Cheat-sheets for developers"
    }, 
    {
      "text": "When we install a package in most of Linux distributions, the package system installs other packages needed by the package that we actually want to install.\nIf we uninstall the package, its dependencies won't be uninstalled, these unused dependencies are called orphaned packages.\n\nRemove orphaned packages\nArchlinux\nDebian\n\n\n\nArchlinux\n\npacman -Rsn $(pacman -Qdtq)\n\nHow does the command work?\npacman -Qdt list all orphaned packages\npacman -Rsn uninstall the listed packages\n\n\nDebian\n\napt-get remove --purge $(deborphan)", 
      "tags": "Archlinux,Debian,Linux,Tips and Tricks", 
      "loc": "/en/posts/linux-remove-orphaned-files.html", 
      "title": "Remove orphaned packages (Linux)"
    }, 
    {
      "text": "Python\nFunci\u00f3n encargada de eliminar las etiquetas HTML:\n\n#main.py\n\nimport re\n\ndef strip_tags(value):\nreturn re.sub(r'<[>]*?>', '', value)\n\nSuponiendo que tenemos el siguiente HTML\n\n<!DOCTYPE HTML>\n<html>\n        <head>\n                <title>Title</title>\n        </head>\n        <body>\n                <p>Paragraph</p>\n        </body>\n</html>\n\nVamos a hacer una prueba pasandolo como par\u00e1metro de la funci\u00f3n strip_tags:\n\n#main.py\n\nhtml_text = \"\"\"\n        <!DOCTYPE HTML>\n        <html>\n                <head>\n                        <title>Title</title>\n                </head>\n                <body>\n                        <p>Paragraph</p>\n                </body>\n        </html>\"\"\"\n\nprint strip_tags(html_text)\n\nSi ejecutamos el script tenemos como resultado:\n\nTitle\n\nParagraph\n\nY si con Python ha sido f\u00e1cil, vamos a ver con Django\n\n\nDjango\n\n#main.py\n\nfrom django.utils.html import strip_tags\n\nhtml_text = \"\"\"\n        <!DOCTYPE HTML>\n        <html>\n                <head>\n                        <title>Title</title>\n                </head>\n                <body>\n                        <p>Paragraph</p>\n                </body>\n        </html>\"\"\"\n\nprint strip_tags( html_text )\n\nMucho m\u00e1s sencillo, porque la funci\u00f3n ya est\u00e1 escrita.", 
      "tags": "Django,HTML,Python", 
      "loc": "/en/posts/delete-html-tags-py-django.html", 
      "title": "Eliminar etiquetas HTML"
    }, 
    {
      "text": "He encontrado por ah\u00ed un grupo tecnol\u00f3gico-art\u00edstico llamados AlgoRythmics, que ense\u00f1an c\u00f3mo funcionan los algoritmos de ordenaci\u00f3n m\u00e1s conocidos.\nSiempre puedes consultar en la wikipedia \u00c0lgoritmos de ordenamiento, aunque no creo que sea tan r\u00e1pido ni tan divertido como con AlgoRythmics, os dejo el ejemplo del Quicksort.", 
      "tags": "Algorithm,Programming,Sorting", 
      "loc": "/posts/sorting-algorithm-dancing.html", 
      "title": "C\u00f3mo funcionan los algoritmos de ordenaci\u00f3n (Bailando)"
    }, 
    {
      "text": "Bases de datos embebidas\nSe trata de bases de datos que carecen de servidor, est\u00e1n inscrustadas en la propia aplicaci\u00f3n y suelen estar almacenadas en ficheros locales. Esto \u00faltimo unido a que suelen tener un modo de funcionamiento en el que mantienen los datos en memoria hace que puedan tener un rendimiento muy alto.\nEso s\u00ed, este gran grado acoplamiento a la aplicaci\u00f3n, hace que tengan peor rendimiento cuando se comparten entre varias aplicaciones debido a colisiones de acceso.\nOtra ventaja es que no tenemos que encargarnos de mantener y gestionar un servidor de bases de datos.\nVoy a hacer una comparativa de rendimiento entre 3 bases de datos embebidas ACID (transaccionales), las NoSQL no entran en esta comparativa que est\u00e1n en otra liga de rendimiento.\n\nContenidos\nBases de datos embebidasSQLite\nDerby o JavaDB\nObjectDB\n\nLos TestsInterfaz DB\nLas Bases de Datos JDBC\nEl c\u00f3digo fuente\nResultados de los tests\n\n\n\n\nSQLite\nSe trata de una librer\u00eda escrita en ANSI C, de menos de 500KB, multi-plataforma, sin dependencias externas, almacena todo el contenido de la base de datos en un solo fichero.\nEs la que da mejor rendimiento en los Resultados de los tests.\nSe puede utilizar desde C y C++, pero tambi\u00e9n desde otros lenguajes de programaci\u00f3n  (PHP, Python, Java, .NET ...).\nEn el caso de Java podemos gestionar esta base de datos a trav\u00e9s de JDBC. Podemos obtener la librer\u00eda de https://bitbucket.org/xerial/sqlite-jdbc.\nVeamos un ejemplo de la inserci\u00f3n de una serie de objetos de la clase Price.\n\npublic class JdbcDb implements DB {\n\n        enum Column {\n                INSTRUMENT,\n                MARKET,\n                PRICE,\n                DATE;\n        }\n\n        public static final String TABLE_NAME = \"PRICES\";\n        public static final String SQL_INSERT = \"INSERT INTO \" + TABLE_NAME\n                        + \" (INSTRUMENT, MARKET, PRICE, DATE) VALUES (?,?,?,?)\";\n\n        // ...\n\n        private void insert(Price p, PreparedStatement preparedStatement) throws SQLException {\n                preparedStatement.setString(1, p.getInstrument());\n                preparedStatement.setString(2, p.getMarket());\n                preparedStatement.setDouble(3, p.getPrice());\n                preparedStatement.setTimestamp(4, new Timestamp(p.getDate().getTime()));\n                preparedStatement.addBatch();\n        }\n\n        @Override\n        public void insert(Price... prices) throws SQLException {\n                PreparedStatement preparedStatement = conn.prepareStatement(SQL_INSERT);\n                for (Price p : prices) {\n                        insert(p, preparedStatement);\n                }\n                preparedStatement.executeBatch();\n                preparedStatement.close();\n                conn.commit();\n        }\n\n        // ...\n}\n\n\n\nDerby o JavaDB\nJavaDB es una distribuci\u00f3n de Oracle de la base de datos de c\u00f3digo libre Derby. Soporta el est\u00e1ndar ANSI/ISO SQL  a trav\u00e9s de JDBC y Java EE. Estas librer\u00edas est\u00e1n incluidas en el JDK.\nAlmacena la base de datos en multiples archivos, lo que puede resultar \u00fatil para escalar el almacenamiento.\nSolo podemos utilizarlo en Java, no desde otros lenguajes.\nComo veremos m\u00e1s adelante ha sido la m\u00e1s lenta en los Resultados de los tests.\nLa implementaci\u00f3n de ejemplo de una inserci\u00f3n de una serie de objetos de la clase Price, es exactamente la misma que la que hemos hecho m\u00e1s arriba en SQLite, esto es una de las bondades de JDBC, que nos permite obtener una conexi\u00f3n para una base de datos espec\u00edfica, pero a partir de ah\u00ed casi siempre nos podemos olvidar de la base de datos con la que trabajamos, siempre y cuando soporte nuestras consultas SQL.\n\n\nObjectDB\nEs una base de datos orientada a objetos que nos permite acceso JPA, un est\u00e1ndar de Java que persigue no perder las ventajas de la orientaci\u00f3n a objetos; esto se suele perder cuando nos acercamos a la capa de persistencia.\nResulta realmente sencillo realizar acciones t\u00edpicas de una base de datos, abstray\u00e9ndonos del SQL, por ejemplo veamos c\u00f3mo quedar\u00eda una inserci\u00f3n de un array de objetos de la clase Price con ObjectDB.\n\npublic void insert(Price... prices) throws SQLException {\n        em.getTransaction().begin();\n        for (Price p : prices) {\n                em.persist(p);\n        }\n        em.getTransaction().commit();\n}\n\nSi a esta facilidad de uso, le unimos que los Resultados de los tests de rendimiento han sido muy buenos (cerca de SQLite), puedo decir que he descubierto una base de datos embebida a tener muy en cuenta en futuros proyectos Java, eso s\u00ed, al igual que con JavaDB, solo nos sirve si vamos a programar en Java.\n\n\n\nLos Tests\nSimplemente consisten en realizar repetidamente una serie operaciones CRUD. Para cada base de datos, el test realiza una serie de inserciones, selects, actualizaciones y borrado de objetos de la clase Precio.\nHe utilizado 100000 instancias de la clase Price, las mismas para cada tipo de base de datos.\nPara esto he creado una interfaz DB que compartir\u00e1n cada una de las implementaciones para cada base de datos.\n\nInterfaz DB\n\n\npublic interface DB {\n\n        public void insert(Price... prices) throws SQLException;\n\n        public void createTable();\n\n        public void deleteAll();\n\n        public void update(Price... prices) throws SQLException;\n\n        public Set<Price> selectAll();\n\n}\n\n\n\n\nLas Bases de Datos JDBC\nSolo cambian los datos necesarios para obtener el driver y la conexi\u00f3n a la base de datos,  por eso toda la l\u00f3gica est\u00e1 en la clase JdbcDb de la que heredan SqliteDb y DerbyDB.\n\n\nEl c\u00f3digo fuente\nPod\u00e9is descargar el c\u00f3digo fuente de https://github.com/carlosvin/java_embedded_databases.\nSe trata de un proyecto Gradle por lo que para ejecutar los tests solo ten\u00e9is que escribir (y tener instalado Gradle claro):\n\n\ngrade test\n\n\nGradle se descargar\u00e1 autom\u00e1ticamente las librer\u00edas necesarias, compilar\u00e1 y ejecutar\u00e1 los tests.\nTambi\u00e9n pod\u00e9is ver directamente la ejecuci\u00f3n en https://travis-ci.org/carlosvin/java_embedded_databases.\nhttps://travis-ci.org/carlosvin/java_embedded_databases.svg\n\n\nResultados de los tests\nA continuaci\u00f3n pod\u00e9is ver un con los resultados de los tests.\n\nAbrir el gr\u00e1fico interactivo | Abrir imagen", 
      "tags": "Java,database,embedded", 
      "loc": "/posts/java-embedded-db-performance-comparison.html", 
      "title": "Bases de Datos Embebidas Java: Performance comparison"
    }, 
    {
      "text": "Hace poco, he tenido que serializar/deserializar unos datos en Java, hac\u00eda mucho que no lo hac\u00eda en formato binario directamente (ultimamente he utilizado JSON o XML). Recordaba haber serializado objetos implementando el interfaz Serializable, pero hab\u00eda visto por Internet otra forma implementando el interfaz Externalizable, \u00bfcu\u00e1l interfaz utilizo? Pues depende lo que quieras y necesites, como todo.\n\nCu\u00e1ndo utilizar Serializable o Externalizable\nSerializable\nExternalizable\nPruebas de Rendimiento (Serializable vs Externalizable)Utilizando el interfaz Serializable\nUtilizando el interfaz Externalizable (mal)\nUtilizando el interfaz Externalizable (bien)\nAnalizando los resultados\n\n\n\n\nSerializable\nCuando quieras serializar algo programando poco, es la forma f\u00e1cil.\nPero tiene algunas restricciones: El objeto a serializar debe implementar el constructor por defecto. Debe hacerse responsable de los atributos no accesibles de la clase padre.\nCuando no te importe mucho el rendimiento, como veremos en la secci\u00f3n Pruebas de Rendimiento (Serializable vs Externalizable).\n\n\nExternalizable\nVas a tener que implementar t\u00fa mismo los m\u00e9todos de serializaci\u00f3n.\nCuando no puedas utilizar Serializable.\nCuando quieras obtener un mejor rendimiento, como veremos en la secci\u00f3n Pruebas de Rendimiento (Serializable vs Externalizable)\nSi tienes que encargarte de la serializaci\u00f3n de los atributos de la clase padre, te recomiendo utilizar Externalizable, porque evitamos una sobrescritura extra\u00f1a de m\u00e9todos privados.\n\nprivate void writeObject(ObjectOutputStream oos)\nprivate void readObject(ObjectInputStream ois)\n\n\n\nPruebas de Rendimiento (Serializable vs Externalizable)\nEl interfaz Serializable utilizando la introspecci\u00f3n de Java, adivina los tipos de los atributos de las clases que va a serializar/deserializar, pero esta \"magia\" tiene una penalizaci\u00f3n en el rendimiento.\nAl utilizar el interfaz Externalizable somos nosotros los que decidimos como serializar/deserializar los objetos, es decir, tenemos que escribir nosotros el c\u00f3digo que hace esto. Hemos perdido comodidad, pero evitamos que Java haga algunas tareas y, si sobrescribimos correctamente los m\u00e9todos del interfaz Externalizable, conseguiremos una mejora de rendimiento.\nPara saber cu\u00e1nto es la diferencia de rendimiento, he escrito un peque\u00f1o ejemplo en el que se serializa un objeto con dos colecciones con 100000 emails y 100000 tel\u00e9fonos. He contemplado 3 casos:\n\nUtilizando el interfaz Serializable\nComo dijimos m\u00e1s arriba, utilizando el interfaz Serializable Java tiene que adivinar ciertas cosas, en este proceso sacrifica algo de rendimiento (es el que m\u00e1s tarda), a cambio \u013ao \u00fanico que tenemos que hacer es que nuestra clase implemente el interfaz Serializable.\n\npublic class Contacts implements Serializable {\n\n1133 milisegundos en serializar\n506  milisegundos en deserializar\n\n\nUtilizando el interfaz Externalizable (mal)\nEn este caso somos nosotros los encargados de \"decir\" a Java c\u00f3mo debe serializar/deserializar, pero debemos ser cuidadosos, de lo contrario podemos quedarnos con lo peor de los dos mundos, por ejemplo: Si simplemente serializamos/deserializamos los atributos de la clase, y estos son atributos complejos (como colecciones), Java tambi\u00e9n tiene que adivinar bastantes cosas y tambi\u00e9n sacrificamos algo de rendimiento y adem\u00e1s hemos tenido que escribir m\u00e1s c\u00f3digo.\n\n@Override\npublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n  setEmails((Set<String>) in.readObject());\n  setPhones((Set<String>) in.readObject());\n}\n\n@Override\npublic void writeExternal(ObjectOutput out) throws IOException {\n  out.writeObject(emails);\n  out.writeObject(phones);\n}\n\n737 milisegundos en serializar\n367 milisegundos en deserializar\n\n\nUtilizando el interfaz Externalizable (bien)\nSi serializamos/deserializamos uno por uno los elementos de las colecciones, ahorramos a\u00fan m\u00e1s tiempo, porque Java est\u00e1 serializando tipos m\u00e1s simples (en este caso java.lang.String).\n\n@Override\npublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n  emails.clear();\n  phones.clear();\n  int nEmails = in.readInt();\n  for (int i = 0; i < nEmails; i++) {\n    emails.add(in.readUTF());\n  }\n  int nPhones = in.readInt();\n  for (int i = 0; i < nPhones; i++) {\n    phones.add(in.readUTF());\n  }\n}\n\n@Override\npublic void writeExternal(ObjectOutput out) throws IOException {\n  out.writeInt(emails.size());\n  for (String e : emails) {\n    out.writeUTF(e);\n  }\n  out.writeInt(phones.size());\n  for (String p : phones) {\n    out.writeUTF(p);\n  }\n}\n\n204 milisegundos en serializar\n92  milisegundos en deserializar\nHemos ganado rendimiento a costa de escribir un poco m\u00e1s de c\u00f3digo.\n\n\nAnalizando los resultados\n\nCaution!\nPor el hecho de utilizar un interfaz u otro, no ganamos rendimiento.\n\n\nTip\nGanamos rendimiento porque el interfaz Externalizable nos \"obliga\" a implementar parte de la serializaci\u00f3n y quitamos esta carga a Java.\n\nAunque como hemos visto en Utilizando el interfaz Externalizable (bien), si no tenemos cuidado, conseguiremos una mejora muy peque\u00f1a.\nA continuaci\u00f3n pod\u00e9is ver un gr\u00e1fico con los resultados de los tests.\n\nAbrir el gr\u00e1fico interactivo | Abrir imagen\n\nA continuaci\u00f3n os dejo los enlaces a:\nResultados de los tests.\n\nC\u00f3digo en github.\n\nEstado de la Construcci\u00f3n en travis", 
      "tags": "Java", 
      "loc": "/posts/serialization-java-serializable-externalizable.html", 
      "title": "Distintas formas de serializaci\u00f3n en Java: Comparaci\u00f3n de rendimiento"
    }, 
    {
      "text": "En C++11 se han introducido muchas mejoras que nos ayudan a desarrollar sistemas multi-hilo. Voy a centrarme en los mutex.\nEn las versiones anteriores a C++11 una forma de obtener un mutex es el que nos proporciona la librer\u00eda pthread, pero para utilizarlo deb\u00edabos inicializarlo y destruirlo en estilo C, en definitiva, tienes que hacer algo m\u00e1s que lock/unlock cada vez que trabajas con un mutex.\nC++11 nos proporciona una clase mutex, que nos abstrae de cosas que no son lock/unclock. Os recomiendo que ech\u00e9is un vistazo y ve\u00e1is lo limpio que queda el c\u00f3digo: Clase mutex de C++11.\nSi sigues trabajando con versiones de compiladores previos a C++11, hace tiempo me hice un wrapper que te ayuda a abstraerte del mutex de pthread, lo dejo aqu\u00ed abajo por si a alguien le resulta \u00fatil.\nAbajo est\u00e1 un Gist del C\u00f3digo, he vuelto a escribir el c\u00f3digo de cabeza y puede ser que haya alg\u00fan error, lo revisar\u00e9, pero lo importante es la idea de hacer una clase que envuelva la inicializaci\u00f3n del mutex de pthread.\n\n\n#include \"Mutex.h\"\n#include <exception>\n\n\nMutex::Mutex()\n{\n    if ( pthread_mutex_init(&_mutex, NULL) )\n    {\n        throw \"Error: Initializing _mutex\";\n    }\n}\n\nMutex::~Mutex()\n{\n\n    pthread_mutex_destroy(&_mutex);\n}\n\nMutex::Mutex(const Mutex & obj)\n{\n\t_mutex = obj._mutex;\n}\n\nMutex & Mutex::operator=(const Mutex & obj)\n{\n\t_mutex = obj._mutex;\n\treturn *this;\n}\n\nbool Mutex::operator==(const Mutex & obj)\n{\n\treturn _mutex == obj._mutex;\n}\n\nbool Mutex::operator!=(const Mutex & obj)\n{\n\treturn !(*this == obj);\n}\n\nvoid Mutex::lock ()\n{\n    pthread_mutex_lock( &_mutex );\n}\n\nvoid Mutex::unlock ()\n{\n    pthread_mutex_unlock( &_mutex );\n}\n\nvoid Mutex::lock ( int lock, Mutex * mtx)\n{\n\tif (lock)\n\t{\n\t\tmtx->lock();\n\t}\n\telse\n\t{\n\t\tmtx->unlock();\n\t}\n}", 
      "tags": "C++,pthread", 
      "loc": "/posts/cpp-mutex.html", 
      "title": "Mutex C++"
    }, 
    {
      "text": "He estado escuchando una charla de A. Jesse Jiryu Davis sobre la librer\u00eda asycnio de Python.\nSe trata de una librer\u00eda introducida en la versi\u00f3n 3.4 de Python que da soporte a programaci\u00f3n concurrente sobre un solo hilo, lo cual supone un ahorro muy importante de memoria.\nEn la charla nos cuenta qu\u00e9 es, c\u00f3mo funciona, cu\u00e1ndo utilizarlo y cu\u00e1ndo no.", 
      "tags": "Programming,Python", 
      "loc": "/posts/async-what-how-when.html", 
      "title": "Python asyncio: Qu\u00e9, C\u00f3mo, C\u00faando"
    }, 
    {
      "text": "He visto en Google Science Fair una colecci\u00f3n de ecuaciones que han cambiado el mundo.\nEn mi opini\u00f3n, comprender algunas de estas ecuaciones deber\u00eda entrar en lo que llamamos \"Cultura General\".", 
      "tags": "G+,Math,Pysics,Science", 
      "loc": "/posts/equations-that-changed-the-word.html", 
      "title": "Ecuaciones que han cambiado el Mundo"
    }, 
    {
      "text": "Supongo que, como la mayor\u00eda, vengo del concepto de software de gesti\u00f3n de blogs o gestores de contenidos din\u00e1micos, basados en:\nenviar informaci\u00f3n desde un navegador a un servidor\nprocesar y almacenar la informaci\u00f3n en una base de datos o en ficheros\nel servidor genera una respuesta din\u00e1micamente que se env\u00eda al navegador en forma de HTMLpara generar esta respuesta se suele leer de la base de datos o de los ficheros\n\nDe todo este proceso se encarga un software instalado en el servidor, nuestro gestor de contenidos.\nAhora he cambiado al paradigma de \"generador de sitios web est\u00e1ticos\", en concreto voy a utilizar Nikola, aunque esta vez no lo voy a instalar en ning\u00fan servidor.\nEn otro post os contar\u00e9 c\u00f3mo he montado esto con Github [1] y Travis [2].\nMi camino para llegar hasta los generadores de sitios web est\u00e1ticos ha pasado por las etapas que os cuento abajo (me he saltado alguna menos importante).\n\nCamino hasta Nikola\nPhpNuke\nMi propio gestor de contenidos\nDrupal\nWordpress\nCMSdj\nNikola\n\n\n\nPhpNuke\nS\u00ed, sigue existiendo. Aqu\u00ed entramos un gestor de contenido basado PHP+MySQL, multi-idioma, gesti\u00f3n de usuarios, grupos de usuarios, ampliable con temas, plugins, etc.\n\n\nMi propio gestor de contenidos\nQue no era tal, porque se qued\u00f3 en un blog en el que pod\u00eda publicar contenidos din\u00e1micamente, tambi\u00e9n hecho en PHP y MySQL. Me sirvi\u00f3 para:\nPublicar posts con problemas.\nDarme cuenta de que un programador necesita a un dise\u00f1ador.\nPHP a nivel sint\u00e1ctico, es feo (cuesti\u00f3n de gustos).\nEmpezar a entender la importancia de DRY [3].\n\n\nDrupal\nUn gestor de contenidos muy completo, que me gust\u00f3 mucho, hasta que se empezaron a \"romper\" cosas (comparto culpa con Drupal) y me cans\u00e9. Pero quiero remarcar que tiene todo lo que yo pod\u00eda esperar de un gestor de contenidos y m\u00e1s.\n\n\nWordpress\nYa no voy a entrar en si es mejor o peor que Drupal, que de eso hay mucho por Internet. Simplemente es mucho m\u00e1s usable y f\u00e1cil de actualizar.\n\n\nCMSdj\nMi segundo intento de creaci\u00f3n de mi propio gestor de contenidos. Ten\u00eda una idea en la cabeza, de c\u00f3mo deber\u00eda ser un dise\u00f1o del modelo de un gestor de contenidos, todav\u00eda la tengo. Y recientemente hab\u00eda descubierto Django, un framework que me encant\u00f3 hecho con un lenguaje que me encanta, Python, \u00bfqui\u00e9n se puede resistir ahora a crear su propio CMS [4]?\nCMSdj est\u00e1 por ah\u00ed en Bitbucket y funciona, tiene su propio buscador, gesti\u00f3n de templates, sistema de comentarios, sistema de votaci\u00f3n, acercamiento a HTML5 + CSS3 y algunas cosillas m\u00e1s, pero:\nYa no sacaba tiempo para desarrollar, un par de horas a la semana, como mucho, y gastaba una hora en recordar por donde iba.\nSegu\u00eda necesitando un dise\u00f1ador.\nAs\u00ed que declar\u00e9 este proyecto muerto por aburrimiento, aunque segu\u00ed utiliz\u00e1ndolo para publicar mis cosillas, pero cada vez que iba a escribir algo en mi blog y ve\u00eda todo a medio hacer, me pon\u00eda malo, as\u00ed que decid\u00ed cerrar y empezar de nuevo.\n\n\nNikola\nTengo que decir que quer\u00eda un generador de sitios est\u00e1ticos, porque est\u00e1n de moda y toda la gente escribe sobre sus bondades y me convencieron. Prob\u00e9 Jekyll para que no me lo contaran, que es el m\u00e1s famoso. Pero prefer\u00eda uno hecho en Python por si quer\u00eda meter mano alguna vez. As\u00ed que despu\u00e9s de buscar un poco, me qued\u00e9 entre Nikola, Mynt y Pelican. Me qued\u00e9 con Nikola  por descarte:\n* Pelican me di\u00f3 algunos problemas en la utilizaci\u00f3n de varios idiomas y en las categor\u00edas, aunque de primeras fue el que m\u00e1s me convenci\u00f3. De hecho, es posible que esos problemas los crease yo, pero no quer\u00eda gastar mucho tiempo en investigar.\n* Mynt me encant\u00f3 por su sencillez, aunque tienes que hacerte tus propios templates y no quiero darme cuenta otra vez de lo que necesito a un dise\u00f1ador.\n[1]En Github alojo el sitio generado, toda la parte est\u00e1tica (las p\u00e1ginas en HTML, im\u00e1genes, etc.)[2]Travis es un software the integraci\u00f3n cont\u00ednua (como Jenkins), yo lo utilizo para automatizar el despliegue del sitio, esto es, para descargar el sitio cada vez que lo cambie en Github, volver a generarlo y publicarlo otra vez.[3]Don't Repeat Yourself (En espa\u00f1ol, \"no te repitas\")[4]Content Management System (\"Sistema de gesti\u00f3n de contenidos\")", 
      "tags": "Python,Static Sites", 
      "loc": "/posts/primer-post.html", 
      "title": "Primer Post utilizando Nikola"
    }, 
    {
      "text": "Para quien quiera utilizar Android Studio sin instalarlo, como un programa \"portable\", aqu\u00ed os dejo el enlace a la \u00faltima versi\u00f3n de Android Studio.", 
      "tags": "Android,Java,Software", 
      "loc": "/posts/android-studio-portable-download.html", 
      "title": "Android Studio Portable Download"
    }, 
    {
      "text": "Trabajando con libtool [1], cuando vamos a depurar un ejecutable que utiliza una librer\u00eda generada con libtool, es posible que nos encontremos con el siguiente error:\n\n$ gdb ./tests-mylib\n\"tests-mylib\": not in executable format: File format not recognized\n\nlibmylib.so es una librer\u00eda din\u00e1mica generada con libtool\ntests-mylib es un ejecutable que utiliza la librer\u00eda mylib\nPara los que est\u00e9is pensando que se me ha olvidado poner la opci\u00f3n de compilaci\u00f3n -g, lo siento, pero este error ocurre aunque utilicemos -g.\nEl error es debido a que estamos intentando ejecutar un script generado por libtool, es una envoltura sobre el programa real, para facilitar la ejecuci\u00f3n de \u00e9ste [libtooldoc].\nPara poder depurar nuestro programa de prueba tests-mylib\n\nlibtool --mode=execute gdb tests-mylib\n\n[1]Herramienta que pertenece a la Autotools usada para crear bibliotecas de software portables.[libtooldoc]Esta informaci\u00f3n la he sacado de http://www.gnu.org/software/libtool/manual/libtool.html#Debugging-executables", 
      "tags": "Autotools,C++,GNU,Tips and Tricks", 
      "loc": "/posts/debug-libtool-lib.html", 
      "title": "Depurar librer\u00eda generada con libtool"
    }, 
    {
      "text": "Un struct de C++ es un elemento que permite agrupar elementos de tipos distintos con alguna relaci\u00f3n entre ellos. Esto permite manipular todos los elementos en bloque mediante una \u00fanica referencia.\nSi alguna vez nos interesa trabajar a un nivel m\u00e1s bajo, nos puede resultar \u00fatil entender c\u00f3mo se mapea una estructura en memoria y c\u00f3mo controlar este mapeo.\n\nTabla de Contenidos\nEstructura de ejemplo\nLa directiva #pragma pack en struct C++\nRendimiento\n\n\n\nEstructura de ejemplo\nEsta estructura estar\u00e1 compuesta por dos campos, un entero (4 bytes) y un booleano (un byte). En C++ queda de la siguiente forma:\n\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\n\nSi hacemos un sizeof de la una instancia de la estructura deber\u00edamos obtener un tama\u00f1o de 5 bytes. Y la memoria quedar\u00eda de la siguiente forma:\n\nEstructura de 5 bytes que realmente ocupa 5 bytes en memoria.\n\nPero no es tan sencillo, a continuaci\u00f3n veremos que no nos podemos olvidar de la alineaci\u00f3n de la memoria que hace el compilador en ese sistema y veremos c\u00f3mo controlarlo para no encontrarnos con tama\u00f1os inesperados, ya que esto depende del compilador del sistema.\nPor ejemplo, si en mi m\u00e1quina hago un sizeof de la estructura, obtengo un tama\u00f1o de 8 bytes. Lo que est\u00e1 sucediendo es que el compilador reserva m\u00e1s memoria al final de la estructura para que cuadre en bloques de 2n bytes. La memoria queda de la siguiente forma:\n\nEstructura de 5 bytes que realmente ocupa 8 bytes en memoria. Para ser m\u00e1s precisos, deber\u00eda haber dibujado la memoria no usada a continuaci\u00f3n del atributo flag.\n\nVamos a ver un fragmento de c\u00f3digo que imprime el tama\u00f1o de la estructura y el de cada uno de sus atributos y verificar, en este caso 4 + 1 no es 5.\n\n#include  <iostream>\n\nusing namespace std;\n\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\n\nstatic void print (size_t sz, size_t sz_flag, size_t sz_timeout)\n{\n    cout << \"\\tflag: \" << sz_flag << \" Bytes\" << endl;\n    cout << \"\\t+\" << endl;\n    cout << \"\\ttimeout: \" << sz_timeout << \" Bytes\" << endl;\n    cout << \"\\t=\" << endl;\n    cout << \"\\t\" << sz_timeout + sz_flag << \" Bytes\" << endl;\n    cout <<\"sizeof struct:  \" << sz << \" Bytes\" << endl;\n}\n\nint main(int argc, char *argv[])\n{\n    cout << \"SampleStruct\" << endl;\n    print (sizeof(SampleStruct), sizeof(SampleStruct::flag), sizeof(SampleStruct::timeout));\n    cout << \" -- \" << endl;\n\n    return 0;\n}\n\nEjecutando el c\u00f3digo de sin la directiva pragma, tenemos que nuestra estructura ocupa 8 bytes en lugar de 5 bytes.\n\nSampleStruct\nflag: 1 Bytes\n+\ntimeout: 4 Bytes\n=\n5 Bytes\nsizeof struct:  8 Bytes\n--\n\n\nTip\nSi queremos conocer el tama\u00f1o exacto de las estructuras que vamos a utilizar, tenemos que especificar al compilador la forma de alinear la estructura en memoria, para ello utilizaremos la directiva #pragma pack(n).\n\n\n\nLa directiva #pragma pack en struct C++\nSe trata de una directiva del preprocesador que indica al compilador c\u00f3mo debe realizar la alineaci\u00f3n de la memoria. Vamos a ver como se comporta con un ejemplo:\n\n#include <iostream>\n\nusing namespace std;\n\nstatic void print (size_t sz, size_t sz_flag, size_t sz_timeout)\n{\n    cout << \" flag: \" << sz_flag << \" Bytes\"<< endl;\n    cout << \" +\" << endl;\n    cout << \" timeout: \" << sz_timeout << \"Bytes\" << endl;\n    cout << \" =\" << endl;\n    cout << \" \" << sz_timeout + sz_flag << \"Bytes\" << endl;\n    cout << \" sizeof struct:  \" << sz << \" Bytes\" << endl;\n}\n\n#pragma pack (1)\nstruct SampleStructPack1\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (2)\nstruct SampleStructPack2\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (4)\nstruct SampleStructPack4\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\n\n\nint main(int argc, char *argv[])\n{\n\n    cout << \"SampleStructPack1\" << endl;\n    print (sizeof(SampleStructPack1), sizeof(SampleStructPack1::flag), sizeof(SampleStructPack1::timeout));\n    cout << \" -- \" << endl;\n\n    cout << \"SampleStructPack2\" << endl;\n    print (sizeof(SampleStructPack2), sizeof(SampleStructPack2::flag), sizeof(SampleStructPack2::timeout));\n\n    cout << \"SampleStructPack4\" << endl;\n    print (sizeof(SampleStructPack4), sizeof(SampleStructPack4::flag), sizeof(SampleStructPack4::timeout));\n\n    cout << \"SampleStruct\" << endl;\n    print (sizeof(SampleStruct), sizeof(SampleStruct::flag), sizeof(SampleStruct::timeout));\n    cout << \" -- \" << endl;\n\n    return 0;\n}\n\nEjecutando el c\u00f3digo de con las directivas pragma, tenemos distintos resultados dependiendo del valor de pragma.\n\nSampleStructPack1\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  5 Bytes\n --\n\nSampleStructPack2\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  6 Bytes\n\nSampleStructPack4\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes\n\nSampleStruct\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes\n --\n\nVeamos caso por caso:\nSampleStructPack1 #pragma pack (1)\nReserva bloques de memoria de un byte, nuestra estructura se ha ajustado perfectamente; en este caso s\u00ed que 4 + 1 = 5.\nSampleStructPack2 #pragma pack (2)\nAhora el m\u00ednimo tama\u00f1o del bloque de memoria es de 2 bytes. Para el entero, hay un ajuste exacto porque necesita 2 bloques que 2 bytes para alojar sus 4 bytes.\nPara el caso del booleano, necesita un bloque de 1 byte, pero como m\u00ednimo tiene que asignar un bloque de 2 bytes, por eso en total reserva 6 bytes, 4 + 2 = 6.\nSampleStructPack4 #pragma pack (4)\nEs el mismo caso que el anterior, aunque  en el caso del booleano, hay un mayor \"desperdicio\" de memoria. Necesita 1 byte, pero reserva 4 bytes que es tama\u00f1o m\u00ednimo de bloque de memoria que puede asignar el compilador.\nSampleStruct (alineaci\u00f3n por defecto del compilador)\nComo vemos se comporta exactamente igual que #pragma pack (4), podemos deducir que la alineaci\u00f3n por defecto del compilador que estamos utilizando es de 4 bytes.\n\nImportant\n\u00bfPor qu\u00e9 no utilizamos siempre la alineaci\u00f3n de memoria m\u00e1s ajustada (#pragma pack (1)) para aprovechar mejor la memoria?\n\nWarning\nPorque perderemos rendimiento.\n\n\n\n\nRendimiento\nVamos a hacer una prueba simple de rendimiento, en la que se va a reservar el mismo n\u00famero de elementos en arrays para cada tipo de estructura.\nEste es el resultado:\n\nSampleStructPack1: 500000000000000000 bytes allocated in 94311 nanoseconds\nSampleStructPack2: 600000000000000000 bytes allocated in 1777 nanoseconds\nSampleStructPack4: 800000000000000000 bytes allocated in 1519 nanoseconds\n\nComo vemos cuanto m\u00e1s ajustada es la alineaci\u00f3n de memoria, m\u00e1s tiempo se tarda en reservar y liberar. Puedes ejecutar la prueba de rendimiento en este enlace.\nA continuaci\u00f3n pego el c\u00f3digo de la prueba de rendimiento.\n\n#include <iostream>\n#include <chrono>\n\n#pragma pack (1)\nstruct SampleStructPack1\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (2)\nstruct SampleStructPack2\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n#pragma pack (4)\nstruct SampleStructPack4\n{\n    bool flag;\n    unsigned int timeout;\n};\n#pragma pack(0)\n\n\nstruct SampleStruct\n{\n    bool flag;\n    unsigned int timeout;\n};\n\nstatic const long MAX_ELEMENTS = 100000000000000000;\nusing namespace std;\nusing namespace std::chrono;\n\nvoid allocate1()\n{\n    SampleStructPack1 elements [MAX_ELEMENTS];\n    cout << \"SampleStructPack1: \" << sizeof(elements) << \" bytes allocated\";\n}\n\nvoid allocate2()\n{\n    SampleStructPack2 elements [MAX_ELEMENTS];\n    cout << \"SampleStructPack2: \" << sizeof(elements) << \" bytes allocated\";\n}\n\nvoid allocate4()\n{\n    SampleStructPack4 elements [MAX_ELEMENTS];\n    cout << \"SampleStructPack4: \" << sizeof(elements) << \" bytes allocated\";\n}\n\nvoid chrono1()\n{\n    auto begin = high_resolution_clock::now() ;\n    allocate1();\n    cout << \" in \" << duration_cast<nanoseconds>(high_resolution_clock::now() - begin).count() << \" nanoseconds\" << endl;\n}\n\nvoid chrono2()\n{\n    auto begin = high_resolution_clock::now() ;\n    allocate2();\n    cout << \" in \" << duration_cast<nanoseconds>(high_resolution_clock::now() - begin).count() << \" nanoseconds\" << endl;\n}\n\nvoid chrono4()\n{\n    auto begin = high_resolution_clock::now() ;\n    allocate4();\n    cout << \" in \" << duration_cast<nanoseconds>(high_resolution_clock::now() - begin).count() << \" nanoseconds\" << endl;\n}\n\n\nint main(int argc, char *argv[])\n{\n    chrono1();\n    chrono2();\n    chrono4();\n\n    return 0;\n}", 
      "tags": "C++", 
      "loc": "/posts/cpp-pragma-pack.html", 
      "title": "Mapeo de un struct C++ en Memoria"
    }, 
    {
      "text": "Es muy tedioso trabajar desde una red con proxy, al menos para m\u00ed, pierdo un mont\u00f3n de tiempo configurando software para que se actualice y funcione correctamente.\nVamos a ver c\u00f3mo configurar git para que utilice un proxy determinado.\nEsta es una descripci\u00f3n m\u00e1s o menos gen\u00e9rica de como hacer que git utilice un proxy determinado:\n\n#para http\ngit config --global http.proxy <protocolo>://<nombre de usuario>:<password>@<direccion_ip>:<puerto>\n\n#para https\ngit config --global https.proxy <protocolo>://<nombre de usuario>:<password>@<direccion_ip>:<puerto>\n\n#para deshabilitar el uso del proxy\ngit config --global --unset http.proxy\n\nM\u00e1s informaci\u00f3n en la configuraci\u00f3n oficial de Git.\n[protocolo]Suele ser http o https", 
      "tags": "Git,Proxy,Tips and Tricks", 
      "loc": "/posts/git-proxy-config.html", 
      "title": "Configuraci\u00f3n de proxy para Git"
    }, 
    {
      "text": "A continuaci\u00f3n muestro una forma de eliminar los signos de puntuaci\u00f3n de una cadena de caract\u00e9res en Python. Los signos de puntuaci\u00f3n son reemplazados por caract\u00e9res en blanco.\n\nimport re, string\n\ndef remove_punctuation ( text ):\n    return re.sub('[%s]' % re.escape(string.punctuation), ' ', text)\n\nEjecutando:\n\n>>> remove_punctuation (\"El perro, de San Roque, no tiene rabo; ni nunca lo ha tenido.\")\n'El perro  de San Roque  no tiene rabo  ni nunca lo ha tenido '\n\nSi queremos hacer la funci\u00f3n m\u00e1s general, para reemplazar los signos de puntuaci\u00f3n por cualquier otra cadena, simplemente hay que hacer la siguiente modificaci\u00f3n en la funci\u00f3n.\n\nimport re, string\n\ndef replace_punctuation ( text, replace ):\n  return re.sub('[%s]' % re.escape(string.punctuation), replace, text)\n\nEjecutando el c\u00f3digo de arriba:\n\n>>> replace_punctuation (\"El perro, de San Roque, no tiene rabo; ni nunca lo ha tenido.\", '[stop]')\n'El perro[stop] de San Roque[stop] no tiene rabo[stop] ni nunca lo ha tenido[stop]'", 
      "tags": "Python,Tips and Tricks", 
      "loc": "/posts/remove-replace-punctuation-py.html", 
      "title": "Eliminar/Reemplazar signos de puntuaci\u00f3n en Python"
    }, 
    {
      "text": "En muchos idiomas, como es el caso del espa\u00f1ol, hay caracteres que no tienen representaci\u00f3n ASCII, como por ejemplo la \u00e1 (que s\u00ed que tiene representaci\u00f3n en Unicode).\nPara evitar problemas o por simplificar, se ha dado una equivalencia entre los caracteres Unicode y los ASCII.\nA continuaci\u00f3n os pondr\u00e9 un trozo de c\u00f3digo en Python que hace esta conversi\u00f3n.\n\n# -*- coding: utf-8 -*-\nfrom unicodedata import normalize\n\ndef normalize_text ( text ):\n  return normalize('NFKD', text).encode('ASCII', 'ignore')\n\nEjecutando el ejemplo:\n\n>>> normalize_text ( 'a\u00e1a\u00e1 e\u00e9e\u00e9 i\u00edi\u00ed o\u00f3o\u00f3 \u00f1n\u00f1n A\u00c0A\u00c0' )\nb'aaaa eeee iiii oooo nnnn AAAA'", 
      "tags": "Python,Tips and Tricks", 
      "loc": "/posts/normalize-text-py.html", 
      "title": "Normalizar texto en Python"
    }, 
    {
      "text": "No se c\u00f3mo no conoc\u00eda este sitio, con la cabeza que tengo y lo bien que me habr\u00eda venido. Se trata de cheat-sheets.org, agrupa tarjetas, gu\u00edas de referencia r\u00e1pidas, chuletas, etc. de much\u00edsimos lenguajes de programaci\u00f3n y software.", 
      "tags": "Cheat Sheet,Tips and Tricks", 
      "loc": "/posts/cheat-sheets-for-developers.html", 
      "title": "Chuletas para desarrolladores"
    }, 
    {
      "text": "Cuando instalamos un paquete en las distribuciones Linux (en las que yo conozco), se instalan otros paquetes (dependencias).\nSi en el futuro desinstalas ese paquete, esas dependencias quedar\u00e1n instaladas en el sistema, aunque no ser\u00e1n usadas por nadie, simplemente ocupar\u00e1n espacio en disco. Estas dependencias son llamadas paquetes hu\u00e9rfanos.\n\nDesinstalar paquetes hu\u00e9rfanos\nArchlinux\nDebian\n\n\n\nArchlinux\nCuando instalamos un paquete en Archlinux pacman -S nombre_paquete se nos descargan autom\u00e1ticamente las dependencias de este paquete. Esto resulta muy c\u00f3mo, pero cuando eliminamos el paquete que instalamos con pacman -R nombre_paquete, se nos quedan instaladas las dependencias de \u00e9ste. Para evitar \u00e9sto, podemos desinstalar los paquetes con pacman -Rscn nombre_paquete, pero si preferimos desinstalar normalmente solo con la opci\u00f3n -R, despu\u00e9s podemos eliminar todos los paquetes hu\u00e9rfanos de la siguiente forma:\n\npacman -Rsn $(pacman -Qdtq)\n\nEl funcionamiento es muy sencillo:\nla sentencia pacman -Qdt da un listado de todos los paquetes hu\u00e9rfanos\npacman -Rsn elimina los paquetes listados\n\n\nDebian\nEn distribuciones basadas en Debian, pasa lo mismo que en Archlinux (bueno para ser justos en Archlinux pasa lo mismo que en Debian, un respeto a la edad). Para eliminar estos paquetes, que solamente est\u00e1n ocupando espacio en disco, simplemente hay que ejecutar el siguiente comando.\n\napt-get remove --purge $(deborphan)", 
      "tags": "Archlinux,Debian,Linux,Tips and Tricks", 
      "loc": "/posts/linux-remove-orphaned-files.html", 
      "title": "Eliminar paquetes hu\u00e9rfanos en Linux"
    }, 
    {
      "text": "Python\nFunci\u00f3n encargada de eliminar las etiquetas HTML:\n\n#main.py\n\nimport re\n\ndef strip_tags(value):\nreturn re.sub(r'<[>]*?>', '', value)\n\nSuponiendo que tenemos el siguiente HTML\n\n<!DOCTYPE HTML>\n<html>\n        <head>\n                <title>Title</title>\n        </head>\n        <body>\n                <p>Paragraph</p>\n        </body>\n</html>\n\nVamos a hacer una prueba pasandolo como par\u00e1metro de la funci\u00f3n strip_tags:\n\n#main.py\n\nhtml_text = \"\"\"\n        <!DOCTYPE HTML>\n        <html>\n                <head>\n                        <title>Title</title>\n                </head>\n                <body>\n                        <p>Paragraph</p>\n                </body>\n        </html>\"\"\"\n\nprint strip_tags(html_text)\n\nSi ejecutamos el script tenemos como resultado:\n\nTitle\n\nParagraph\n\nY si con Python ha sido f\u00e1cil, vamos a ver con Django\n\n\nDjango\n\n#main.py\n\nfrom django.utils.html import strip_tags\n\nhtml_text = \"\"\"\n        <!DOCTYPE HTML>\n        <html>\n                <head>\n                        <title>Title</title>\n                </head>\n                <body>\n                        <p>Paragraph</p>\n                </body>\n        </html>\"\"\"\n\nprint strip_tags( html_text )\n\nMucho m\u00e1s sencillo, porque la funci\u00f3n ya est\u00e1 escrita.", 
      "tags": "Django,HTML,Python", 
      "loc": "/posts/delete-html-tags-py-django.html", 
      "title": "Eliminar etiquetas HTML"
    }
  ]
}