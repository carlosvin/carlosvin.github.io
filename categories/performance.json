{"category":"Performance","posts":[{"sectids":"","toc-placement":"auto","notitle":"","stylesheet":"","webfonts":"","prewrap":"","attribute-undefined":"drop-line","attribute-missing":"skip","iconfont-remote":"","caution-caption":"Caution","important-caption":"Important","note-caption":"Note","tip-caption":"Tip","warning-caption":"Warning","example-caption":"Example","figure-caption":"Figure","table-caption":"Table","toc-title":"Table of Contents","section-refsig":"Section","part-refsig":"Part","chapter-refsig":"Chapter","appendix-refsig":"Appendix","appendix-caption":"Appendix","untitled-label":"Untitled","version-label":"Version","last-update-label":"Last updated","docfile":"cpp-pragma-pack.en.adoc","docdir":"","docfilesuffix":".adoc","docname":"cpp-pragma-pack.en","embedded":"","asciidoctor":"","asciidoctor-version":"2.0.10","safe-mode-name":"secure","safe-mode-secure":"","safe-mode-level":20,"max-include-depth":64,"user-home":".","backend":"html5","max-attribute-value-size":4096,"linkcss":"","doctype":"article","htmlsyntax":"html","backend-html5-doctype-article":"","doctype-article":"","backend-html5":"","outfilesuffix":".html","filetype":"html","filetype-html":"","basebackend-html-doctype-article":"","basebackend-html":"","basebackend":"html","stylesdir":".","iconsdir":"./images/icons","localdate":"2020-05-01","localyear":"2020","localtime":"00:40:40 +0200","localdatetime":"2020-05-01 00:40:40 +0200","docdate":"2020-04-19","docyear":"2020","doctime":"10:46:31 +0200","docdatetime":"2020-04-19 10:46:31 +0200","doctitle":"C++ Struct memory alignment","date":"2012/11/26 12:00:00","keywords":["C++","Performance","Compilers","Memory"],"lang":"en","toc":"","description":"Understanding pragma pack preprocessor directive and how it affects to memory alignment","authorcount":0,"title":"C++ Struct memory alignment","summary":"Understanding pragma pack preprocessor directive and how it affects to memory alignment","html":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_struct_example\">Struct example</a></li>\n<li><a href=\"#_pragma_pack_directive_in_c_struct\">#pragma pack directive in C++ struct</a></li>\n<li><a href=\"#_performance_test\">Performance test</a></li>\n</ul>\n</div>\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>A C++ struct is an element that groups attributes with different types so we can manipulate them all together using same reference. It is like a class with public visibility by default for functions and attributes.</p>\n</div>\n<div class=\"paragraph\">\n<p>If we want to work in a lower level, closer to machine, it might be useful understand how that data structure is stored in memory and how to control that mapping.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_struct_example\">Struct example</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>It has two attributes: an integer (4 bytes) and a boolean (1 byte).</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-c++\" data-lang=\"c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStruct</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If we get the instance size using <code>sizeof</code> we should get 5 bytes size and memory would be like:</p>\n</div>\n<div id=\"5-bytes\" class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/c-mem-struct/5b.png\" alt=\"5Bytes\" width=\"200\" height=\"auto\">\n</div>\n<div class=\"title\">Figure 1. 5 bytes struct which uses 5 bytes in memory</div>\n</div>\n<div class=\"paragraph\">\n<p><strong>But</strong> is not that simple, memory alignment depends on compiler and system. We will learn how to control compiler alignment policy, so we can avoid getting unexpected allocation memory sizes.</p>\n</div>\n<div class=\"paragraph\">\n<p>For example, in my local host, if I get the <code>sizeof</code> the previous structure without <code>pragma</code> declarations, <strong>I get a 8 bytes size</strong>. We are getting 8 Bytes instead of expected 5 Bytes because the compiler allocates more memory at the end of structure so it fits in 2n bytes blocks. Memory actually looks like:</p>\n</div>\n<div id=\"8-bytes\" class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/c-mem-struct/8b.png\" alt=\"5Bytes\" width=\"200\" height=\"auto\">\n</div>\n<div class=\"title\">Without pragma: 5 bytes structure that actually spends 8 bytes in memory</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">It prints structure and attributes size, in this case <strong>4 + 1 is not 5</strong></div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-c++\" data-lang=\"c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span>  <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStruct</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">size_t</span> sz, <span class=\"hljs-keyword\">size_t</span> sz_flag, <span class=\"hljs-keyword\">size_t</span> sz_timeout)</span>\n</span>{\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"\\tflag: \"</span> &lt;&lt; sz_flag &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"\\t+\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"\\ttimeout: \"</span> &lt;&lt; sz_timeout &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"\\t=\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"\\t\"</span> &lt;&lt; sz_timeout + sz_flag &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt;<span class=\"hljs-string\">\"sizeof struct:  \"</span> &lt;&lt; sz &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[])</span>\n</span>{\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStruct\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">print</span> (<span class=\"hljs-keyword\">sizeof</span>(SampleStruct), <span class=\"hljs-keyword\">sizeof</span>(SampleStruct::flag), <span class=\"hljs-keyword\">sizeof</span>(SampleStruct::timeout));\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" -- \"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\"><a href=\"https://coliru.stacked-crooked.com/a/7c18ee6585e57366\">Executing code with pragma pack directive</a>: We get 8 bytes instead of 5 bytes</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-bash\" data-lang=\"bash\">SampleStruct\nflag: 1 Bytes\n+\ntimeout: 4 Bytes\n=\n5 Bytes\nsizeof struct:  8 Bytes\n--</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nIf we want to know the exact structure size we have to specify compiler how to align the memory, to do so we have <code>#pragma pack(n)</code> directive.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_pragma_pack_directive_in_c_struct\">#pragma pack directive in C++ struct</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>It is a preprocessor directive to indicate to compiler how to align data in memory.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Example with different memory alignment configurations</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-c++\" data-lang=\"c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">size_t</span> sz, <span class=\"hljs-keyword\">size_t</span> sz_flag, <span class=\"hljs-keyword\">size_t</span> sz_timeout)</span>\n</span>{\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" flag: \"</span> &lt;&lt; sz_flag &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span>&lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" +\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" timeout: \"</span> &lt;&lt; sz_timeout &lt;&lt; <span class=\"hljs-string\">\"Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" =\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" \"</span> &lt;&lt; sz_timeout + sz_flag &lt;&lt; <span class=\"hljs-string\">\"Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" sizeof struct:  \"</span> &lt;&lt; sz &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n}\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (1)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack1</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (2)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack2</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (4)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack4</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStruct</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[])</span>\n</span>{\n\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack1\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">print</span> (<span class=\"hljs-keyword\">sizeof</span>(SampleStructPack1), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack1::flag), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack1::timeout));\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" -- \"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack2\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">print</span> (<span class=\"hljs-keyword\">sizeof</span>(SampleStructPack2), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack2::flag), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack2::timeout));\n\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack4\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">print</span> (<span class=\"hljs-keyword\">sizeof</span>(SampleStructPack4), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack4::flag), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack4::timeout));\n\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStruct\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">print</span> (<span class=\"hljs-keyword\">sizeof</span>(SampleStruct), <span class=\"hljs-keyword\">sizeof</span>(SampleStruct::flag), <span class=\"hljs-keyword\">sizeof</span>(SampleStruct::timeout));\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" -- \"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\"><a href=\"https://coliru.stacked-crooked.com/a/7c18ee6585e57366\">Executing code with pragma pack directive</a>, we have different results depending of pragma value.</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-bash\" data-lang=\"bash\">SampleStructPack1 <b class=\"conum\">(1)</b>\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  5 Bytes\n --\n\nSampleStructPack2 <b class=\"conum\">(2)</b>\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  6 Bytes\n\nSampleStructPack4 <b class=\"conum\">(3)</b>\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes\n\nSampleStruct <b class=\"conum\">(4)</b>\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p>SampleStructPack1 <code>#pragma pack (1)</code>: It allocates 1 byte memory block, so our sample struct fits perfectly, in this case it is true that <code>4 + 1 = 5</code>.</p>\n</li>\n<li>\n<p>SampleStructPack2 <code>#pragma pack (2)</code>: Minimum block size is 2 bytes. Integer attribute fits because it just needs 2 blocks of 2 Bytes. Boolean attribute needs just 1 Byte, but minimum block size is 2 Bytes, that&#8217;s why total allocated memory is 6 bytes, <code>4 + 2 = 6</code>.</p>\n</li>\n<li>\n<p>SampleStructPack4 <code>#pragma pack (4)</code>: It is like previous one, but in this case we are wasting more memory for boolean attribute, it needs 1 Byte, but we are allocating 4 Bytes.</p>\n</li>\n<li>\n<p>SampleStruct (default compiler alignment): As you can see it behaves exactly like <code>#pragma pack (4)</code>, so we can deduct it is the default compiler alignment.</p>\n</li>\n</ol>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Important</div>\n</td>\n<td class=\"content\">\nWhy don&#8217;t we always use smallest memory alignment (<code>#pragma pack (1)</code>) so we can save more memory?\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Warning</div>\n</td>\n<td class=\"content\">\nBecause of performance loss.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_performance_test\">Performance test</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The test will allocate same number of elements in arrays for each structure type (1, 2, 4).</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Test results: <a href=\"https://coliru.stacked-crooked.com/a/954ad542659c7591\">execute performance test</a></div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-bash\" data-lang=\"bash\">SampleStructPack1: 500000000000000000 bytes allocated <span class=\"hljs-keyword\">in</span> 94311 nanoseconds\nSampleStructPack2: 600000000000000000 bytes allocated <span class=\"hljs-keyword\">in</span> 1777 nanoseconds\nSampleStructPack4: 800000000000000000 bytes allocated <span class=\"hljs-keyword\">in</span> 1519 nanoseconds</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>As you can see, the smallest memory alignment spends more time allocating and releasing memory.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Performance test source code:</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-c++\" data-lang=\"c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;chrono&gt;</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (1)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack1</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (2)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack2</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (4)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack4</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStruct</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">long</span> MAX_ELEMENTS = <span class=\"hljs-number\">100000000000000000</span>;\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>::chrono;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">allocate1</span><span class=\"hljs-params\">()</span>\n</span>{\n    SampleStructPack1 elements [MAX_ELEMENTS];\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack1: \"</span> &lt;&lt; <span class=\"hljs-keyword\">sizeof</span>(elements) &lt;&lt; <span class=\"hljs-string\">\" bytes allocated\"</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">allocate2</span><span class=\"hljs-params\">()</span>\n</span>{\n    SampleStructPack2 elements [MAX_ELEMENTS];\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack2: \"</span> &lt;&lt; <span class=\"hljs-keyword\">sizeof</span>(elements) &lt;&lt; <span class=\"hljs-string\">\" bytes allocated\"</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">allocate4</span><span class=\"hljs-params\">()</span>\n</span>{\n    SampleStructPack4 elements [MAX_ELEMENTS];\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack4: \"</span> &lt;&lt; <span class=\"hljs-keyword\">sizeof</span>(elements) &lt;&lt; <span class=\"hljs-string\">\" bytes allocated\"</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">chrono1</span><span class=\"hljs-params\">()</span>\n</span>{\n    <span class=\"hljs-keyword\">auto</span> <span class=\"hljs-built_in\">begin</span> = high_resolution_clock::now() ;\n    allocate1();\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" in \"</span> &lt;&lt; duration_cast&lt;nanoseconds&gt;(high_resolution_clock::now() - <span class=\"hljs-built_in\">begin</span>).count() &lt;&lt; <span class=\"hljs-string\">\" nanoseconds\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">chrono2</span><span class=\"hljs-params\">()</span>\n</span>{\n    <span class=\"hljs-keyword\">auto</span> <span class=\"hljs-built_in\">begin</span> = high_resolution_clock::now() ;\n    allocate2();\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" in \"</span> &lt;&lt; duration_cast&lt;nanoseconds&gt;(high_resolution_clock::now() - <span class=\"hljs-built_in\">begin</span>).count() &lt;&lt; <span class=\"hljs-string\">\" nanoseconds\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">chrono4</span><span class=\"hljs-params\">()</span>\n</span>{\n    <span class=\"hljs-keyword\">auto</span> <span class=\"hljs-built_in\">begin</span> = high_resolution_clock::now() ;\n    allocate4();\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" in \"</span> &lt;&lt; duration_cast&lt;nanoseconds&gt;(high_resolution_clock::now() - <span class=\"hljs-built_in\">begin</span>).count() &lt;&lt; <span class=\"hljs-string\">\" nanoseconds\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n}\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[])</span>\n</span>{\n    chrono1();\n    chrono2();\n    chrono4();\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n</div>\n</div>\n</div>\n</div>","slug":"cpp-pragma-pack"},{"sectids":"","toc-placement":"auto","notitle":"","stylesheet":"","webfonts":"","prewrap":"","attribute-undefined":"drop-line","attribute-missing":"skip","iconfont-remote":"","caution-caption":"Caution","important-caption":"Important","note-caption":"Note","tip-caption":"Tip","warning-caption":"Warning","example-caption":"Example","figure-caption":"Figure","table-caption":"Table","toc-title":"Table of Contents","section-refsig":"Section","part-refsig":"Part","chapter-refsig":"Chapter","appendix-refsig":"Appendix","appendix-caption":"Appendix","untitled-label":"Untitled","version-label":"Version","last-update-label":"Last updated","docfile":"cpp-pragma-pack.es.adoc","docdir":"","docfilesuffix":".adoc","docname":"cpp-pragma-pack.es","embedded":"","asciidoctor":"","asciidoctor-version":"2.0.10","safe-mode-name":"secure","safe-mode-secure":"","safe-mode-level":20,"max-include-depth":64,"user-home":".","backend":"html5","max-attribute-value-size":4096,"linkcss":"","doctype":"article","htmlsyntax":"html","backend-html5-doctype-article":"","doctype-article":"","backend-html5":"","outfilesuffix":".html","filetype":"html","filetype-html":"","basebackend-html-doctype-article":"","basebackend-html":"","basebackend":"html","stylesdir":".","iconsdir":"./images/icons","localdate":"2020-05-01","localyear":"2020","localtime":"00:40:41 +0200","localdatetime":"2020-05-01 00:40:41 +0200","docdate":"2020-04-19","docyear":"2020","doctime":"10:46:31 +0200","docdatetime":"2020-04-19 10:46:31 +0200","doctitle":"Alineación de una Estructura C++ en Memoria","date":"2012/11/26 12:00:00","keywords":["C++","Performance","Compilers","Memory"],"description":"Comprendiendo cómo funciona la directiva C++ pragma pack y cómo afecta a la alineación de la memoria","lang":"es","previewimage":"/images/c-mem-struct/5b.png","toc":"","authorcount":0,"title":"Alineación de una Estructura C++ en Memoria","summary":"Comprendiendo cómo funciona la directiva C++ pragma pack y cómo afecta a la alineación de la memoria","html":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_estructura_de_ejemplo\">Estructura de ejemplo</a></li>\n<li><a href=\"#_la_directiva_pragma_pack_en_struct_c\">La directiva #pragma pack en struct C++</a></li>\n<li><a href=\"#_rendimiento\">Rendimiento</a></li>\n</ul>\n</div>\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Un struct de C++ es un elemento que permite agrupar elementos de tipos distintos con alguna relación entre ellos. Esto permite manipular todos los elementos en bloque mediante una única referencia. Podemos considerarlo como una clase con visibilidad publica por defecto para sus atributos y funciones.</p>\n</div>\n<div class=\"paragraph\">\n<p>Si alguna vez nos interesa trabajar a un nivel más bajo, nos puede resultar útil entender cómo se mapea una estructura en memoria y cómo controlar este mapeo.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_estructura_de_ejemplo\">Estructura de ejemplo</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Esta estructura estará compuesta por dos campos, un entero (4 bytes) y un booleano (un byte). En C++ queda de la siguiente forma:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-c++\" data-lang=\"c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStruct</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Si hacemos un <code>sizeof</code> de una instancia de la estructura deberíamos obtener un tamaño de 5 bytes. Y la memoria quedaría de la siguiente forma:</p>\n</div>\n<div id=\"5-bytes\" class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/c-mem-struct/5b.png\" alt=\"5Bytes\" width=\"200\" height=\"auto\">\n</div>\n<div class=\"title\">Figure 1. Estructura de 5 bytes que realmente ocupa 5 bytes en memoria</div>\n</div>\n<div class=\"paragraph\">\n<p><strong>Pero</strong> no es tan sencillo, a continuación veremos que no nos podemos olvidar de la alineación de la memoria que hace el compilador en ese sistema y veremos cómo controlarlo para no encontrarnos con tamaños inesperados, ya que esto depende del compilador del sistema.</p>\n</div>\n<div class=\"paragraph\">\n<p>Por ejemplo, si en mi máquina hago un <code>sizeof</code> de la estructura de ejemplo, <strong>obtengo un tamaño de 8 bytes</strong>. Lo que está sucediendo es que el compilador reserva más memoria al final de la estructura para que cuadre en bloques de 2n Bytes. La memoria realmente queda de la siguiente forma:</p>\n</div>\n<div id=\"8-bytes\" class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/c-mem-struct/8b.png\" alt=\"5Bytes\" width=\"200\" height=\"auto\">\n</div>\n<div class=\"title\">Sin pragma: Estructura de 5 Bytes que realmente ocupa 8 Bytes en memoria</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Fragmento de código que imprime el tamaño de la estructura y el de cada uno de sus atributos, en este caso 4 + 1 no es 5</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-c++\" data-lang=\"c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span>  <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStruct</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">size_t</span> sz, <span class=\"hljs-keyword\">size_t</span> sz_flag, <span class=\"hljs-keyword\">size_t</span> sz_timeout)</span>\n</span>{\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"\\tflag: \"</span> &lt;&lt; sz_flag &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"\\t+\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"\\ttimeout: \"</span> &lt;&lt; sz_timeout &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"\\t=\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"\\t\"</span> &lt;&lt; sz_timeout + sz_flag &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt;<span class=\"hljs-string\">\"sizeof struct:  \"</span> &lt;&lt; sz &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[])</span>\n</span>{\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStruct\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">print</span> (<span class=\"hljs-keyword\">sizeof</span>(SampleStruct), <span class=\"hljs-keyword\">sizeof</span>(SampleStruct::flag), <span class=\"hljs-keyword\">sizeof</span>(SampleStruct::timeout));\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" -- \"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\"><a href=\"https://coliru.stacked-crooked.com/a/c7deb3df49bebd40\">Ejecutando el código sin la directiva pragma</a>, tenemos que nuestra estructura ocupa 8 bytes en lugar de 5 bytes.</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-bash\" data-lang=\"bash\">SampleStruct\nflag: 1 Bytes\n+\ntimeout: 4 Bytes\n=\n5 Bytes\nsizeof struct:  8 Bytes\n--</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nSi queremos conocer el tamaño exacto de las estructuras que vamos a utilizar, tenemos que especificar al compilador la forma de alinear la estructura en memoria, para ello utilizaremos la directiva <code>#pragma pack(n)</code>.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_la_directiva_pragma_pack_en_struct_c\">La directiva #pragma pack en struct C++</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Se trata de una directiva del preprocesador que indica al compilador cómo debe realizar la alineación de la memoria.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Ejemplo con diferentes configuraciones de alineamiento de memoria</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-c++\" data-lang=\"c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">size_t</span> sz, <span class=\"hljs-keyword\">size_t</span> sz_flag, <span class=\"hljs-keyword\">size_t</span> sz_timeout)</span>\n</span>{\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" flag: \"</span> &lt;&lt; sz_flag &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span>&lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" +\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" timeout: \"</span> &lt;&lt; sz_timeout &lt;&lt; <span class=\"hljs-string\">\"Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" =\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" \"</span> &lt;&lt; sz_timeout + sz_flag &lt;&lt; <span class=\"hljs-string\">\"Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" sizeof struct:  \"</span> &lt;&lt; sz &lt;&lt; <span class=\"hljs-string\">\" Bytes\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n}\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (1)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack1</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (2)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack2</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (4)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack4</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStruct</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[])</span>\n</span>{\n\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack1\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">print</span> (<span class=\"hljs-keyword\">sizeof</span>(SampleStructPack1), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack1::flag), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack1::timeout));\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" -- \"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack2\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">print</span> (<span class=\"hljs-keyword\">sizeof</span>(SampleStructPack2), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack2::flag), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack2::timeout));\n\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack4\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">print</span> (<span class=\"hljs-keyword\">sizeof</span>(SampleStructPack4), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack4::flag), <span class=\"hljs-keyword\">sizeof</span>(SampleStructPack4::timeout));\n\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStruct\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    <span class=\"hljs-built_in\">print</span> (<span class=\"hljs-keyword\">sizeof</span>(SampleStruct), <span class=\"hljs-keyword\">sizeof</span>(SampleStruct::flag), <span class=\"hljs-keyword\">sizeof</span>(SampleStruct::timeout));\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" -- \"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\"><a href=\"https://coliru.stacked-crooked.com/a/7c18ee6585e57366\">Ejecutando el código con las directivas pragma</a>, tenemos distintos resultados dependiendo del valor de pragma.</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-bash\" data-lang=\"bash\">SampleStructPack1 <b class=\"conum\">(1)</b>\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  5 Bytes\n --\n\nSampleStructPack2 <b class=\"conum\">(2)</b>\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  6 Bytes\n\nSampleStructPack4 <b class=\"conum\">(3)</b>\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes\n\nSampleStruct <b class=\"conum\">(4)</b>\n flag: 1 Bytes\n +\n timeout: 4Bytes\n =\n 5Bytes\n sizeof struct:  8 Bytes</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p>SampleStructPack1 <code>#pragma pack (1)</code>: Reserva bloques de memoria de un byte, nuestra estructura se ha ajustado perfectamente; en este caso sí que <code>4 + 1 = 5</code>.</p>\n</li>\n<li>\n<p>SampleStructPack2 <code>#pragma pack (2)</code>: Ahora el mínimo tamaño del bloque de memoria es de 2 bytes. Para el entero, hay un ajuste exacto porque necesita 2 bloques que 2 bytes para alojar sus 4 bytes. Para el caso del booleano, necesita un bloque de 1 byte, pero como mínimo tiene que asignar un bloque de 2 bytes, por eso en total reserva 6 bytes, <code>4 + 2 = 6</code>.</p>\n</li>\n<li>\n<p>SampleStructPack4 <code>#pragma pack (4)</code>: Es el mismo caso que el anterior, aunque en el caso del booleano, hay un mayor \"desperdicio\" de memoria. Necesita 1 byte, pero reserva 4 bytes que es tamaño mínimo de bloque de memoria que puede asignar el compilador.</p>\n</li>\n<li>\n<p>SampleStruct (default compiler alignment): Como vemos se comporta exactamente igual que <code>#pragma pack (4)</code>, podemos deducir que la alineación por defecto del compilador que estamos utilizando es de 4 bytes.</p>\n</li>\n</ol>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Important</div>\n</td>\n<td class=\"content\">\n¿Por qué no utilizamos siempre la alineación de memoria más ajustada (<code>#pragma pack (1)</code>) para aprovechar mejor la memoria?\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Warning</div>\n</td>\n<td class=\"content\">\nPorque perderemos rendimiento.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rendimiento\">Rendimiento</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vamos a hacer una prueba simple de rendimiento, en la que se va a reservar el mismo número de elementos en arrays para cada tipo de estructura.</p>\n</div>\n<div class=\"paragraph\">\n<p>Este es el resultado:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\"><a href=\"https://coliru.stacked-crooked.com/a/954ad542659c7591\">Resultados de la prueba de rendimiento</a>.</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-bash\" data-lang=\"bash\">SampleStructPack1: 500000000000000000 bytes allocated <span class=\"hljs-keyword\">in</span> 94311 nanoseconds\nSampleStructPack2: 600000000000000000 bytes allocated <span class=\"hljs-keyword\">in</span> 1777 nanoseconds\nSampleStructPack4: 800000000000000000 bytes allocated <span class=\"hljs-keyword\">in</span> 1519 nanoseconds</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Como vemos cuanto más ajustada es la alineación de memoria, más tiempo se tarda en reservar y liberar.</p>\n</div>\n<div class=\"paragraph\">\n<p>A continuación pego el código de la prueba de rendimiento.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Código de las pruebas de rendimiento</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-c++\" data-lang=\"c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;chrono&gt;</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (1)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack1</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (2)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack2</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack (4)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStructPack4</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> pack(0)</span>\n\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">SampleStruct</span>\n{</span>\n    <span class=\"hljs-keyword\">bool</span> flag;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> timeout;\n};\n\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">long</span> MAX_ELEMENTS = <span class=\"hljs-number\">100000000000000000</span>;\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>::chrono;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">allocate1</span><span class=\"hljs-params\">()</span>\n</span>{\n    SampleStructPack1 elements [MAX_ELEMENTS];\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack1: \"</span> &lt;&lt; <span class=\"hljs-keyword\">sizeof</span>(elements) &lt;&lt; <span class=\"hljs-string\">\" bytes allocated\"</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">allocate2</span><span class=\"hljs-params\">()</span>\n</span>{\n    SampleStructPack2 elements [MAX_ELEMENTS];\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack2: \"</span> &lt;&lt; <span class=\"hljs-keyword\">sizeof</span>(elements) &lt;&lt; <span class=\"hljs-string\">\" bytes allocated\"</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">allocate4</span><span class=\"hljs-params\">()</span>\n</span>{\n    SampleStructPack4 elements [MAX_ELEMENTS];\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"SampleStructPack4: \"</span> &lt;&lt; <span class=\"hljs-keyword\">sizeof</span>(elements) &lt;&lt; <span class=\"hljs-string\">\" bytes allocated\"</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">chrono1</span><span class=\"hljs-params\">()</span>\n</span>{\n    <span class=\"hljs-keyword\">auto</span> <span class=\"hljs-built_in\">begin</span> = high_resolution_clock::now() ;\n    allocate1();\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" in \"</span> &lt;&lt; duration_cast&lt;nanoseconds&gt;(high_resolution_clock::now() - <span class=\"hljs-built_in\">begin</span>).count() &lt;&lt; <span class=\"hljs-string\">\" nanoseconds\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">chrono2</span><span class=\"hljs-params\">()</span>\n</span>{\n    <span class=\"hljs-keyword\">auto</span> <span class=\"hljs-built_in\">begin</span> = high_resolution_clock::now() ;\n    allocate2();\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" in \"</span> &lt;&lt; duration_cast&lt;nanoseconds&gt;(high_resolution_clock::now() - <span class=\"hljs-built_in\">begin</span>).count() &lt;&lt; <span class=\"hljs-string\">\" nanoseconds\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">chrono4</span><span class=\"hljs-params\">()</span>\n</span>{\n    <span class=\"hljs-keyword\">auto</span> <span class=\"hljs-built_in\">begin</span> = high_resolution_clock::now() ;\n    allocate4();\n    <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\" in \"</span> &lt;&lt; duration_cast&lt;nanoseconds&gt;(high_resolution_clock::now() - <span class=\"hljs-built_in\">begin</span>).count() &lt;&lt; <span class=\"hljs-string\">\" nanoseconds\"</span> &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n}\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[])</span>\n</span>{\n    chrono1();\n    chrono2();\n    chrono4();\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n</div>\n</div>\n</div>\n</div>","slug":"cpp-pragma-pack"},{"sectids":"","toc-placement":"auto","notitle":"","stylesheet":"","webfonts":"","prewrap":"","attribute-undefined":"drop-line","attribute-missing":"skip","iconfont-remote":"","caution-caption":"Caution","important-caption":"Important","note-caption":"Note","tip-caption":"Tip","warning-caption":"Warning","example-caption":"Example","figure-caption":"Figure","table-caption":"Table","toc-title":"Table of Contents","section-refsig":"Section","part-refsig":"Part","chapter-refsig":"Chapter","appendix-refsig":"Appendix","appendix-caption":"Appendix","untitled-label":"Untitled","version-label":"Version","last-update-label":"Last updated","docfile":"serialization-java-serializable-externalizable.en.adoc","docdir":"","docfilesuffix":".adoc","docname":"serialization-java-serializable-externalizable.en","embedded":"","asciidoctor":"","asciidoctor-version":"2.0.10","safe-mode-name":"secure","safe-mode-secure":"","safe-mode-level":20,"max-include-depth":64,"user-home":".","backend":"html5","max-attribute-value-size":4096,"linkcss":"","doctype":"article","htmlsyntax":"html","backend-html5-doctype-article":"","doctype-article":"","backend-html5":"","outfilesuffix":".html","filetype":"html","filetype-html":"","basebackend-html-doctype-article":"","basebackend-html":"","basebackend":"html","stylesdir":".","iconsdir":"./images/icons","localdate":"2020-05-01","localyear":"2020","localtime":"00:40:43 +0200","localdatetime":"2020-05-01 00:40:43 +0200","docdate":"2020-04-19","docyear":"2020","doctime":"10:46:31 +0200","docdatetime":"2020-04-19 10:46:31 +0200","doctitle":"Java serialization ways: Performance Comparison","date":"2014/05/13 17:00:00","lang":"en","toc":"","description":"Java serialization ways, performance comparison","keywords":["Java","Performance"],"java":"https://www.java.com[Java,window=_blank]","json":"https://www.json.org[JSON,window=_blank]","xml":"https://en.wikipedia.org/wiki/XML[XML,window=_blank]","serializable":"https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html[Serializable,window=_blank]","externalizable":"https://docs.oracle.com/javase/7/docs/api/java/io/Externalizable.html[Externalizable,window=_blank]","authorcount":0,"title":"Java serialization ways: Performance Comparison","summary":"Java serialization ways, performance comparison","html":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_serializable\">Serializable</a></li>\n<li><a href=\"#_externalizable\">Externalizable</a></li>\n<li><a href=\"#_performance_tests_serializable_vs_externalizable\">Performance tests (Serializable vs. Externalizable)</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_implementing_serializable\">Implementing Serializable</a></li>\n<li><a href=\"#_implementing_externalizable_wrong_way\">Implementing Externalizable (wrong way)</a></li>\n<li><a href=\"#_implementing_externalizable_right_way\">Implementing Externalizable (right way)</a></li>\n<li><a href=\"#_results_analysis\">Results Analysis</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Recently I&#8217;ve had to serialize/deserialize some data in <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a> binary format. Lately I use <a href=\"https://www.json.org\" target=\"_blank\" rel=\"noopener\">JSON</a> or <a href=\"https://en.wikipedia.org/wiki/XML\" target=\"_blank\" rel=\"noopener\">XML</a> formats.</p>\n</div>\n<div class=\"paragraph\">\n<p>I remember that to serialize <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a> objects they must implement the <a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html\" target=\"_blank\" rel=\"noopener\">Serializable</a> interface, but I had also read in Internet other way, implementing the <a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/Externalizable.html\" target=\"_blank\" rel=\"noopener\">Externalizable</a> interface, then, which interface must I implement? It depends on what you want such as everything in the life.</p>\n</div>\n<div class=\"paragraph\">\n<p>When to use <a href=\"#_serializable\">Serializable</a> or <a href=\"#_externalizable\">Externalizable</a>.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_serializable\">Serializable</h2>\n<div class=\"sectionbody\">\n<div class=\"ulist\">\n<ul>\n<li>\n<p>To serialize easily. You have to write less code.</p>\n</li>\n<li>\n<p>This way has some restrictions: The object to serialize must implement the default constructor (0 args). It must be responsible to manage the parent class attributes.</p>\n</li>\n<li>\n<p>The performance is not as important, we will see more about that in <a href=\"#_performance_tests_serializable_vs_externalizable\">Performance tests (Serializable vs. Externalizable)</a>.</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_externalizable\">Externalizable</h2>\n<div class=\"sectionbody\">\n<div class=\"ulist\">\n<ul>\n<li>\n<p>You must implement the serialization/deserialization methods, so you have to write more code.</p>\n</li>\n<li>\n<p>When you cannot use <a href=\"#_serializable\">Serializable</a>.</p>\n</li>\n<li>\n<p>When you want to improve the performance, as we&#8217;ll see in <a href=\"#_performance_tests_serializable_vs_externalizable\">Performance tests (Serializable vs. Externalizable)</a>.</p>\n</li>\n<li>\n<p>If you have to manage the serialization of parent class attributes, then I recommend you use <a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/Externalizable.html\" target=\"_blank\" rel=\"noopener\">Externalizable</a>, because we&#8217;ll avoid a weird private methods overriding.</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">writeObject</span><span class=\"hljs-params\">(ObjectOutputStream oos)</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">readObject</span><span class=\"hljs-params\">(ObjectInputStream ois)</span></span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_performance_tests_serializable_vs_externalizable\">Performance tests (Serializable vs. Externalizable)</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><a href=\"#_serializable\">Serializable</a>: Java, through introspection, guesses the types of class attributes to know how to serialize/deserialize them, but this \"magic\" is not free, it has a performance penalty.</p>\n</div>\n<div class=\"paragraph\">\n<p>When we use <a href=\"#_externalizable\">Externalizable</a> interface, we decide how to serialize/deserialize, namely we have to write the code that does it. We&#8217;ve lost ease, but also we avoid that <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a> does some tasks, so if we override the methods properly, we&#8217;ll get a performance improvement.</p>\n</div>\n<div class=\"paragraph\">\n<p>To know how big is the performance difference between both interfaces, I&#8217;ve written a <a href=\"https://github.com/carlosvin/serializations-performance-java\" target=\"_blank\" rel=\"noopener\">tiny example in which we serialize an object with 2 collections with 100000 elements each one</a>. Here you can find the <a href=\"http://carlosvin.github.io/serializations-performance-java/classes/com.github.carlosvin.contacts.SerializationTest.html\" target=\"_blank\" rel=\"noopener\">tests execution results</a>. There are 3 different implementations:</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_implementing_serializable\">Implementing Serializable</h3>\n<div class=\"paragraph\">\n<p>As we mentioned above, <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a> has to guess certain things. During this process it sacrifices some of performance (slowest way), in exchange we get really simple source code, the class to serialize just has to implement the <a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html\" target=\"_blank\" rel=\"noopener\">Serializable</a> interface.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Contacts</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Serializable</span> </span>{\n  <span class=\"hljs-comment\">// ...</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>serializing: 1133 millisecond</p>\n</li>\n<li>\n<p>deserializing: 506 millisecond</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_implementing_externalizable_wrong_way\">Implementing Externalizable (wrong way)</h3>\n<div class=\"paragraph\">\n<p>If the class implements <a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/Externalizable.html\" target=\"_blank\" rel=\"noopener\">Externalizable</a>, we must tell to <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a> how it has to serialize/deserialize the class attributes. We just have to be careful, because if we did it bad, then we&#8217;ll get the worst of the both worlds: more complex implementation and bad performance, i.e: If we serialize/deserialize complex class attributes (like collections), <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a> will also have to guess many things about the attributes type.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">readExternal</span><span class=\"hljs-params\">(ObjectInput in)</span> <span class=\"hljs-keyword\">throws</span> IOException, ClassNotFoundException </span>{\n  setEmails((Set&lt;String&gt;) in.readObject());\n  setPhones((Set&lt;String&gt;) in.readObject());\n}\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">writeExternal</span><span class=\"hljs-params\">(ObjectOutput out)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n  out.writeObject(emails);\n  out.writeObject(phones);\n}</code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>serializing: 737 millisecond</p>\n</li>\n<li>\n<p>deserializing: 367 millisecond</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_implementing_externalizable_right_way\">Implementing Externalizable (right way)</h3>\n<div class=\"paragraph\">\n<p>If we serialize one by one the collection elements, then we&#8217;ll save more time, because <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a> serializes simple types, this way avoids guessing things that we actually know.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">readExternal</span><span class=\"hljs-params\">(ObjectInput in)</span> <span class=\"hljs-keyword\">throws</span> IOException, ClassNotFoundException </span>{\n  emails.clear();\n  phones.clear();\n  <span class=\"hljs-keyword\">int</span> nEmails = in.readInt();\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; nEmails; i++) {\n    emails.add(in.readUTF());\n  }\n  <span class=\"hljs-keyword\">int</span> nPhones = in.readInt();\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; nPhones; i++) {\n    phones.add(in.readUTF());\n  }\n}\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">writeExternal</span><span class=\"hljs-params\">(ObjectOutput out)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n  out.writeInt(emails.size());\n  <span class=\"hljs-keyword\">for</span> (String e : emails) {\n    out.writeUTF(e);\n  }\n  out.writeInt(phones.size());\n  <span class=\"hljs-keyword\">for</span> (String p : phones) {\n    out.writeUTF(p);\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>serializing: 204 millisecond</p>\n</li>\n<li>\n<p>deserializing: 92 millisecond</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>We&#8217;ve gained performance at expense of write more code.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_results_analysis\">Results Analysis</h3>\n<div class=\"paragraph\">\n<p>We don&#8217;t gain performance due to use an interface or the other one.</p>\n</div>\n<div class=\"paragraph\">\n<p>We gain performance because <a href=\"#_externalizable\">Externalizable</a> interface forces us to implement ourselves the guessing code, so <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a> doesn&#8217;t have to do that.</p>\n</div>\n<div class=\"paragraph\">\n<p>As we have seen at <a href=\"#_implementing_externalizable_wrong_way\">Implementing Externalizable (wrong way)</a>, si no tenemos cuidado, conseguiremos una mejora poco significativa a costa de complicar nuestro código fuente.</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"http://carlosvin.github.io/serializations-performance-java/classes/com.github.carlosvin.contacts.SerializationTest.html\" target=\"_blank\" rel=\"noopener\">Test results</a>.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/carlosvin/serializations-performance-java/\">Code in Github</a>.</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>","slug":"serialization-java-serializable-externalizable"},{"sectids":"","toc-placement":"auto","notitle":"","stylesheet":"","webfonts":"","prewrap":"","attribute-undefined":"drop-line","attribute-missing":"skip","iconfont-remote":"","caution-caption":"Caution","important-caption":"Important","note-caption":"Note","tip-caption":"Tip","warning-caption":"Warning","example-caption":"Example","figure-caption":"Figure","table-caption":"Table","toc-title":"Table of Contents","section-refsig":"Section","part-refsig":"Part","chapter-refsig":"Chapter","appendix-refsig":"Appendix","appendix-caption":"Appendix","untitled-label":"Untitled","version-label":"Version","last-update-label":"Last updated","docfile":"serialization-java-serializable-externalizable.es.adoc","docdir":"","docfilesuffix":".adoc","docname":"serialization-java-serializable-externalizable.es","embedded":"","asciidoctor":"","asciidoctor-version":"2.0.10","safe-mode-name":"secure","safe-mode-secure":"","safe-mode-level":20,"max-include-depth":64,"user-home":".","backend":"html5","max-attribute-value-size":4096,"linkcss":"","doctype":"article","htmlsyntax":"html","backend-html5-doctype-article":"","doctype-article":"","backend-html5":"","outfilesuffix":".html","filetype":"html","filetype-html":"","basebackend-html-doctype-article":"","basebackend-html":"","basebackend":"html","stylesdir":".","iconsdir":"./images/icons","localdate":"2020-05-01","localyear":"2020","localtime":"00:40:43 +0200","localdatetime":"2020-05-01 00:40:43 +0200","docdate":"2020-04-19","docyear":"2020","doctime":"10:46:31 +0200","docdatetime":"2020-04-19 10:46:31 +0200","doctitle":"Distintas formas de serialización en Java: Comparación de rendimiento","date":"2014/05/13 17:00:00","lang":"es","toc":"","description":"Comparación de rendimientos entre distintas formas de serialización en Java","keywords":["Java","Performance"],"java":"https://www.java.com[Java,window=_blank]","json":"https://www.json.org[JSON,window=_blank]","xml":"https://en.wikipedia.org/wiki/XML[XML,window=_blank]","serializable":"https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html[Serializable,window=_blank]","externalizable":"https://docs.oracle.com/javase/7/docs/api/java/io/Externalizable.html[Externalizable,window=_blank]","authorcount":0,"title":"Distintas formas de serialización en Java: Comparación de rendimiento","summary":"Comparación de rendimientos entre distintas formas de serialización en Java","html":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_serializable\">Serializable</a></li>\n<li><a href=\"#_externalizable\">Externalizable</a></li>\n<li><a href=\"#_pruebas_de_rendimiento_serializable_vs_externalizable\">Pruebas de Rendimiento (Serializable vs Externalizable)</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_implementando_el_interfaz_serializable\">Implementando el interfaz Serializable</a></li>\n<li><a href=\"#_utilizando_el_interfaz_externalizable_mal\">Utilizando el interfaz Externalizable (mal)</a></li>\n<li><a href=\"#_utilizando_el_interfaz_externalizable_correctamente\">Utilizando el interfaz Externalizable (correctamente)</a></li>\n<li><a href=\"#_analizando_los_resultados\">Analizando los resultados</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Hace poco, he tenido que serializar/deserializar unos datos en <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a>, hacía mucho que no lo hacía en formato binario directamente (ultimamente he utilizado <a href=\"https://www.json.org\" target=\"_blank\" rel=\"noopener\">JSON</a> o <a href=\"https://en.wikipedia.org/wiki/XML\" target=\"_blank\" rel=\"noopener\">XML</a>). Recordaba haber serializado objetos implementando el interfaz <a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html\" target=\"_blank\" rel=\"noopener\">Serializable</a>, pero había visto por Internet otra forma implementando el interfaz <a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/Externalizable.html\" target=\"_blank\" rel=\"noopener\">Externalizable</a>, ¿cuál interfaz utilizo? Pues depende lo que quieras y necesites, como todo.</p>\n</div>\n<div class=\"paragraph\">\n<p>Veamos cuándo utilizar <a href=\"#_serializable\">Serializable</a> o <a href=\"#_externalizable\">Externalizable</a>.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_serializable\">Serializable</h2>\n<div class=\"sectionbody\">\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Cuando quieras escribir poco código, es la forma fácil.</p>\n</li>\n<li>\n<p>Pero tiene algunas restricciones: El objeto a serializar debe implementar el constructor por defecto. Debe hacerse responsable de los atributos no accesibles de la clase padre.</p>\n</li>\n<li>\n<p>Cuando no te importe mucho el rendimiento, como veremos en la sección <a href=\"#_pruebas_de_rendimiento_serializable_vs_externalizable\">Pruebas de Rendimiento (Serializable vs Externalizable)</a>.</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_externalizable\">Externalizable</h2>\n<div class=\"sectionbody\">\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Vas a tener que implementar tú mismo los métodos de serialización.</p>\n</li>\n<li>\n<p>Cuando no puedas utilizar <a href=\"#_serializable\">Serializable</a>.</p>\n</li>\n<li>\n<p>Cuando quieras obtener un mejor rendimiento, como veremos en la sección <a href=\"#_pruebas_de_rendimiento_serializable_vs_externalizable\">Pruebas de Rendimiento (Serializable vs Externalizable)</a>.</p>\n</li>\n<li>\n<p>Si tienes que encargarte de la serialización de los atributos de la clase padre, te recomiendo utilizar <a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/Externalizable.html\" target=\"_blank\" rel=\"noopener\">Externalizable</a>, porque evitamos una sobrescritura extraña de métodos privados.</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">writeObject</span><span class=\"hljs-params\">(ObjectOutputStream oos)</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">readObject</span><span class=\"hljs-params\">(ObjectInputStream ois)</span></span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_pruebas_de_rendimiento_serializable_vs_externalizable\">Pruebas de Rendimiento (Serializable vs Externalizable)</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>El interfaz <a href=\"#_serializable\">Serializable</a> utilizando la introspección de <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a>, adivina los tipos de los atributos de las clases que va a serializar/deserializar, pero esta \"magia\" tiene una penalización en el rendimiento.</p>\n</div>\n<div class=\"paragraph\">\n<p>Al utilizar el interfaz <a href=\"#_externalizable\">Externalizable</a> somos nosotros los que decidimos cómo serializar/deserializar los objetos, es decir, tenemos que escribir nosotros el código que hace esto. Hemos perdido comodidad, pero evitamos que <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a> haga algunas tareas y, si sobrescribimos correctamente los métodos del interfaz <a href=\"#_externalizable\">Externalizable</a>, conseguiremos una mejora de rendimiento.</p>\n</div>\n<div class=\"paragraph\">\n<p>Para saber cuánto es la diferencia de rendimiento, he escrito un <a href=\"https://github.com/carlosvin/serializations-performance-java\" target=\"_blank\" rel=\"noopener\">pequeño ejemplo en el que se serializa un objeto con dos colecciones con 100000 emails y 100000 teléfonos</a>. He contemplado 3 casos:</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_implementando_el_interfaz_serializable\">Implementando el interfaz Serializable</h3>\n<div class=\"paragraph\">\n<p>Como dijimos más arriba, cuando implementamos el interfaz <a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html\" target=\"_blank\" rel=\"noopener\">Serializable</a>, <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a> tiene que adivinar ciertas cosas, en este proceso sacrifica algo de rendimiento (es el que más tarda), a cambio ĺo único que tenemos que hacer es que nuestra clase implemente el interfaz <a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html\" target=\"_blank\" rel=\"noopener\">Serializable</a>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Contacts</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Serializable</span> </span>{\n  <span class=\"hljs-comment\">// ...</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>1133 milisegundos en serializar</p>\n</li>\n<li>\n<p>506 milisegundos en deserializar</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_utilizando_el_interfaz_externalizable_mal\">Utilizando el interfaz Externalizable (mal)</h3>\n<div class=\"paragraph\">\n<p>En este caso somos nosotros los encargados de \"decir\" a <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a> cómo debe serializar/deserializar, pero debemos ser cuidadosos, de lo contrario podemos quedarnos con lo peor de los dos mundos, por ejemplo: Si simplemente serializamos/deserializamos los atributos de la clase, y estos son atributos complejos (como colecciones), <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a> también tiene que adivinar bastantes cosas y también sacrificamos algo de rendimiento y además hemos tenido que escribir más código.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">readExternal</span><span class=\"hljs-params\">(ObjectInput in)</span> <span class=\"hljs-keyword\">throws</span> IOException, ClassNotFoundException </span>{\n  setEmails((Set&lt;String&gt;) in.readObject());\n  setPhones((Set&lt;String&gt;) in.readObject());\n}\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">writeExternal</span><span class=\"hljs-params\">(ObjectOutput out)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n  out.writeObject(emails);\n  out.writeObject(phones);\n}</code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>737 milisegundos en serializar</p>\n</li>\n<li>\n<p>367 milisegundos en deserializar</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_utilizando_el_interfaz_externalizable_correctamente\">Utilizando el interfaz Externalizable (correctamente)</h3>\n<div class=\"paragraph\">\n<p>Si serializamos/deserializamos uno por uno los elementos de las colecciones, ahorramos aún más tiempo, porque <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a> está serializando tipos más simples (en este caso java.lang.String).</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">readExternal</span><span class=\"hljs-params\">(ObjectInput in)</span> <span class=\"hljs-keyword\">throws</span> IOException, ClassNotFoundException </span>{\n  emails.clear();\n  phones.clear();\n  <span class=\"hljs-keyword\">int</span> nEmails = in.readInt();\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; nEmails; i++) {\n    emails.add(in.readUTF());\n  }\n  <span class=\"hljs-keyword\">int</span> nPhones = in.readInt();\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; nPhones; i++) {\n    phones.add(in.readUTF());\n  }\n}\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">writeExternal</span><span class=\"hljs-params\">(ObjectOutput out)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n  out.writeInt(emails.size());\n  <span class=\"hljs-keyword\">for</span> (String e : emails) {\n    out.writeUTF(e);\n  }\n  out.writeInt(phones.size());\n  <span class=\"hljs-keyword\">for</span> (String p : phones) {\n    out.writeUTF(p);\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>204 milisegundos en serializar</p>\n</li>\n<li>\n<p>92 milisegundos en deserializar</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Hemos ganado rendimiento a costa de escribir un poco más de código.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_analizando_los_resultados\">Analizando los resultados</h3>\n<div class=\"paragraph\">\n<p>Por el hecho de utilizar un interfaz u otro, no ganamos rendimiento.</p>\n</div>\n<div class=\"paragraph\">\n<p>Ganamos rendimiento porque el interfaz <a href=\"#_externalizable\">Externalizable</a> nos \"obliga\" a implementar parte de la serialización y quitamos esta carga a <a href=\"https://www.java.com\" target=\"_blank\" rel=\"noopener\">Java</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Aunque como hemos visto en <a href=\"#_utilizando_el_interfaz_externalizable_mal\">Utilizando el interfaz Externalizable (mal)</a>, si no tenemos cuidado, conseguiremos una mejora poco significativa a costa de complicar nuestro código fuente.</p>\n</div>\n<div class=\"paragraph\">\n<p>A continuación os dejo los enlaces a:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"http://carlosvin.github.io/serializations-performance-java/classes/com.github.carlosvin.contacts.SerializationTest.html\">Resultados de los tests</a>.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/carlosvin/serializations-performance-java/\">Código en github</a>.</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>","slug":"serialization-java-serializable-externalizable"}]}