<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Vin's Blog (pthread)</title><link>http://carlosvin.github.io/</link><description></description><language>es</language><lastBuildDate>Wed, 11 Jun 2014 11:24:19 GMT</lastBuildDate><generator>http://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Mutex C++</title><link>http://carlosvin.github.io/posts/cpp-mutex.html</link><dc:creator>Carlos Martín Sánchez</dc:creator><description>&lt;p&gt;En &lt;a class="reference external" href="http://es.wikipedia.org/wiki/C%2B%2B11"&gt;C++11&lt;/a&gt; se han introducido muchas mejoras que nos ayudan a desarrollar sistemas multi-hilo. Voy a centrarme en los &lt;a class="reference external" href="http://es.wikipedia.org/wiki/Exclusi%C3%B3n_mutua_(inform%C3%A1tica)"&gt;mutex&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;En las versiones anteriores a &lt;a class="reference external" href="http://es.wikipedia.org/wiki/C%2B%2B11"&gt;C++11&lt;/a&gt; una forma de obtener un &lt;a class="reference external" href="http://es.wikipedia.org/wiki/Exclusi%C3%B3n_mutua_(inform%C3%A1tica)"&gt;mutex&lt;/a&gt; es el que nos proporciona la librería &lt;a class="reference external" href="http://en.wikipedia.org/wiki/POSIX_Threads"&gt;pthread&lt;/a&gt;, pero para utilizarlo debíabos inicializarlo y destruirlo en estilo &lt;a class="reference external" href="http://es.wikipedia.org/wiki/C_(lenguaje_de_programaci%C3%B3n)"&gt;C&lt;/a&gt;, en definitiva, tienes que hacer algo más que lock/unlock cada vez que trabajas con un mutex.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://es.wikipedia.org/wiki/C%2B%2B11"&gt;C++11&lt;/a&gt; nos proporciona una &lt;a class="reference external" href="http://es.cppreference.com/w/cpp/thread/mutex"&gt;clase mutex&lt;/a&gt;, que nos abstrae de cosas que no son lock/unclock. Os recomiendo que echéis un vistazo y veáis lo limpio que queda el código: &lt;a class="reference external" href="http://es.cppreference.com/w/cpp/thread/mutex"&gt;Clase mutex de C++11&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Si sigues trabajando con &lt;a class="reference external" href="http://clang.llvm.org/cxx_status.html"&gt;versiones de compiladores previos a C++11&lt;/a&gt;, hace tiempo me hice un wrapper que te ayuda a abstraerte del mutex de pthread, lo dejo aquí abajo por si a alguien le resulta útil.&lt;/p&gt;
&lt;p&gt;Abajo está un &lt;a class="reference external" href="https://gist.github.com/carlosvin/11257689"&gt;Gist del Código&lt;/a&gt;, he vuelto a escribir el código de cabeza y puede ser que haya algún error, lo revisaré, pero lo importante es la idea de hacer una clase que envuelva la inicialización del mutex de pthread.&lt;/p&gt;
&lt;script src="https://gist.github.com/11257689.js"&gt;&lt;/script&gt;&lt;noscript&gt;&lt;pre class="literal-block"&gt;
#include "Mutex.h"
#include &amp;lt;exception&amp;gt;


Mutex::Mutex()
{
    if ( pthread_mutex_init(&amp;amp;_mutex, NULL) )
    {
        throw "Error: Initializing _mutex";
    }
}

Mutex::~Mutex()
{

    pthread_mutex_destroy(&amp;amp;_mutex);
}

Mutex::Mutex(const Mutex &amp;amp; obj)
{
	_mutex = obj._mutex;
}

Mutex &amp;amp; Mutex::operator=(const Mutex &amp;amp; obj)
{
	_mutex = obj._mutex;
	return *this;
}

bool Mutex::operator==(const Mutex &amp;amp; obj)
{
	return _mutex == obj._mutex;
}

bool Mutex::operator!=(const Mutex &amp;amp; obj)
{
	return !(*this == obj);
}

void Mutex::lock ()
{
    pthread_mutex_lock( &amp;amp;_mutex );
}

void Mutex::unlock ()
{
    pthread_mutex_unlock( &amp;amp;_mutex );
}

void Mutex::lock ( int lock, Mutex * mtx)
{
	if (lock)
	{
		mtx-&amp;gt;lock();
	}
	else
	{
		mtx-&amp;gt;unlock();
	}
}


&lt;/pre&gt;
&lt;/noscript&gt;</description><category>C++</category><category>pthread</category><guid>http://carlosvin.github.io/posts/cpp-mutex.html</guid><pubDate>Thu, 24 Apr 2014 15:50:00 GMT</pubDate></item></channel></rss>